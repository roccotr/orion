/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ThrfAlog_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kiEstatetypeValues[] = {
  iEstatetype::UPSERT,
  iEstatetype::DELTMB
};
const char* _kiEstatetypeNames[] = {
  "UPSERT",
  "DELTMB"
};
const std::map<int, const char*> _iEstatetype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kiEstatetypeValues, _kiEstatetypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEcolumntypeValues[] = {
  iEcolumntype::KEYTYPE___,
  iEcolumntype::STRINGTYPE,
  iEcolumntype::LSTRNGTYPE,
  iEcolumntype::INTEGRTYPE,
  iEcolumntype::LINTGRTYPE,
  iEcolumntype::DOUBLETYPE,
  iEcolumntype::LDOUBLTYPE,
  iEcolumntype::BOOLN_TYPE
};
const char* _kiEcolumntypeNames[] = {
  "KEYTYPE___",
  "STRINGTYPE",
  "LSTRNGTYPE",
  "INTEGRTYPE",
  "LINTGRTYPE",
  "DOUBLETYPE",
  "LDOUBLTYPE",
  "BOOLN_TYPE"
};
const std::map<int, const char*> _iEcolumntype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kiEcolumntypeValues, _kiEcolumntypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEconditiontypeValues[] = {
  iEconditiontype::ECOND,
  iEconditiontype::GCOND,
  iEconditiontype::LCOND,
  iEconditiontype::GECOND,
  iEconditiontype::LECOND
};
const char* _kiEconditiontypeNames[] = {
  "ECOND",
  "GCOND",
  "LCOND",
  "GECOND",
  "LECOND"
};
const std::map<int, const char*> _iEconditiontype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kiEconditiontypeValues, _kiEconditiontypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEopcodetypeValues[] = {
  iEopcodetype::MUTATOR,
  iEopcodetype::REPAIR_
};
const char* _kiEopcodetypeNames[] = {
  "MUTATOR",
  "REPAIR_"
};
const std::map<int, const char*> _iEopcodetype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kiEopcodetypeValues, _kiEopcodetypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEquerytypeValues[] = {
  iEquerytype::EXACTQUERY,
  iEquerytype::RANGEQUERY,
  iEquerytype::TOKENQUERY,
  iEquerytype::TKALLQUERY,
  iEquerytype::TKSLWQUERY
};
const char* _kiEquerytypeNames[] = {
  "EXACTQUERY",
  "RANGEQUERY",
  "TOKENQUERY",
  "TKALLQUERY",
  "TKSLWQUERY"
};
const std::map<int, const char*> _iEquerytype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kiEquerytypeValues, _kiEquerytypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEordertypeValues[] = {
  iEordertype::ASC,
  iEordertype::DESC
};
const char* _kiEordertypeNames[] = {
  "ASC",
  "DESC"
};
const std::map<int, const char*> _iEordertype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kiEordertypeValues, _kiEordertypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEstategossipnodeValues[] = {
  iEstategossipnode::RUNNING,
  iEstategossipnode::JOINING,
  iEstategossipnode::LEAVING,
  iEstategossipnode::STOPPED,
  iEstategossipnode::LOADING
};
const char* _kiEstategossipnodeNames[] = {
  "RUNNING",
  "JOINING",
  "LEAVING",
  "STOPPED",
  "LOADING"
};
const std::map<int, const char*> _iEstategossipnode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kiEstategossipnodeValues, _kiEstategossipnodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEreservedkeywordValues[] = {
  iEreservedkeyword::STARTUP,
  iEreservedkeyword::SHUTDOWN,
  iEreservedkeyword::VERS,
  iEreservedkeyword::NETWORK,
  iEreservedkeyword::ADD,
  iEreservedkeyword::REMOVE,
  iEreservedkeyword::JOIN,
  iEreservedkeyword::LEAVE,
  iEreservedkeyword::TABLET,
  iEreservedkeyword::STORE,
  iEreservedkeyword::FORGET,
  iEreservedkeyword::LOAD,
  iEreservedkeyword::STATS,
  iEreservedkeyword::READ,
  iEreservedkeyword::WRITE,
  iEreservedkeyword::INFO,
  iEreservedkeyword::TOUCH,
  iEreservedkeyword::KILL,
  iEreservedkeyword::STOPTHRIFT,
  iEreservedkeyword::STARTTHRIFT,
  iEreservedkeyword::DISCONNECT,
  iEreservedkeyword::RESETLOCAL,
  iEreservedkeyword::STATSTHRIFT,
  iEreservedkeyword::ANTIENTROPHY,
  iEreservedkeyword::PULLALL,
  iEreservedkeyword::PPULLMATCH,
  iEreservedkeyword::PPULLREPAIR,
  iEreservedkeyword::TABLE,
  iEreservedkeyword::REBUILD,
  iEreservedkeyword::SPLIT,
  iEreservedkeyword::JOINFAST,
  iEreservedkeyword::STOPSEDA,
  iEreservedkeyword::STARTSEDA,
  iEreservedkeyword::ADDFAST,
  iEreservedkeyword::FREEZE,
  iEreservedkeyword::RELOAD,
  iEreservedkeyword::TOP,
  iEreservedkeyword::CLEAN,
  iEreservedkeyword::PURGE,
  iEreservedkeyword::REPAIR,
  iEreservedkeyword::TRUNCATE,
  iEreservedkeyword::SHRINK,
  iEreservedkeyword::SOFTSHRINK,
  iEreservedkeyword::COMPACTION,
  iEreservedkeyword::REMOVEFAST,
  iEreservedkeyword::LEAVEFAST,
  iEreservedkeyword::REBUILDPART,
  iEreservedkeyword::SIZE,
  iEreservedkeyword::CLONE,
  iEreservedkeyword::REBOUND,
  iEreservedkeyword::REJOIN,
  iEreservedkeyword::NORMAL,
  iEreservedkeyword::ABORT
};
const char* _kiEreservedkeywordNames[] = {
  "STARTUP",
  "SHUTDOWN",
  "VERS",
  "NETWORK",
  "ADD",
  "REMOVE",
  "JOIN",
  "LEAVE",
  "TABLET",
  "STORE",
  "FORGET",
  "LOAD",
  "STATS",
  "READ",
  "WRITE",
  "INFO",
  "TOUCH",
  "KILL",
  "STOPTHRIFT",
  "STARTTHRIFT",
  "DISCONNECT",
  "RESETLOCAL",
  "STATSTHRIFT",
  "ANTIENTROPHY",
  "PULLALL",
  "PPULLMATCH",
  "PPULLREPAIR",
  "TABLE",
  "REBUILD",
  "SPLIT",
  "JOINFAST",
  "STOPSEDA",
  "STARTSEDA",
  "ADDFAST",
  "FREEZE",
  "RELOAD",
  "TOP",
  "CLEAN",
  "PURGE",
  "REPAIR",
  "TRUNCATE",
  "SHRINK",
  "SOFTSHRINK",
  "COMPACTION",
  "REMOVEFAST",
  "LEAVEFAST",
  "REBUILDPART",
  "SIZE",
  "CLONE",
  "REBOUND",
  "REJOIN",
  "NORMAL",
  "ABORT"
};
const std::map<int, const char*> _iEreservedkeyword_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(53, _kiEreservedkeywordValues, _kiEreservedkeywordNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEtablettypeValues[] = {
  iEtablettype::MEMORYTABLETYPE,
  iEtablettype::SSTABLETYPE
};
const char* _kiEtablettypeNames[] = {
  "MEMORYTABLETYPE",
  "SSTABLETYPE"
};
const std::map<int, const char*> _iEtablettype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kiEtablettypeValues, _kiEtablettypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEservicetypeValues[] = {
  iEservicetype::STATEMENT,
  iEservicetype::QUERY,
  iEservicetype::OSQL
};
const char* _kiEservicetypeNames[] = {
  "STATEMENT",
  "QUERY",
  "OSQL"
};
const std::map<int, const char*> _iEservicetype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kiEservicetypeValues, _kiEservicetypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kiEbulkservicetypeValues[] = {
  iEbulkservicetype::BULKTHRIFT,
  iEbulkservicetype::BULKSTRING,
  iEbulkservicetype::SINGLETHRIFT,
  iEbulkservicetype::PING
};
const char* _kiEbulkservicetypeNames[] = {
  "BULKTHRIFT",
  "BULKSTRING",
  "SINGLETHRIFT",
  "PING"
};
const std::map<int, const char*> _iEbulkservicetype_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kiEbulkservicetypeValues, _kiEbulkservicetypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ThrfLmtb::~ThrfLmtb() throw() {
}


void ThrfLmtb::__set_sVnamespace(const std::string& val) {
  this->sVnamespace = val;
}

void ThrfLmtb::__set_sVtable(const std::string& val) {
  this->sVtable = val;
}

const char* ThrfLmtb::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t ThrfLmtb::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t ThrfLmtb::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVnamespace = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnamespace);
          isset_sVnamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVtable);
          this->__isset.sVtable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVnamespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfLmtb::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfLmtb");

  xfer += oprot->writeFieldBegin("sVnamespace", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVnamespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVtable", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVtable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfLmtb &a, ThrfLmtb &b) {
  using ::std::swap;
  swap(a.sVnamespace, b.sVnamespace);
  swap(a.sVtable, b.sVtable);
  swap(a.__isset, b.__isset);
}

ThrfLmtb::ThrfLmtb(const ThrfLmtb& other0) {
  sVnamespace = other0.sVnamespace;
  sVtable = other0.sVtable;
  __isset = other0.__isset;
}
ThrfLmtb& ThrfLmtb::operator=(const ThrfLmtb& other1) {
  sVnamespace = other1.sVnamespace;
  sVtable = other1.sVtable;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfLmtb& obj) {
  using apache::thrift::to_string;
  out << "ThrfLmtb(";
  out << "sVnamespace=" << to_string(obj.sVnamespace);
  out << ", " << "sVtable=" << to_string(obj.sVtable);
  out << ")";
  return out;
}


ThrfLkey::~ThrfLkey() throw() {
}


void ThrfLkey::__set_sVmain(const std::string& val) {
  this->sVmain = val;
}

void ThrfLkey::__set_sVaccessgroup(const std::string& val) {
  this->sVaccessgroup = val;
}

void ThrfLkey::__set_sVqualifier(const std::string& val) {
  this->sVqualifier = val;
}

void ThrfLkey::__set_iVstate(const iEstatetype::type val) {
  this->iVstate = val;
}

void ThrfLkey::__set_iVtimestamp(const int64_t val) {
  this->iVtimestamp = val;
}

const char* ThrfLkey::ascii_fingerprint = "222AFB4990285E29234328916DC6F924";
const uint8_t ThrfLkey::binary_fingerprint[16] = {0x22,0x2A,0xFB,0x49,0x90,0x28,0x5E,0x29,0x23,0x43,0x28,0x91,0x6D,0xC6,0xF9,0x24};

uint32_t ThrfLkey::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVmain = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVmain);
          isset_sVmain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVaccessgroup);
          this->__isset.sVaccessgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVqualifier);
          this->__isset.sVqualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->iVstate = (iEstatetype::type)ecast2;
          this->__isset.iVstate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVtimestamp);
          this->__isset.iVtimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVmain)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfLkey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfLkey");

  xfer += oprot->writeFieldBegin("sVmain", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVmain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVaccessgroup", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVaccessgroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVqualifier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sVqualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVstate", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->iVstate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVtimestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->iVtimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfLkey &a, ThrfLkey &b) {
  using ::std::swap;
  swap(a.sVmain, b.sVmain);
  swap(a.sVaccessgroup, b.sVaccessgroup);
  swap(a.sVqualifier, b.sVqualifier);
  swap(a.iVstate, b.iVstate);
  swap(a.iVtimestamp, b.iVtimestamp);
  swap(a.__isset, b.__isset);
}

ThrfLkey::ThrfLkey(const ThrfLkey& other3) {
  sVmain = other3.sVmain;
  sVaccessgroup = other3.sVaccessgroup;
  sVqualifier = other3.sVqualifier;
  iVstate = other3.iVstate;
  iVtimestamp = other3.iVtimestamp;
  __isset = other3.__isset;
}
ThrfLkey& ThrfLkey::operator=(const ThrfLkey& other4) {
  sVmain = other4.sVmain;
  sVaccessgroup = other4.sVaccessgroup;
  sVqualifier = other4.sVqualifier;
  iVstate = other4.iVstate;
  iVtimestamp = other4.iVtimestamp;
  __isset = other4.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfLkey& obj) {
  using apache::thrift::to_string;
  out << "ThrfLkey(";
  out << "sVmain=" << to_string(obj.sVmain);
  out << ", " << "sVaccessgroup=" << to_string(obj.sVaccessgroup);
  out << ", " << "sVqualifier=" << to_string(obj.sVqualifier);
  out << ", " << "iVstate=" << to_string(obj.iVstate);
  out << ", " << "iVtimestamp=" << to_string(obj.iVtimestamp);
  out << ")";
  return out;
}


ThrfL2cv::~ThrfL2cv() throw() {
}


void ThrfL2cv::__set_iVtype(const iEcolumntype::type val) {
  this->iVtype = val;
}

void ThrfL2cv::__set_sVvalue(const std::string& val) {
  this->sVvalue = val;
}

void ThrfL2cv::__set_sVlistvalue(const std::vector<std::string> & val) {
  this->sVlistvalue = val;
}

void ThrfL2cv::__set_iVvalue(const int32_t val) {
  this->iVvalue = val;
}

void ThrfL2cv::__set_iVlistvalue(const std::vector<int32_t> & val) {
  this->iVlistvalue = val;
}

void ThrfL2cv::__set_dVvalue(const double val) {
  this->dVvalue = val;
}

void ThrfL2cv::__set_dVlistvalue(const std::vector<double> & val) {
  this->dVlistvalue = val;
}

void ThrfL2cv::__set_bVvalue(const bool val) {
  this->bVvalue = val;
}

const char* ThrfL2cv::ascii_fingerprint = "EF17F9DF99D07B94B21A8D4343E55659";
const uint8_t ThrfL2cv::binary_fingerprint[16] = {0xEF,0x17,0xF9,0xDF,0x99,0xD0,0x7B,0x94,0xB2,0x1A,0x8D,0x43,0x43,0xE5,0x56,0x59};

uint32_t ThrfL2cv::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVtype = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->iVtype = (iEcolumntype::type)ecast5;
          isset_iVtype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVvalue);
          this->__isset.sVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sVlistvalue.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->sVlistvalue.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->sVlistvalue[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sVlistvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVvalue);
          this->__isset.iVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iVlistvalue.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->iVlistvalue.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readI32(this->iVlistvalue[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.iVlistvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dVvalue);
          this->__isset.dVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dVlistvalue.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->dVlistvalue.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readDouble(this->dVlistvalue[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dVlistvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVvalue);
          this->__isset.bVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVtype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2cv::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2cv");

  xfer += oprot->writeFieldBegin("iVtype", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iVtype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVvalue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVvalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVlistvalue", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sVlistvalue.size()));
    std::vector<std::string> ::const_iterator _iter21;
    for (_iter21 = this->sVlistvalue.begin(); _iter21 != this->sVlistvalue.end(); ++_iter21)
    {
      xfer += oprot->writeString((*_iter21));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVvalue", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iVvalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVlistvalue", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->iVlistvalue.size()));
    std::vector<int32_t> ::const_iterator _iter22;
    for (_iter22 = this->iVlistvalue.begin(); _iter22 != this->iVlistvalue.end(); ++_iter22)
    {
      xfer += oprot->writeI32((*_iter22));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dVvalue", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->dVvalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dVlistvalue", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->dVlistvalue.size()));
    std::vector<double> ::const_iterator _iter23;
    for (_iter23 = this->dVlistvalue.begin(); _iter23 != this->dVlistvalue.end(); ++_iter23)
    {
      xfer += oprot->writeDouble((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVvalue", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bVvalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2cv &a, ThrfL2cv &b) {
  using ::std::swap;
  swap(a.iVtype, b.iVtype);
  swap(a.sVvalue, b.sVvalue);
  swap(a.sVlistvalue, b.sVlistvalue);
  swap(a.iVvalue, b.iVvalue);
  swap(a.iVlistvalue, b.iVlistvalue);
  swap(a.dVvalue, b.dVvalue);
  swap(a.dVlistvalue, b.dVlistvalue);
  swap(a.bVvalue, b.bVvalue);
  swap(a.__isset, b.__isset);
}

ThrfL2cv::ThrfL2cv(const ThrfL2cv& other24) {
  iVtype = other24.iVtype;
  sVvalue = other24.sVvalue;
  sVlistvalue = other24.sVlistvalue;
  iVvalue = other24.iVvalue;
  iVlistvalue = other24.iVlistvalue;
  dVvalue = other24.dVvalue;
  dVlistvalue = other24.dVlistvalue;
  bVvalue = other24.bVvalue;
  __isset = other24.__isset;
}
ThrfL2cv& ThrfL2cv::operator=(const ThrfL2cv& other25) {
  iVtype = other25.iVtype;
  sVvalue = other25.sVvalue;
  sVlistvalue = other25.sVlistvalue;
  iVvalue = other25.iVvalue;
  iVlistvalue = other25.iVlistvalue;
  dVvalue = other25.dVvalue;
  dVlistvalue = other25.dVlistvalue;
  bVvalue = other25.bVvalue;
  __isset = other25.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2cv& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2cv(";
  out << "iVtype=" << to_string(obj.iVtype);
  out << ", " << "sVvalue=" << to_string(obj.sVvalue);
  out << ", " << "sVlistvalue=" << to_string(obj.sVlistvalue);
  out << ", " << "iVvalue=" << to_string(obj.iVvalue);
  out << ", " << "iVlistvalue=" << to_string(obj.iVlistvalue);
  out << ", " << "dVvalue=" << to_string(obj.dVvalue);
  out << ", " << "dVlistvalue=" << to_string(obj.dVlistvalue);
  out << ", " << "bVvalue=" << to_string(obj.bVvalue);
  out << ")";
  return out;
}


ThrfL2cl::~ThrfL2cl() throw() {
}


void ThrfL2cl::__set_sVcolumn(const std::string& val) {
  this->sVcolumn = val;
}

void ThrfL2cl::__set_iVtype(const iEcolumntype::type val) {
  this->iVtype = val;
}

void ThrfL2cl::__set_cVvalue(const ThrfL2cv& val) {
  this->cVvalue = val;
}

void ThrfL2cl::__set_iVconditiontype(const iEconditiontype::type val) {
  this->iVconditiontype = val;
}

const char* ThrfL2cl::ascii_fingerprint = "5425A5B0A496E00FFDB490AC0B56ACC2";
const uint8_t ThrfL2cl::binary_fingerprint[16] = {0x54,0x25,0xA5,0xB0,0xA4,0x96,0xE0,0x0F,0xFD,0xB4,0x90,0xAC,0x0B,0x56,0xAC,0xC2};

uint32_t ThrfL2cl::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVcolumn = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVcolumn);
          isset_sVcolumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast26;
          xfer += iprot->readI32(ecast26);
          this->iVtype = (iEcolumntype::type)ecast26;
          this->__isset.iVtype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVvalue.read(iprot);
          this->__isset.cVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast27;
          xfer += iprot->readI32(ecast27);
          this->iVconditiontype = (iEconditiontype::type)ecast27;
          this->__isset.iVconditiontype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVcolumn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2cl::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2cl");

  xfer += oprot->writeFieldBegin("sVcolumn", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVcolumn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVtype", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->iVtype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVvalue", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVvalue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVconditiontype", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->iVconditiontype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2cl &a, ThrfL2cl &b) {
  using ::std::swap;
  swap(a.sVcolumn, b.sVcolumn);
  swap(a.iVtype, b.iVtype);
  swap(a.cVvalue, b.cVvalue);
  swap(a.iVconditiontype, b.iVconditiontype);
  swap(a.__isset, b.__isset);
}

ThrfL2cl::ThrfL2cl(const ThrfL2cl& other28) {
  sVcolumn = other28.sVcolumn;
  iVtype = other28.iVtype;
  cVvalue = other28.cVvalue;
  iVconditiontype = other28.iVconditiontype;
  __isset = other28.__isset;
}
ThrfL2cl& ThrfL2cl::operator=(const ThrfL2cl& other29) {
  sVcolumn = other29.sVcolumn;
  iVtype = other29.iVtype;
  cVvalue = other29.cVvalue;
  iVconditiontype = other29.iVconditiontype;
  __isset = other29.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2cl& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2cl(";
  out << "sVcolumn=" << to_string(obj.sVcolumn);
  out << ", " << "iVtype=" << to_string(obj.iVtype);
  out << ", " << "cVvalue=" << to_string(obj.cVvalue);
  out << ", " << "iVconditiontype=" << to_string(obj.iVconditiontype);
  out << ")";
  return out;
}


ThrfLval::~ThrfLval() throw() {
}


void ThrfLval::__set_sVopaquevalue(const std::string& val) {
  this->sVopaquevalue = val;
}

void ThrfLval::__set_iVtimestamp(const int64_t val) {
  this->iVtimestamp = val;
}

const char* ThrfLval::ascii_fingerprint = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
const uint8_t ThrfLval::binary_fingerprint[16] = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

uint32_t ThrfLval::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVopaquevalue = false;
  bool isset_iVtimestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVopaquevalue);
          isset_sVopaquevalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVtimestamp);
          isset_iVtimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVopaquevalue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVtimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfLval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfLval");

  xfer += oprot->writeFieldBegin("sVopaquevalue", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVopaquevalue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVtimestamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->iVtimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfLval &a, ThrfLval &b) {
  using ::std::swap;
  swap(a.sVopaquevalue, b.sVopaquevalue);
  swap(a.iVtimestamp, b.iVtimestamp);
}

ThrfLval::ThrfLval(const ThrfLval& other30) {
  sVopaquevalue = other30.sVopaquevalue;
  iVtimestamp = other30.iVtimestamp;
}
ThrfLval& ThrfLval::operator=(const ThrfLval& other31) {
  sVopaquevalue = other31.sVopaquevalue;
  iVtimestamp = other31.iVtimestamp;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfLval& obj) {
  using apache::thrift::to_string;
  out << "ThrfLval(";
  out << "sVopaquevalue=" << to_string(obj.sVopaquevalue);
  out << ", " << "iVtimestamp=" << to_string(obj.iVtimestamp);
  out << ")";
  return out;
}


ThrfL1ks::~ThrfL1ks() throw() {
}


void ThrfL1ks::__set_cVkey(const ThrfLkey& val) {
  this->cVkey = val;
}

void ThrfL1ks::__set_bVresult(const bool val) {
  this->bVresult = val;
}

void ThrfL1ks::__set_cVvalue(const ThrfLval& val) {
  this->cVvalue = val;
}

const char* ThrfL1ks::ascii_fingerprint = "CC4FFBE08543BFB22DD6DEF04A7E402F";
const uint8_t ThrfL1ks::binary_fingerprint[16] = {0xCC,0x4F,0xFB,0xE0,0x85,0x43,0xBF,0xB2,0x2D,0xD6,0xDE,0xF0,0x4A,0x7E,0x40,0x2F};

uint32_t ThrfL1ks::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cVkey = false;
  bool isset_bVresult = false;
  bool isset_cVvalue = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey.read(iprot);
          isset_cVkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVresult);
          isset_bVresult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVvalue.read(iprot);
          isset_cVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cVkey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVresult)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cVvalue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL1ks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL1ks");

  xfer += oprot->writeFieldBegin("cVkey", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cVkey.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVresult", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bVresult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVvalue", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVvalue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL1ks &a, ThrfL1ks &b) {
  using ::std::swap;
  swap(a.cVkey, b.cVkey);
  swap(a.bVresult, b.bVresult);
  swap(a.cVvalue, b.cVvalue);
}

ThrfL1ks::ThrfL1ks(const ThrfL1ks& other32) {
  cVkey = other32.cVkey;
  bVresult = other32.bVresult;
  cVvalue = other32.cVvalue;
}
ThrfL1ks& ThrfL1ks::operator=(const ThrfL1ks& other33) {
  cVkey = other33.cVkey;
  bVresult = other33.bVresult;
  cVvalue = other33.cVvalue;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL1ks& obj) {
  using apache::thrift::to_string;
  out << "ThrfL1ks(";
  out << "cVkey=" << to_string(obj.cVkey);
  out << ", " << "bVresult=" << to_string(obj.bVresult);
  out << ", " << "cVvalue=" << to_string(obj.cVvalue);
  out << ")";
  return out;
}


ThrfLstm::~ThrfLstm() throw() {
}


void ThrfLstm::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfLstm::__set_cVkey(const ThrfLkey& val) {
  this->cVkey = val;
}

void ThrfLstm::__set_cVvalue(const ThrfLval& val) {
  this->cVvalue = val;
}

void ThrfLstm::__set_iVopcode(const iEopcodetype::type val) {
  this->iVopcode = val;
}

void ThrfLstm::__set_sVcallback(const std::string& val) {
  this->sVcallback = val;
}

const char* ThrfLstm::ascii_fingerprint = "82696706F701A26A513FB455CAC6DDAA";
const uint8_t ThrfLstm::binary_fingerprint[16] = {0x82,0x69,0x67,0x06,0xF7,0x01,0xA2,0x6A,0x51,0x3F,0xB4,0x55,0xCA,0xC6,0xDD,0xAA};

uint32_t ThrfLstm::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cVmutable = false;
  bool isset_cVkey = false;
  bool isset_cVvalue = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          isset_cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey.read(iprot);
          isset_cVkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVvalue.read(iprot);
          isset_cVvalue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->iVopcode = (iEopcodetype::type)ecast34;
          this->__isset.iVopcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVcallback);
          this->__isset.sVcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cVmutable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cVkey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cVvalue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfLstm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfLstm");

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVkey", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cVkey.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVvalue", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVvalue.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVopcode", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->iVopcode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVcallback", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sVcallback);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfLstm &a, ThrfLstm &b) {
  using ::std::swap;
  swap(a.cVmutable, b.cVmutable);
  swap(a.cVkey, b.cVkey);
  swap(a.cVvalue, b.cVvalue);
  swap(a.iVopcode, b.iVopcode);
  swap(a.sVcallback, b.sVcallback);
  swap(a.__isset, b.__isset);
}

ThrfLstm::ThrfLstm(const ThrfLstm& other35) {
  cVmutable = other35.cVmutable;
  cVkey = other35.cVkey;
  cVvalue = other35.cVvalue;
  iVopcode = other35.iVopcode;
  sVcallback = other35.sVcallback;
  __isset = other35.__isset;
}
ThrfLstm& ThrfLstm::operator=(const ThrfLstm& other36) {
  cVmutable = other36.cVmutable;
  cVkey = other36.cVkey;
  cVvalue = other36.cVvalue;
  iVopcode = other36.iVopcode;
  sVcallback = other36.sVcallback;
  __isset = other36.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfLstm& obj) {
  using apache::thrift::to_string;
  out << "ThrfLstm(";
  out << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "cVkey=" << to_string(obj.cVkey);
  out << ", " << "cVvalue=" << to_string(obj.cVvalue);
  out << ", " << "iVopcode=" << to_string(obj.iVopcode);
  out << ", " << "sVcallback=" << to_string(obj.sVcallback);
  out << ")";
  return out;
}


ThrfL2st::~ThrfL2st() throw() {
}


void ThrfL2st::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfL2st::__set_cVkey(const ThrfLkey& val) {
  this->cVkey = val;
}

void ThrfL2st::__set_cVcolumns(const std::vector<ThrfL2cl> & val) {
  this->cVcolumns = val;
}

void ThrfL2st::__set_iVopcode(const iEopcodetype::type val) {
  this->iVopcode = val;
}

const char* ThrfL2st::ascii_fingerprint = "4798E44E2BCE0A6FF6287FCA51B26071";
const uint8_t ThrfL2st::binary_fingerprint[16] = {0x47,0x98,0xE4,0x4E,0x2B,0xCE,0x0A,0x6F,0xF6,0x28,0x7F,0xCA,0x51,0xB2,0x60,0x71};

uint32_t ThrfL2st::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cVmutable = false;
  bool isset_cVkey = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          isset_cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey.read(iprot);
          isset_cVkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVcolumns.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->cVcolumns.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->cVcolumns[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVcolumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->iVopcode = (iEopcodetype::type)ecast42;
          this->__isset.iVopcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cVmutable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cVkey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2st::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2st");

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVkey", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cVkey.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVcolumns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVcolumns.size()));
    std::vector<ThrfL2cl> ::const_iterator _iter43;
    for (_iter43 = this->cVcolumns.begin(); _iter43 != this->cVcolumns.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVopcode", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->iVopcode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2st &a, ThrfL2st &b) {
  using ::std::swap;
  swap(a.cVmutable, b.cVmutable);
  swap(a.cVkey, b.cVkey);
  swap(a.cVcolumns, b.cVcolumns);
  swap(a.iVopcode, b.iVopcode);
  swap(a.__isset, b.__isset);
}

ThrfL2st::ThrfL2st(const ThrfL2st& other44) {
  cVmutable = other44.cVmutable;
  cVkey = other44.cVkey;
  cVcolumns = other44.cVcolumns;
  iVopcode = other44.iVopcode;
  __isset = other44.__isset;
}
ThrfL2st& ThrfL2st::operator=(const ThrfL2st& other45) {
  cVmutable = other45.cVmutable;
  cVkey = other45.cVkey;
  cVcolumns = other45.cVcolumns;
  iVopcode = other45.iVopcode;
  __isset = other45.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2st& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2st(";
  out << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "cVkey=" << to_string(obj.cVkey);
  out << ", " << "cVcolumns=" << to_string(obj.cVcolumns);
  out << ", " << "iVopcode=" << to_string(obj.iVopcode);
  out << ")";
  return out;
}


ThrfL2ag::~ThrfL2ag() throw() {
}


void ThrfL2ag::__set_sVname(const std::string& val) {
  this->sVname = val;
}

void ThrfL2ag::__set_sVcolumns(const std::vector<std::string> & val) {
  this->sVcolumns = val;
}

const char* ThrfL2ag::ascii_fingerprint = "25702B8D5E28AA39160F267DABBC8446";
const uint8_t ThrfL2ag::binary_fingerprint[16] = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

uint32_t ThrfL2ag::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVname = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVname);
          isset_sVname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sVcolumns.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->sVcolumns.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += iprot->readString(this->sVcolumns[_i50]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sVcolumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2ag::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2ag");

  xfer += oprot->writeFieldBegin("sVname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVcolumns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sVcolumns.size()));
    std::vector<std::string> ::const_iterator _iter51;
    for (_iter51 = this->sVcolumns.begin(); _iter51 != this->sVcolumns.end(); ++_iter51)
    {
      xfer += oprot->writeString((*_iter51));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2ag &a, ThrfL2ag &b) {
  using ::std::swap;
  swap(a.sVname, b.sVname);
  swap(a.sVcolumns, b.sVcolumns);
  swap(a.__isset, b.__isset);
}

ThrfL2ag::ThrfL2ag(const ThrfL2ag& other52) {
  sVname = other52.sVname;
  sVcolumns = other52.sVcolumns;
  __isset = other52.__isset;
}
ThrfL2ag& ThrfL2ag::operator=(const ThrfL2ag& other53) {
  sVname = other53.sVname;
  sVcolumns = other53.sVcolumns;
  __isset = other53.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2ag& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2ag(";
  out << "sVname=" << to_string(obj.sVname);
  out << ", " << "sVcolumns=" << to_string(obj.sVcolumns);
  out << ")";
  return out;
}


ThrfL2ct::~ThrfL2ct() throw() {
}


void ThrfL2ct::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfL2ct::__set_cVcolumns(const std::vector<ThrfL2cl> & val) {
  this->cVcolumns = val;
}

void ThrfL2ct::__set_cVaccessgroups(const std::vector<ThrfL2ag> & val) {
  this->cVaccessgroups = val;
}

const char* ThrfL2ct::ascii_fingerprint = "283393C1EF3BAF2E520343AFF1DFA513";
const uint8_t ThrfL2ct::binary_fingerprint[16] = {0x28,0x33,0x93,0xC1,0xEF,0x3B,0xAF,0x2E,0x52,0x03,0x43,0xAF,0xF1,0xDF,0xA5,0x13};

uint32_t ThrfL2ct::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cVmutable = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          isset_cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVcolumns.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->cVcolumns.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->cVcolumns[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVcolumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVaccessgroups.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->cVaccessgroups.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->cVaccessgroups[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVaccessgroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cVmutable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2ct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2ct");

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVcolumns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVcolumns.size()));
    std::vector<ThrfL2cl> ::const_iterator _iter64;
    for (_iter64 = this->cVcolumns.begin(); _iter64 != this->cVcolumns.end(); ++_iter64)
    {
      xfer += (*_iter64).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVaccessgroups", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVaccessgroups.size()));
    std::vector<ThrfL2ag> ::const_iterator _iter65;
    for (_iter65 = this->cVaccessgroups.begin(); _iter65 != this->cVaccessgroups.end(); ++_iter65)
    {
      xfer += (*_iter65).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2ct &a, ThrfL2ct &b) {
  using ::std::swap;
  swap(a.cVmutable, b.cVmutable);
  swap(a.cVcolumns, b.cVcolumns);
  swap(a.cVaccessgroups, b.cVaccessgroups);
  swap(a.__isset, b.__isset);
}

ThrfL2ct::ThrfL2ct(const ThrfL2ct& other66) {
  cVmutable = other66.cVmutable;
  cVcolumns = other66.cVcolumns;
  cVaccessgroups = other66.cVaccessgroups;
  __isset = other66.__isset;
}
ThrfL2ct& ThrfL2ct::operator=(const ThrfL2ct& other67) {
  cVmutable = other67.cVmutable;
  cVcolumns = other67.cVcolumns;
  cVaccessgroups = other67.cVaccessgroups;
  __isset = other67.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2ct& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2ct(";
  out << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "cVcolumns=" << to_string(obj.cVcolumns);
  out << ", " << "cVaccessgroups=" << to_string(obj.cVaccessgroups);
  out << ")";
  return out;
}


ThrfL2ks::~ThrfL2ks() throw() {
}


void ThrfL2ks::__set_cVkey(const ThrfLkey& val) {
  this->cVkey = val;
}

void ThrfL2ks::__set_cVcolumns(const std::vector<ThrfL2cl> & val) {
  this->cVcolumns = val;
}

const char* ThrfL2ks::ascii_fingerprint = "E7E176AF8D5B43BBB1C59E3A993EF742";
const uint8_t ThrfL2ks::binary_fingerprint[16] = {0xE7,0xE1,0x76,0xAF,0x8D,0x5B,0x43,0xBB,0xB1,0xC5,0x9E,0x3A,0x99,0x3E,0xF7,0x42};

uint32_t ThrfL2ks::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cVkey = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey.read(iprot);
          isset_cVkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVcolumns.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->cVcolumns.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += this->cVcolumns[_i72].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVcolumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cVkey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2ks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2ks");

  xfer += oprot->writeFieldBegin("cVkey", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cVkey.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVcolumns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVcolumns.size()));
    std::vector<ThrfL2cl> ::const_iterator _iter73;
    for (_iter73 = this->cVcolumns.begin(); _iter73 != this->cVcolumns.end(); ++_iter73)
    {
      xfer += (*_iter73).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2ks &a, ThrfL2ks &b) {
  using ::std::swap;
  swap(a.cVkey, b.cVkey);
  swap(a.cVcolumns, b.cVcolumns);
  swap(a.__isset, b.__isset);
}

ThrfL2ks::ThrfL2ks(const ThrfL2ks& other74) {
  cVkey = other74.cVkey;
  cVcolumns = other74.cVcolumns;
  __isset = other74.__isset;
}
ThrfL2ks& ThrfL2ks::operator=(const ThrfL2ks& other75) {
  cVkey = other75.cVkey;
  cVcolumns = other75.cVcolumns;
  __isset = other75.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2ks& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2ks(";
  out << "cVkey=" << to_string(obj.cVkey);
  out << ", " << "cVcolumns=" << to_string(obj.cVcolumns);
  out << ")";
  return out;
}


ThrfL2or::~ThrfL2or() throw() {
}


void ThrfL2or::__set_sVcolumn(const std::string& val) {
  this->sVcolumn = val;
}

void ThrfL2or::__set_iVordertype(const iEordertype::type val) {
  this->iVordertype = val;
}

const char* ThrfL2or::ascii_fingerprint = "D6FD826D949221396F4FFC3ECCD3D192";
const uint8_t ThrfL2or::binary_fingerprint[16] = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

uint32_t ThrfL2or::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVcolumn = false;
  bool isset_iVordertype = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVcolumn);
          isset_sVcolumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->iVordertype = (iEordertype::type)ecast76;
          isset_iVordertype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVcolumn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVordertype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2or::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2or");

  xfer += oprot->writeFieldBegin("sVcolumn", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVcolumn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVordertype", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->iVordertype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2or &a, ThrfL2or &b) {
  using ::std::swap;
  swap(a.sVcolumn, b.sVcolumn);
  swap(a.iVordertype, b.iVordertype);
}

ThrfL2or::ThrfL2or(const ThrfL2or& other77) {
  sVcolumn = other77.sVcolumn;
  iVordertype = other77.iVordertype;
}
ThrfL2or& ThrfL2or::operator=(const ThrfL2or& other78) {
  sVcolumn = other78.sVcolumn;
  iVordertype = other78.iVordertype;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2or& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2or(";
  out << "sVcolumn=" << to_string(obj.sVcolumn);
  out << ", " << "iVordertype=" << to_string(obj.iVordertype);
  out << ")";
  return out;
}


ThrfL2wh::~ThrfL2wh() throw() {
}


void ThrfL2wh::__set_cVcondition(const std::vector<ThrfL2cl> & val) {
  this->cVcondition = val;
}

void ThrfL2wh::__set_cVorderby(const std::vector<ThrfL2or> & val) {
  this->cVorderby = val;
}

const char* ThrfL2wh::ascii_fingerprint = "B406C81429592FB475424F013CCD6826";
const uint8_t ThrfL2wh::binary_fingerprint[16] = {0xB4,0x06,0xC8,0x14,0x29,0x59,0x2F,0xB4,0x75,0x42,0x4F,0x01,0x3C,0xCD,0x68,0x26};

uint32_t ThrfL2wh::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVcondition.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->cVcondition.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += this->cVcondition[_i83].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVcondition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVorderby.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->cVorderby.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->cVorderby[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVorderby = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfL2wh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2wh");

  xfer += oprot->writeFieldBegin("cVcondition", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVcondition.size()));
    std::vector<ThrfL2cl> ::const_iterator _iter89;
    for (_iter89 = this->cVcondition.begin(); _iter89 != this->cVcondition.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVorderby", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVorderby.size()));
    std::vector<ThrfL2or> ::const_iterator _iter90;
    for (_iter90 = this->cVorderby.begin(); _iter90 != this->cVorderby.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2wh &a, ThrfL2wh &b) {
  using ::std::swap;
  swap(a.cVcondition, b.cVcondition);
  swap(a.cVorderby, b.cVorderby);
  swap(a.__isset, b.__isset);
}

ThrfL2wh::ThrfL2wh(const ThrfL2wh& other91) {
  cVcondition = other91.cVcondition;
  cVorderby = other91.cVorderby;
  __isset = other91.__isset;
}
ThrfL2wh& ThrfL2wh::operator=(const ThrfL2wh& other92) {
  cVcondition = other92.cVcondition;
  cVorderby = other92.cVorderby;
  __isset = other92.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2wh& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2wh(";
  out << "cVcondition=" << to_string(obj.cVcondition);
  out << ", " << "cVorderby=" << to_string(obj.cVorderby);
  out << ")";
  return out;
}


ThrfL2qr::~ThrfL2qr() throw() {
}


void ThrfL2qr::__set_cVselect(const std::vector<ThrfL2cl> & val) {
  this->cVselect = val;
}

void ThrfL2qr::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfL2qr::__set_iVquery(const iEquerytype::type val) {
  this->iVquery = val;
}

void ThrfL2qr::__set_cVkey_start(const ThrfLkey& val) {
  this->cVkey_start = val;
}

void ThrfL2qr::__set_cVkey_end(const ThrfLkey& val) {
  this->cVkey_end = val;
}

void ThrfL2qr::__set_cVwhere(const ThrfL2wh& val) {
  this->cVwhere = val;
}

void ThrfL2qr::__set_iVcount(const int32_t val) {
  this->iVcount = val;
}

void ThrfL2qr::__set_bVonlysecondary(const bool val) {
  this->bVonlysecondary = val;
}

void ThrfL2qr::__set_bVdisableteleport(const bool val) {
  this->bVdisableteleport = val;
}

const char* ThrfL2qr::ascii_fingerprint = "A702846D85FB1FED210EBF9443B5BA24";
const uint8_t ThrfL2qr::binary_fingerprint[16] = {0xA7,0x02,0x84,0x6D,0x85,0xFB,0x1F,0xED,0x21,0x0E,0xBF,0x94,0x43,0xB5,0xBA,0x24};

uint32_t ThrfL2qr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cVmutable = false;
  bool isset_bVonlysecondary = false;
  bool isset_bVdisableteleport = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVselect.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->cVselect.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->cVselect[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVselect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          isset_cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast98;
          xfer += iprot->readI32(ecast98);
          this->iVquery = (iEquerytype::type)ecast98;
          this->__isset.iVquery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey_start.read(iprot);
          this->__isset.cVkey_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey_end.read(iprot);
          this->__isset.cVkey_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVwhere.read(iprot);
          this->__isset.cVwhere = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVcount);
          this->__isset.iVcount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVonlysecondary);
          isset_bVonlysecondary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVdisableteleport);
          isset_bVdisableteleport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cVmutable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVonlysecondary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVdisableteleport)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2qr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2qr");

  xfer += oprot->writeFieldBegin("cVselect", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVselect.size()));
    std::vector<ThrfL2cl> ::const_iterator _iter99;
    for (_iter99 = this->cVselect.begin(); _iter99 != this->cVselect.end(); ++_iter99)
    {
      xfer += (*_iter99).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVquery", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->iVquery);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVkey_start", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->cVkey_start.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVkey_end", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->cVkey_end.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVwhere", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->cVwhere.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVcount", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iVcount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVonlysecondary", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bVonlysecondary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVdisableteleport", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->bVdisableteleport);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2qr &a, ThrfL2qr &b) {
  using ::std::swap;
  swap(a.cVselect, b.cVselect);
  swap(a.cVmutable, b.cVmutable);
  swap(a.iVquery, b.iVquery);
  swap(a.cVkey_start, b.cVkey_start);
  swap(a.cVkey_end, b.cVkey_end);
  swap(a.cVwhere, b.cVwhere);
  swap(a.iVcount, b.iVcount);
  swap(a.bVonlysecondary, b.bVonlysecondary);
  swap(a.bVdisableteleport, b.bVdisableteleport);
  swap(a.__isset, b.__isset);
}

ThrfL2qr::ThrfL2qr(const ThrfL2qr& other100) {
  cVselect = other100.cVselect;
  cVmutable = other100.cVmutable;
  iVquery = other100.iVquery;
  cVkey_start = other100.cVkey_start;
  cVkey_end = other100.cVkey_end;
  cVwhere = other100.cVwhere;
  iVcount = other100.iVcount;
  bVonlysecondary = other100.bVonlysecondary;
  bVdisableteleport = other100.bVdisableteleport;
  __isset = other100.__isset;
}
ThrfL2qr& ThrfL2qr::operator=(const ThrfL2qr& other101) {
  cVselect = other101.cVselect;
  cVmutable = other101.cVmutable;
  iVquery = other101.iVquery;
  cVkey_start = other101.cVkey_start;
  cVkey_end = other101.cVkey_end;
  cVwhere = other101.cVwhere;
  iVcount = other101.iVcount;
  bVonlysecondary = other101.bVonlysecondary;
  bVdisableteleport = other101.bVdisableteleport;
  __isset = other101.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2qr& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2qr(";
  out << "cVselect=" << to_string(obj.cVselect);
  out << ", " << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "iVquery=" << to_string(obj.iVquery);
  out << ", " << "cVkey_start=" << to_string(obj.cVkey_start);
  out << ", " << "cVkey_end=" << to_string(obj.cVkey_end);
  out << ", " << "cVwhere=" << to_string(obj.cVwhere);
  out << ", " << "iVcount=" << to_string(obj.iVcount);
  out << ", " << "bVonlysecondary=" << to_string(obj.bVonlysecondary);
  out << ", " << "bVdisableteleport=" << to_string(obj.bVdisableteleport);
  out << ")";
  return out;
}


ThrfL2os::~ThrfL2os() throw() {
}


void ThrfL2os::__set_sVnamespace(const std::string& val) {
  this->sVnamespace = val;
}

void ThrfL2os::__set_sVosqlstring(const std::string& val) {
  this->sVosqlstring = val;
}

void ThrfL2os::__set_cVinputbindings(const std::vector<ThrfL2cv> & val) {
  this->cVinputbindings = val;
}

void ThrfL2os::__set_bVonlysecondary(const bool val) {
  this->bVonlysecondary = val;
}

void ThrfL2os::__set_bVdisableteleport(const bool val) {
  this->bVdisableteleport = val;
}

void ThrfL2os::__set_iVtimestamp(const int64_t val) {
  this->iVtimestamp = val;
}

void ThrfL2os::__set_bVfulltablescan(const bool val) {
  this->bVfulltablescan = val;
}

const char* ThrfL2os::ascii_fingerprint = "8D1CEF95AAC64B94AE3750CCF0573671";
const uint8_t ThrfL2os::binary_fingerprint[16] = {0x8D,0x1C,0xEF,0x95,0xAA,0xC6,0x4B,0x94,0xAE,0x37,0x50,0xCC,0xF0,0x57,0x36,0x71};

uint32_t ThrfL2os::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVnamespace = false;
  bool isset_sVosqlstring = false;
  bool isset_bVonlysecondary = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnamespace);
          isset_sVnamespace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVosqlstring);
          isset_sVosqlstring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVinputbindings.clear();
            uint32_t _size102;
            ::apache::thrift::protocol::TType _etype105;
            xfer += iprot->readListBegin(_etype105, _size102);
            this->cVinputbindings.resize(_size102);
            uint32_t _i106;
            for (_i106 = 0; _i106 < _size102; ++_i106)
            {
              xfer += this->cVinputbindings[_i106].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVinputbindings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVonlysecondary);
          isset_bVonlysecondary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVdisableteleport);
          this->__isset.bVdisableteleport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVtimestamp);
          this->__isset.iVtimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVfulltablescan);
          this->__isset.bVfulltablescan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVnamespace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVosqlstring)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVonlysecondary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfL2os::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2os");

  xfer += oprot->writeFieldBegin("sVnamespace", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVnamespace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVosqlstring", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVosqlstring);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVinputbindings", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVinputbindings.size()));
    std::vector<ThrfL2cv> ::const_iterator _iter107;
    for (_iter107 = this->cVinputbindings.begin(); _iter107 != this->cVinputbindings.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVonlysecondary", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bVonlysecondary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVdisableteleport", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->bVdisableteleport);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVtimestamp", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->iVtimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVfulltablescan", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bVfulltablescan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2os &a, ThrfL2os &b) {
  using ::std::swap;
  swap(a.sVnamespace, b.sVnamespace);
  swap(a.sVosqlstring, b.sVosqlstring);
  swap(a.cVinputbindings, b.cVinputbindings);
  swap(a.bVonlysecondary, b.bVonlysecondary);
  swap(a.bVdisableteleport, b.bVdisableteleport);
  swap(a.iVtimestamp, b.iVtimestamp);
  swap(a.bVfulltablescan, b.bVfulltablescan);
  swap(a.__isset, b.__isset);
}

ThrfL2os::ThrfL2os(const ThrfL2os& other108) {
  sVnamespace = other108.sVnamespace;
  sVosqlstring = other108.sVosqlstring;
  cVinputbindings = other108.cVinputbindings;
  bVonlysecondary = other108.bVonlysecondary;
  bVdisableteleport = other108.bVdisableteleport;
  iVtimestamp = other108.iVtimestamp;
  bVfulltablescan = other108.bVfulltablescan;
  __isset = other108.__isset;
}
ThrfL2os& ThrfL2os::operator=(const ThrfL2os& other109) {
  sVnamespace = other109.sVnamespace;
  sVosqlstring = other109.sVosqlstring;
  cVinputbindings = other109.cVinputbindings;
  bVonlysecondary = other109.bVonlysecondary;
  bVdisableteleport = other109.bVdisableteleport;
  iVtimestamp = other109.iVtimestamp;
  bVfulltablescan = other109.bVfulltablescan;
  __isset = other109.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2os& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2os(";
  out << "sVnamespace=" << to_string(obj.sVnamespace);
  out << ", " << "sVosqlstring=" << to_string(obj.sVosqlstring);
  out << ", " << "cVinputbindings=" << to_string(obj.cVinputbindings);
  out << ", " << "bVonlysecondary=" << to_string(obj.bVonlysecondary);
  out << ", " << "bVdisableteleport=" << to_string(obj.bVdisableteleport);
  out << ", " << "iVtimestamp=" << to_string(obj.iVtimestamp);
  out << ", " << "bVfulltablescan=" << to_string(obj.bVfulltablescan);
  out << ")";
  return out;
}


ThrfGoel::~ThrfGoel() throw() {
}


void ThrfGoel::__set_sVtoken(const std::string& val) {
  this->sVtoken = val;
}

void ThrfGoel::__set_sVnodeid(const std::string& val) {
  this->sVnodeid = val;
}

void ThrfGoel::__set_dVphiaccrual(const double val) {
  this->dVphiaccrual = val;
}

void ThrfGoel::__set_sVaddress(const std::string& val) {
  this->sVaddress = val;
}

void ThrfGoel::__set_iVport(const int32_t val) {
  this->iVport = val;
}

void ThrfGoel::__set_sVdatacenterid(const std::string& val) {
  this->sVdatacenterid = val;
}

void ThrfGoel::__set_iVstate(const iEstategossipnode::type val) {
  this->iVstate = val;
}

void ThrfGoel::__set_iVtimestamp(const int64_t val) {
  this->iVtimestamp = val;
}

void ThrfGoel::__set_iVsize(const int64_t val) {
  this->iVsize = val;
}

const char* ThrfGoel::ascii_fingerprint = "66664E4F8B1E171B59A9581CAD735933";
const uint8_t ThrfGoel::binary_fingerprint[16] = {0x66,0x66,0x4E,0x4F,0x8B,0x1E,0x17,0x1B,0x59,0xA9,0x58,0x1C,0xAD,0x73,0x59,0x33};

uint32_t ThrfGoel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVtoken = false;
  bool isset_sVnodeid = false;
  bool isset_dVphiaccrual = false;
  bool isset_sVdatacenterid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVtoken);
          isset_sVtoken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnodeid);
          isset_sVnodeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dVphiaccrual);
          isset_dVphiaccrual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVaddress);
          this->__isset.sVaddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVport);
          this->__isset.iVport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVdatacenterid);
          isset_sVdatacenterid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->iVstate = (iEstategossipnode::type)ecast110;
          this->__isset.iVstate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVtimestamp);
          this->__isset.iVtimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVsize);
          this->__isset.iVsize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVtoken)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVnodeid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dVphiaccrual)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVdatacenterid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfGoel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfGoel");

  xfer += oprot->writeFieldBegin("sVtoken", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVtoken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVnodeid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVnodeid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dVphiaccrual", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dVphiaccrual);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVaddress", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->sVaddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVport", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iVport);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVdatacenterid", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sVdatacenterid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVstate", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->iVstate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVtimestamp", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->iVtimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVsize", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->iVsize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfGoel &a, ThrfGoel &b) {
  using ::std::swap;
  swap(a.sVtoken, b.sVtoken);
  swap(a.sVnodeid, b.sVnodeid);
  swap(a.dVphiaccrual, b.dVphiaccrual);
  swap(a.sVaddress, b.sVaddress);
  swap(a.iVport, b.iVport);
  swap(a.sVdatacenterid, b.sVdatacenterid);
  swap(a.iVstate, b.iVstate);
  swap(a.iVtimestamp, b.iVtimestamp);
  swap(a.iVsize, b.iVsize);
  swap(a.__isset, b.__isset);
}

ThrfGoel::ThrfGoel(const ThrfGoel& other111) {
  sVtoken = other111.sVtoken;
  sVnodeid = other111.sVnodeid;
  dVphiaccrual = other111.dVphiaccrual;
  sVaddress = other111.sVaddress;
  iVport = other111.iVport;
  sVdatacenterid = other111.sVdatacenterid;
  iVstate = other111.iVstate;
  iVtimestamp = other111.iVtimestamp;
  iVsize = other111.iVsize;
  __isset = other111.__isset;
}
ThrfGoel& ThrfGoel::operator=(const ThrfGoel& other112) {
  sVtoken = other112.sVtoken;
  sVnodeid = other112.sVnodeid;
  dVphiaccrual = other112.dVphiaccrual;
  sVaddress = other112.sVaddress;
  iVport = other112.iVport;
  sVdatacenterid = other112.sVdatacenterid;
  iVstate = other112.iVstate;
  iVtimestamp = other112.iVtimestamp;
  iVsize = other112.iVsize;
  __isset = other112.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfGoel& obj) {
  using apache::thrift::to_string;
  out << "ThrfGoel(";
  out << "sVtoken=" << to_string(obj.sVtoken);
  out << ", " << "sVnodeid=" << to_string(obj.sVnodeid);
  out << ", " << "dVphiaccrual=" << to_string(obj.dVphiaccrual);
  out << ", " << "sVaddress=" << to_string(obj.sVaddress);
  out << ", " << "iVport=" << to_string(obj.iVport);
  out << ", " << "sVdatacenterid=" << to_string(obj.sVdatacenterid);
  out << ", " << "iVstate=" << to_string(obj.iVstate);
  out << ", " << "iVtimestamp=" << to_string(obj.iVtimestamp);
  out << ", " << "iVsize=" << to_string(obj.iVsize);
  out << ")";
  return out;
}


ThrfGoss::~ThrfGoss() throw() {
}


void ThrfGoss::__set_cVgossipelement(const std::vector<ThrfGoel> & val) {
  this->cVgossipelement = val;
}

const char* ThrfGoss::ascii_fingerprint = "24C4AFFE4AFF374F788CD9DB3DC2A4BA";
const uint8_t ThrfGoss::binary_fingerprint[16] = {0x24,0xC4,0xAF,0xFE,0x4A,0xFF,0x37,0x4F,0x78,0x8C,0xD9,0xDB,0x3D,0xC2,0xA4,0xBA};

uint32_t ThrfGoss::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVgossipelement.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->cVgossipelement.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += this->cVgossipelement[_i117].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVgossipelement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfGoss::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfGoss");

  xfer += oprot->writeFieldBegin("cVgossipelement", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVgossipelement.size()));
    std::vector<ThrfGoel> ::const_iterator _iter118;
    for (_iter118 = this->cVgossipelement.begin(); _iter118 != this->cVgossipelement.end(); ++_iter118)
    {
      xfer += (*_iter118).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfGoss &a, ThrfGoss &b) {
  using ::std::swap;
  swap(a.cVgossipelement, b.cVgossipelement);
  swap(a.__isset, b.__isset);
}

ThrfGoss::ThrfGoss(const ThrfGoss& other119) {
  cVgossipelement = other119.cVgossipelement;
  __isset = other119.__isset;
}
ThrfGoss& ThrfGoss::operator=(const ThrfGoss& other120) {
  cVgossipelement = other120.cVgossipelement;
  __isset = other120.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfGoss& obj) {
  using apache::thrift::to_string;
  out << "ThrfGoss(";
  out << "cVgossipelement=" << to_string(obj.cVgossipelement);
  out << ")";
  return out;
}


ThrfPtel::~ThrfPtel() throw() {
}


void ThrfPtel::__set_sVnodeid(const std::string& val) {
  this->sVnodeid = val;
}

void ThrfPtel::__set_sVbound(const std::string& val) {
  this->sVbound = val;
}

const char* ThrfPtel::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t ThrfPtel::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t ThrfPtel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVnodeid = false;
  bool isset_sVbound = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnodeid);
          isset_sVnodeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVbound);
          isset_sVbound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVnodeid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVbound)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfPtel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfPtel");

  xfer += oprot->writeFieldBegin("sVnodeid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVnodeid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVbound", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVbound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfPtel &a, ThrfPtel &b) {
  using ::std::swap;
  swap(a.sVnodeid, b.sVnodeid);
  swap(a.sVbound, b.sVbound);
}

ThrfPtel::ThrfPtel(const ThrfPtel& other121) {
  sVnodeid = other121.sVnodeid;
  sVbound = other121.sVbound;
}
ThrfPtel& ThrfPtel::operator=(const ThrfPtel& other122) {
  sVnodeid = other122.sVnodeid;
  sVbound = other122.sVbound;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfPtel& obj) {
  using apache::thrift::to_string;
  out << "ThrfPtel(";
  out << "sVnodeid=" << to_string(obj.sVnodeid);
  out << ", " << "sVbound=" << to_string(obj.sVbound);
  out << ")";
  return out;
}


ThrfTlel::~ThrfTlel() throw() {
}


void ThrfTlel::__set_iVtablettype(const iEtablettype::type val) {
  this->iVtablettype = val;
}

void ThrfTlel::__set_sVname(const std::string& val) {
  this->sVname = val;
}

void ThrfTlel::__set_bVvalid(const bool val) {
  this->bVvalid = val;
}

void ThrfTlel::__set_bVneedcompaction(const bool val) {
  this->bVneedcompaction = val;
}

void ThrfTlel::__set_bVvalidasmemorytable(const bool val) {
  this->bVvalidasmemorytable = val;
}

void ThrfTlel::__set_iVcompactionlevel(const int32_t val) {
  this->iVcompactionlevel = val;
}

void ThrfTlel::__set_sVmemorytable(const std::string& val) {
  this->sVmemorytable = val;
}

void ThrfTlel::__set_iVres(const int64_t val) {
  this->iVres = val;
}

void ThrfTlel::__set_iVmapped(const int64_t val) {
  this->iVmapped = val;
}

void ThrfTlel::__set_iVsize(const int64_t val) {
  this->iVsize = val;
}

void ThrfTlel::__set_iVcount(const int64_t val) {
  this->iVcount = val;
}

void ThrfTlel::__set_sVredotimestamp(const std::string& val) {
  this->sVredotimestamp = val;
}

void ThrfTlel::__set_iVsstabletype(const int32_t val) {
  this->iVsstabletype = val;
}

const char* ThrfTlel::ascii_fingerprint = "BF6A4B72A74CB252F65E60BCB570DEC5";
const uint8_t ThrfTlel::binary_fingerprint[16] = {0xBF,0x6A,0x4B,0x72,0xA7,0x4C,0xB2,0x52,0xF6,0x5E,0x60,0xBC,0xB5,0x70,0xDE,0xC5};

uint32_t ThrfTlel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVtablettype = false;
  bool isset_sVname = false;
  bool isset_bVvalid = false;
  bool isset_bVneedcompaction = false;
  bool isset_bVvalidasmemorytable = false;
  bool isset_iVcompactionlevel = false;
  bool isset_sVmemorytable = false;
  bool isset_iVres = false;
  bool isset_iVmapped = false;
  bool isset_iVsize = false;
  bool isset_iVcount = false;
  bool isset_sVredotimestamp = false;
  bool isset_iVsstabletype = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast123;
          xfer += iprot->readI32(ecast123);
          this->iVtablettype = (iEtablettype::type)ecast123;
          isset_iVtablettype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVname);
          isset_sVname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVvalid);
          isset_bVvalid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVneedcompaction);
          isset_bVneedcompaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVvalidasmemorytable);
          isset_bVvalidasmemorytable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVcompactionlevel);
          isset_iVcompactionlevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVmemorytable);
          isset_sVmemorytable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVres);
          isset_iVres = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVmapped);
          isset_iVmapped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVsize);
          isset_iVsize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVcount);
          isset_iVcount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVredotimestamp);
          isset_sVredotimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVsstabletype);
          isset_iVsstabletype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVtablettype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVname)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVvalid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVneedcompaction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVvalidasmemorytable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVcompactionlevel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVmemorytable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVres)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVmapped)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVsize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVcount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sVredotimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVsstabletype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfTlel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfTlel");

  xfer += oprot->writeFieldBegin("iVtablettype", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iVtablettype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVvalid", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bVvalid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVneedcompaction", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bVneedcompaction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVvalidasmemorytable", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->bVvalidasmemorytable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVcompactionlevel", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iVcompactionlevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVmemorytable", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->sVmemorytable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVres", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->iVres);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVmapped", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->iVmapped);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVsize", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->iVsize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVcount", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->iVcount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVredotimestamp", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->sVredotimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVsstabletype", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->iVsstabletype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfTlel &a, ThrfTlel &b) {
  using ::std::swap;
  swap(a.iVtablettype, b.iVtablettype);
  swap(a.sVname, b.sVname);
  swap(a.bVvalid, b.bVvalid);
  swap(a.bVneedcompaction, b.bVneedcompaction);
  swap(a.bVvalidasmemorytable, b.bVvalidasmemorytable);
  swap(a.iVcompactionlevel, b.iVcompactionlevel);
  swap(a.sVmemorytable, b.sVmemorytable);
  swap(a.iVres, b.iVres);
  swap(a.iVmapped, b.iVmapped);
  swap(a.iVsize, b.iVsize);
  swap(a.iVcount, b.iVcount);
  swap(a.sVredotimestamp, b.sVredotimestamp);
  swap(a.iVsstabletype, b.iVsstabletype);
}

ThrfTlel::ThrfTlel(const ThrfTlel& other124) {
  iVtablettype = other124.iVtablettype;
  sVname = other124.sVname;
  bVvalid = other124.bVvalid;
  bVneedcompaction = other124.bVneedcompaction;
  bVvalidasmemorytable = other124.bVvalidasmemorytable;
  iVcompactionlevel = other124.iVcompactionlevel;
  sVmemorytable = other124.sVmemorytable;
  iVres = other124.iVres;
  iVmapped = other124.iVmapped;
  iVsize = other124.iVsize;
  iVcount = other124.iVcount;
  sVredotimestamp = other124.sVredotimestamp;
  iVsstabletype = other124.iVsstabletype;
}
ThrfTlel& ThrfTlel::operator=(const ThrfTlel& other125) {
  iVtablettype = other125.iVtablettype;
  sVname = other125.sVname;
  bVvalid = other125.bVvalid;
  bVneedcompaction = other125.bVneedcompaction;
  bVvalidasmemorytable = other125.bVvalidasmemorytable;
  iVcompactionlevel = other125.iVcompactionlevel;
  sVmemorytable = other125.sVmemorytable;
  iVres = other125.iVres;
  iVmapped = other125.iVmapped;
  iVsize = other125.iVsize;
  iVcount = other125.iVcount;
  sVredotimestamp = other125.sVredotimestamp;
  iVsstabletype = other125.iVsstabletype;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfTlel& obj) {
  using apache::thrift::to_string;
  out << "ThrfTlel(";
  out << "iVtablettype=" << to_string(obj.iVtablettype);
  out << ", " << "sVname=" << to_string(obj.sVname);
  out << ", " << "bVvalid=" << to_string(obj.bVvalid);
  out << ", " << "bVneedcompaction=" << to_string(obj.bVneedcompaction);
  out << ", " << "bVvalidasmemorytable=" << to_string(obj.bVvalidasmemorytable);
  out << ", " << "iVcompactionlevel=" << to_string(obj.iVcompactionlevel);
  out << ", " << "sVmemorytable=" << to_string(obj.sVmemorytable);
  out << ", " << "iVres=" << to_string(obj.iVres);
  out << ", " << "iVmapped=" << to_string(obj.iVmapped);
  out << ", " << "iVsize=" << to_string(obj.iVsize);
  out << ", " << "iVcount=" << to_string(obj.iVcount);
  out << ", " << "sVredotimestamp=" << to_string(obj.sVredotimestamp);
  out << ", " << "iVsstabletype=" << to_string(obj.iVsstabletype);
  out << ")";
  return out;
}


ThrfTabl::~ThrfTabl() throw() {
}


void ThrfTabl::__set_sVxml(const std::string& val) {
  this->sVxml = val;
}

void ThrfTabl::__set_cVpartitionedelements(const std::vector<ThrfPtel> & val) {
  this->cVpartitionedelements = val;
}

void ThrfTabl::__set_cVpartitionedindexelements(const std::vector<ThrfPtel> & val) {
  this->cVpartitionedindexelements = val;
}

void ThrfTabl::__set_cVtabletelement(const std::vector<ThrfTlel> & val) {
  this->cVtabletelement = val;
}

void ThrfTabl::__set_cVindextabletelement(const std::vector<ThrfTlel> & val) {
  this->cVindextabletelement = val;
}

void ThrfTabl::__set_sVjoincustompartition(const std::string& val) {
  this->sVjoincustompartition = val;
}

void ThrfTabl::__set_sVjoincustompartitionindex(const std::string& val) {
  this->sVjoincustompartitionindex = val;
}

void ThrfTabl::__set_sVpartitiontype(const std::string& val) {
  this->sVpartitiontype = val;
}

const char* ThrfTabl::ascii_fingerprint = "F47AA2A9521E41A35AA914A39F3CDF3C";
const uint8_t ThrfTabl::binary_fingerprint[16] = {0xF4,0x7A,0xA2,0xA9,0x52,0x1E,0x41,0xA3,0x5A,0xA9,0x14,0xA3,0x9F,0x3C,0xDF,0x3C};

uint32_t ThrfTabl::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVxml = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVxml);
          isset_sVxml = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVpartitionedelements.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->cVpartitionedelements.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += this->cVpartitionedelements[_i130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVpartitionedelements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVpartitionedindexelements.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->cVpartitionedindexelements.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += this->cVpartitionedindexelements[_i135].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVpartitionedindexelements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVtabletelement.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readListBegin(_etype139, _size136);
            this->cVtabletelement.resize(_size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              xfer += this->cVtabletelement[_i140].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVtabletelement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVindextabletelement.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->cVindextabletelement.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += this->cVindextabletelement[_i145].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVindextabletelement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVjoincustompartition);
          this->__isset.sVjoincustompartition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVjoincustompartitionindex);
          this->__isset.sVjoincustompartitionindex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVpartitiontype);
          this->__isset.sVpartitiontype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVxml)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfTabl::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfTabl");

  xfer += oprot->writeFieldBegin("sVxml", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVxml);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVpartitionedelements", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVpartitionedelements.size()));
    std::vector<ThrfPtel> ::const_iterator _iter146;
    for (_iter146 = this->cVpartitionedelements.begin(); _iter146 != this->cVpartitionedelements.end(); ++_iter146)
    {
      xfer += (*_iter146).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVpartitionedindexelements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVpartitionedindexelements.size()));
    std::vector<ThrfPtel> ::const_iterator _iter147;
    for (_iter147 = this->cVpartitionedindexelements.begin(); _iter147 != this->cVpartitionedindexelements.end(); ++_iter147)
    {
      xfer += (*_iter147).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVtabletelement", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVtabletelement.size()));
    std::vector<ThrfTlel> ::const_iterator _iter148;
    for (_iter148 = this->cVtabletelement.begin(); _iter148 != this->cVtabletelement.end(); ++_iter148)
    {
      xfer += (*_iter148).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVindextabletelement", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVindextabletelement.size()));
    std::vector<ThrfTlel> ::const_iterator _iter149;
    for (_iter149 = this->cVindextabletelement.begin(); _iter149 != this->cVindextabletelement.end(); ++_iter149)
    {
      xfer += (*_iter149).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVjoincustompartition", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sVjoincustompartition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVjoincustompartitionindex", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->sVjoincustompartitionindex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVpartitiontype", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->sVpartitiontype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfTabl &a, ThrfTabl &b) {
  using ::std::swap;
  swap(a.sVxml, b.sVxml);
  swap(a.cVpartitionedelements, b.cVpartitionedelements);
  swap(a.cVpartitionedindexelements, b.cVpartitionedindexelements);
  swap(a.cVtabletelement, b.cVtabletelement);
  swap(a.cVindextabletelement, b.cVindextabletelement);
  swap(a.sVjoincustompartition, b.sVjoincustompartition);
  swap(a.sVjoincustompartitionindex, b.sVjoincustompartitionindex);
  swap(a.sVpartitiontype, b.sVpartitiontype);
  swap(a.__isset, b.__isset);
}

ThrfTabl::ThrfTabl(const ThrfTabl& other150) {
  sVxml = other150.sVxml;
  cVpartitionedelements = other150.cVpartitionedelements;
  cVpartitionedindexelements = other150.cVpartitionedindexelements;
  cVtabletelement = other150.cVtabletelement;
  cVindextabletelement = other150.cVindextabletelement;
  sVjoincustompartition = other150.sVjoincustompartition;
  sVjoincustompartitionindex = other150.sVjoincustompartitionindex;
  sVpartitiontype = other150.sVpartitiontype;
  __isset = other150.__isset;
}
ThrfTabl& ThrfTabl::operator=(const ThrfTabl& other151) {
  sVxml = other151.sVxml;
  cVpartitionedelements = other151.cVpartitionedelements;
  cVpartitionedindexelements = other151.cVpartitionedindexelements;
  cVtabletelement = other151.cVtabletelement;
  cVindextabletelement = other151.cVindextabletelement;
  sVjoincustompartition = other151.sVjoincustompartition;
  sVjoincustompartitionindex = other151.sVjoincustompartitionindex;
  sVpartitiontype = other151.sVpartitiontype;
  __isset = other151.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfTabl& obj) {
  using apache::thrift::to_string;
  out << "ThrfTabl(";
  out << "sVxml=" << to_string(obj.sVxml);
  out << ", " << "cVpartitionedelements=" << to_string(obj.cVpartitionedelements);
  out << ", " << "cVpartitionedindexelements=" << to_string(obj.cVpartitionedindexelements);
  out << ", " << "cVtabletelement=" << to_string(obj.cVtabletelement);
  out << ", " << "cVindextabletelement=" << to_string(obj.cVindextabletelement);
  out << ", " << "sVjoincustompartition=" << to_string(obj.sVjoincustompartition);
  out << ", " << "sVjoincustompartitionindex=" << to_string(obj.sVjoincustompartitionindex);
  out << ", " << "sVpartitiontype=" << to_string(obj.sVpartitiontype);
  out << ")";
  return out;
}


ThrfStel::~ThrfStel() throw() {
}


void ThrfStel::__set_iVcount(const int64_t val) {
  this->iVcount = val;
}

void ThrfStel::__set_iVmeandelay(const int32_t val) {
  this->iVmeandelay = val;
}

void ThrfStel::__set_iVworstdelay(const int32_t val) {
  this->iVworstdelay = val;
}

void ThrfStel::__set_iVsize(const int64_t val) {
  this->iVsize = val;
}

void ThrfStel::__set_iVelapsed(const int64_t val) {
  this->iVelapsed = val;
}

const char* ThrfStel::ascii_fingerprint = "AEE2FAF8C83F8A2810461026C139743F";
const uint8_t ThrfStel::binary_fingerprint[16] = {0xAE,0xE2,0xFA,0xF8,0xC8,0x3F,0x8A,0x28,0x10,0x46,0x10,0x26,0xC1,0x39,0x74,0x3F};

uint32_t ThrfStel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVcount = false;
  bool isset_iVmeandelay = false;
  bool isset_iVworstdelay = false;
  bool isset_iVsize = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVcount);
          isset_iVcount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVmeandelay);
          isset_iVmeandelay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVworstdelay);
          isset_iVworstdelay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVsize);
          isset_iVsize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVelapsed);
          this->__isset.iVelapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVcount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVmeandelay)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVworstdelay)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVsize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfStel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfStel");

  xfer += oprot->writeFieldBegin("iVcount", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->iVcount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVmeandelay", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iVmeandelay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVworstdelay", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iVworstdelay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVsize", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->iVsize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVelapsed", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->iVelapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfStel &a, ThrfStel &b) {
  using ::std::swap;
  swap(a.iVcount, b.iVcount);
  swap(a.iVmeandelay, b.iVmeandelay);
  swap(a.iVworstdelay, b.iVworstdelay);
  swap(a.iVsize, b.iVsize);
  swap(a.iVelapsed, b.iVelapsed);
  swap(a.__isset, b.__isset);
}

ThrfStel::ThrfStel(const ThrfStel& other152) {
  iVcount = other152.iVcount;
  iVmeandelay = other152.iVmeandelay;
  iVworstdelay = other152.iVworstdelay;
  iVsize = other152.iVsize;
  iVelapsed = other152.iVelapsed;
  __isset = other152.__isset;
}
ThrfStel& ThrfStel::operator=(const ThrfStel& other153) {
  iVcount = other153.iVcount;
  iVmeandelay = other153.iVmeandelay;
  iVworstdelay = other153.iVworstdelay;
  iVsize = other153.iVsize;
  iVelapsed = other153.iVelapsed;
  __isset = other153.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfStel& obj) {
  using apache::thrift::to_string;
  out << "ThrfStel(";
  out << "iVcount=" << to_string(obj.iVcount);
  out << ", " << "iVmeandelay=" << to_string(obj.iVmeandelay);
  out << ", " << "iVworstdelay=" << to_string(obj.iVworstdelay);
  out << ", " << "iVsize=" << to_string(obj.iVsize);
  out << ", " << "iVelapsed=" << to_string(obj.iVelapsed);
  out << ")";
  return out;
}


ThrfStth::~ThrfStth() throw() {
}


void ThrfStth::__set_iVprocessors(const int32_t val) {
  this->iVprocessors = val;
}

void ThrfStth::__set_iVconnections(const int32_t val) {
  this->iVconnections = val;
}

void ThrfStth::__set_iVidleconnections(const int32_t val) {
  this->iVidleconnections = val;
}

void ThrfStth::__set_iVmaxprocessors(const int32_t val) {
  this->iVmaxprocessors = val;
}

void ThrfStth::__set_iVmaxconnections(const int32_t val) {
  this->iVmaxconnections = val;
}

const char* ThrfStth::ascii_fingerprint = "2EB010665070FC89CB24AB9DA34D5F9D";
const uint8_t ThrfStth::binary_fingerprint[16] = {0x2E,0xB0,0x10,0x66,0x50,0x70,0xFC,0x89,0xCB,0x24,0xAB,0x9D,0xA3,0x4D,0x5F,0x9D};

uint32_t ThrfStth::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVprocessors = false;
  bool isset_iVconnections = false;
  bool isset_iVidleconnections = false;
  bool isset_iVmaxprocessors = false;
  bool isset_iVmaxconnections = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVprocessors);
          isset_iVprocessors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVconnections);
          isset_iVconnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVidleconnections);
          isset_iVidleconnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVmaxprocessors);
          isset_iVmaxprocessors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVmaxconnections);
          isset_iVmaxconnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVprocessors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVconnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVidleconnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVmaxprocessors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVmaxconnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfStth::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfStth");

  xfer += oprot->writeFieldBegin("iVprocessors", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iVprocessors);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVconnections", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iVconnections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVidleconnections", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iVidleconnections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVmaxprocessors", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iVmaxprocessors);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVmaxconnections", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iVmaxconnections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfStth &a, ThrfStth &b) {
  using ::std::swap;
  swap(a.iVprocessors, b.iVprocessors);
  swap(a.iVconnections, b.iVconnections);
  swap(a.iVidleconnections, b.iVidleconnections);
  swap(a.iVmaxprocessors, b.iVmaxprocessors);
  swap(a.iVmaxconnections, b.iVmaxconnections);
}

ThrfStth::ThrfStth(const ThrfStth& other154) {
  iVprocessors = other154.iVprocessors;
  iVconnections = other154.iVconnections;
  iVidleconnections = other154.iVidleconnections;
  iVmaxprocessors = other154.iVmaxprocessors;
  iVmaxconnections = other154.iVmaxconnections;
}
ThrfStth& ThrfStth::operator=(const ThrfStth& other155) {
  iVprocessors = other155.iVprocessors;
  iVconnections = other155.iVconnections;
  iVidleconnections = other155.iVidleconnections;
  iVmaxprocessors = other155.iVmaxprocessors;
  iVmaxconnections = other155.iVmaxconnections;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfStth& obj) {
  using apache::thrift::to_string;
  out << "ThrfStth(";
  out << "iVprocessors=" << to_string(obj.iVprocessors);
  out << ", " << "iVconnections=" << to_string(obj.iVconnections);
  out << ", " << "iVidleconnections=" << to_string(obj.iVidleconnections);
  out << ", " << "iVmaxprocessors=" << to_string(obj.iVmaxprocessors);
  out << ", " << "iVmaxconnections=" << to_string(obj.iVmaxconnections);
  out << ")";
  return out;
}


ThrfAenp::~ThrfAenp() throw() {
}


void ThrfAenp::__set_sVopaquedata(const std::string& val) {
  this->sVopaquedata = val;
}

void ThrfAenp::__set_sVnodeid(const std::string& val) {
  this->sVnodeid = val;
}

void ThrfAenp::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfAenp::__set_sVkeystart(const std::string& val) {
  this->sVkeystart = val;
}

void ThrfAenp::__set_iVlimitsize(const int32_t val) {
  this->iVlimitsize = val;
}

const char* ThrfAenp::ascii_fingerprint = "A26670596CD156B37A412F54D08BBA99";
const uint8_t ThrfAenp::binary_fingerprint[16] = {0xA2,0x66,0x70,0x59,0x6C,0xD1,0x56,0xB3,0x7A,0x41,0x2F,0x54,0xD0,0x8B,0xBA,0x99};

uint32_t ThrfAenp::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVopaquedata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVopaquedata);
          isset_sVopaquedata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnodeid);
          this->__isset.sVnodeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          this->__isset.cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVkeystart);
          this->__isset.sVkeystart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVlimitsize);
          this->__isset.iVlimitsize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVopaquedata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfAenp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfAenp");

  xfer += oprot->writeFieldBegin("sVopaquedata", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVopaquedata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVnodeid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVnodeid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVkeystart", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->sVkeystart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVlimitsize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iVlimitsize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfAenp &a, ThrfAenp &b) {
  using ::std::swap;
  swap(a.sVopaquedata, b.sVopaquedata);
  swap(a.sVnodeid, b.sVnodeid);
  swap(a.cVmutable, b.cVmutable);
  swap(a.sVkeystart, b.sVkeystart);
  swap(a.iVlimitsize, b.iVlimitsize);
  swap(a.__isset, b.__isset);
}

ThrfAenp::ThrfAenp(const ThrfAenp& other156) {
  sVopaquedata = other156.sVopaquedata;
  sVnodeid = other156.sVnodeid;
  cVmutable = other156.cVmutable;
  sVkeystart = other156.sVkeystart;
  iVlimitsize = other156.iVlimitsize;
  __isset = other156.__isset;
}
ThrfAenp& ThrfAenp::operator=(const ThrfAenp& other157) {
  sVopaquedata = other157.sVopaquedata;
  sVnodeid = other157.sVnodeid;
  cVmutable = other157.cVmutable;
  sVkeystart = other157.sVkeystart;
  iVlimitsize = other157.iVlimitsize;
  __isset = other157.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfAenp& obj) {
  using apache::thrift::to_string;
  out << "ThrfAenp(";
  out << "sVopaquedata=" << to_string(obj.sVopaquedata);
  out << ", " << "sVnodeid=" << to_string(obj.sVnodeid);
  out << ", " << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "sVkeystart=" << to_string(obj.sVkeystart);
  out << ", " << "iVlimitsize=" << to_string(obj.iVlimitsize);
  out << ")";
  return out;
}


ThrfTope::~ThrfTope() throw() {
}


void ThrfTope::__set_sVtablet(const std::string& val) {
  this->sVtablet = val;
}

void ThrfTope::__set_iVreadtime(const int64_t val) {
  this->iVreadtime = val;
}

void ThrfTope::__set_iVwritetime(const int64_t val) {
  this->iVwritetime = val;
}

void ThrfTope::__set_iVreadcountl2(const int64_t val) {
  this->iVreadcountl2 = val;
}

void ThrfTope::__set_iVwritecountl2(const int64_t val) {
  this->iVwritecountl2 = val;
}

void ThrfTope::__set_iVreadcountl1(const int64_t val) {
  this->iVreadcountl1 = val;
}

void ThrfTope::__set_iVwritecountl1(const int64_t val) {
  this->iVwritecountl1 = val;
}

const char* ThrfTope::ascii_fingerprint = "C81882A778978FEBDADBD08BCE2CD236";
const uint8_t ThrfTope::binary_fingerprint[16] = {0xC8,0x18,0x82,0xA7,0x78,0x97,0x8F,0xEB,0xDA,0xDB,0xD0,0x8B,0xCE,0x2C,0xD2,0x36};

uint32_t ThrfTope::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sVtablet = false;
  bool isset_iVreadtime = false;
  bool isset_iVwritetime = false;
  bool isset_iVreadcountl2 = false;
  bool isset_iVwritecountl2 = false;
  bool isset_iVreadcountl1 = false;
  bool isset_iVwritecountl1 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVtablet);
          isset_sVtablet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVreadtime);
          isset_iVreadtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVwritetime);
          isset_iVwritetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVreadcountl2);
          isset_iVreadcountl2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVwritecountl2);
          isset_iVwritecountl2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVreadcountl1);
          isset_iVreadcountl1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVwritecountl1);
          isset_iVwritecountl1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sVtablet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVreadtime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVwritetime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVreadcountl2)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVwritecountl2)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVreadcountl1)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_iVwritecountl1)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfTope::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfTope");

  xfer += oprot->writeFieldBegin("sVtablet", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sVtablet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVreadtime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->iVreadtime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVwritetime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->iVwritetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVreadcountl2", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->iVreadcountl2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVwritecountl2", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->iVwritecountl2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVreadcountl1", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->iVreadcountl1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVwritecountl1", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->iVwritecountl1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfTope &a, ThrfTope &b) {
  using ::std::swap;
  swap(a.sVtablet, b.sVtablet);
  swap(a.iVreadtime, b.iVreadtime);
  swap(a.iVwritetime, b.iVwritetime);
  swap(a.iVreadcountl2, b.iVreadcountl2);
  swap(a.iVwritecountl2, b.iVwritecountl2);
  swap(a.iVreadcountl1, b.iVreadcountl1);
  swap(a.iVwritecountl1, b.iVwritecountl1);
}

ThrfTope::ThrfTope(const ThrfTope& other158) {
  sVtablet = other158.sVtablet;
  iVreadtime = other158.iVreadtime;
  iVwritetime = other158.iVwritetime;
  iVreadcountl2 = other158.iVreadcountl2;
  iVwritecountl2 = other158.iVwritecountl2;
  iVreadcountl1 = other158.iVreadcountl1;
  iVwritecountl1 = other158.iVwritecountl1;
}
ThrfTope& ThrfTope::operator=(const ThrfTope& other159) {
  sVtablet = other159.sVtablet;
  iVreadtime = other159.iVreadtime;
  iVwritetime = other159.iVwritetime;
  iVreadcountl2 = other159.iVreadcountl2;
  iVwritecountl2 = other159.iVwritecountl2;
  iVreadcountl1 = other159.iVreadcountl1;
  iVwritecountl1 = other159.iVwritecountl1;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfTope& obj) {
  using apache::thrift::to_string;
  out << "ThrfTope(";
  out << "sVtablet=" << to_string(obj.sVtablet);
  out << ", " << "iVreadtime=" << to_string(obj.iVreadtime);
  out << ", " << "iVwritetime=" << to_string(obj.iVwritetime);
  out << ", " << "iVreadcountl2=" << to_string(obj.iVreadcountl2);
  out << ", " << "iVwritecountl2=" << to_string(obj.iVwritecountl2);
  out << ", " << "iVreadcountl1=" << to_string(obj.iVreadcountl1);
  out << ", " << "iVwritecountl1=" << to_string(obj.iVwritecountl1);
  out << ")";
  return out;
}


ThrfTop_::~ThrfTop_() throw() {
}


void ThrfTop_::__set_iVtimestamp(const int64_t val) {
  this->iVtimestamp = val;
}

void ThrfTop_::__set_cVtopelement(const std::vector<ThrfTope> & val) {
  this->cVtopelement = val;
}

const char* ThrfTop_::ascii_fingerprint = "487841EA677A54A50A3C256DC57687AA";
const uint8_t ThrfTop_::binary_fingerprint[16] = {0x48,0x78,0x41,0xEA,0x67,0x7A,0x54,0xA5,0x0A,0x3C,0x25,0x6D,0xC5,0x76,0x87,0xAA};

uint32_t ThrfTop_::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVtimestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVtimestamp);
          isset_iVtimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVtopelement.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->cVtopelement.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += this->cVtopelement[_i164].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVtopelement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVtimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfTop_::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfTop_");

  xfer += oprot->writeFieldBegin("iVtimestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->iVtimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVtopelement", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVtopelement.size()));
    std::vector<ThrfTope> ::const_iterator _iter165;
    for (_iter165 = this->cVtopelement.begin(); _iter165 != this->cVtopelement.end(); ++_iter165)
    {
      xfer += (*_iter165).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfTop_ &a, ThrfTop_ &b) {
  using ::std::swap;
  swap(a.iVtimestamp, b.iVtimestamp);
  swap(a.cVtopelement, b.cVtopelement);
  swap(a.__isset, b.__isset);
}

ThrfTop_::ThrfTop_(const ThrfTop_& other166) {
  iVtimestamp = other166.iVtimestamp;
  cVtopelement = other166.cVtopelement;
  __isset = other166.__isset;
}
ThrfTop_& ThrfTop_::operator=(const ThrfTop_& other167) {
  iVtimestamp = other167.iVtimestamp;
  cVtopelement = other167.cVtopelement;
  __isset = other167.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfTop_& obj) {
  using apache::thrift::to_string;
  out << "ThrfTop_(";
  out << "iVtimestamp=" << to_string(obj.iVtimestamp);
  out << ", " << "cVtopelement=" << to_string(obj.cVtopelement);
  out << ")";
  return out;
}


ThrfComm::~ThrfComm() throw() {
}


void ThrfComm::__set_iVcommand(const iEreservedkeyword::type val) {
  this->iVcommand = val;
}

void ThrfComm::__set_iVsubcommand(const iEreservedkeyword::type val) {
  this->iVsubcommand = val;
}

void ThrfComm::__set_sVreturnmessage(const std::string& val) {
  this->sVreturnmessage = val;
}

void ThrfComm::__set_sVaddress(const std::string& val) {
  this->sVaddress = val;
}

void ThrfComm::__set_iVport(const int32_t val) {
  this->iVport = val;
}

void ThrfComm::__set_sVtablet(const std::string& val) {
  this->sVtablet = val;
}

void ThrfComm::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfComm::__set_cVantientrophy(const ThrfAenp& val) {
  this->cVantientrophy = val;
}

void ThrfComm::__set_sVnodeid(const std::string& val) {
  this->sVnodeid = val;
}

void ThrfComm::__set_sVnewtoken(const std::string& val) {
  this->sVnewtoken = val;
}

void ThrfComm::__set_cVmutabledestination(const ThrfLmtb& val) {
  this->cVmutabledestination = val;
}

void ThrfComm::__set_iVtimestamp(const int64_t val) {
  this->iVtimestamp = val;
}

const char* ThrfComm::ascii_fingerprint = "E4BD9A2ABEDE2D0D79C3DE2A16D0CF68";
const uint8_t ThrfComm::binary_fingerprint[16] = {0xE4,0xBD,0x9A,0x2A,0xBE,0xDE,0x2D,0x0D,0x79,0xC3,0xDE,0x2A,0x16,0xD0,0xCF,0x68};

uint32_t ThrfComm::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast168;
          xfer += iprot->readI32(ecast168);
          this->iVcommand = (iEreservedkeyword::type)ecast168;
          this->__isset.iVcommand = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast169;
          xfer += iprot->readI32(ecast169);
          this->iVsubcommand = (iEreservedkeyword::type)ecast169;
          this->__isset.iVsubcommand = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVreturnmessage);
          this->__isset.sVreturnmessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVaddress);
          this->__isset.sVaddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVport);
          this->__isset.iVport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVtablet);
          this->__isset.sVtablet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          this->__isset.cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVantientrophy.read(iprot);
          this->__isset.cVantientrophy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnodeid);
          this->__isset.sVnodeid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVnewtoken);
          this->__isset.sVnewtoken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutabledestination.read(iprot);
          this->__isset.cVmutabledestination = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVtimestamp);
          this->__isset.iVtimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfComm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfComm");

  xfer += oprot->writeFieldBegin("iVcommand", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iVcommand);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVsubcommand", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->iVsubcommand);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVreturnmessage", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->sVreturnmessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVaddress", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->sVaddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVport", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iVport);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVtablet", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->sVtablet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVantientrophy", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->cVantientrophy.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVnodeid", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->sVnodeid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVnewtoken", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->sVnewtoken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVmutabledestination", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->cVmutabledestination.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVtimestamp", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->iVtimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfComm &a, ThrfComm &b) {
  using ::std::swap;
  swap(a.iVcommand, b.iVcommand);
  swap(a.iVsubcommand, b.iVsubcommand);
  swap(a.sVreturnmessage, b.sVreturnmessage);
  swap(a.sVaddress, b.sVaddress);
  swap(a.iVport, b.iVport);
  swap(a.sVtablet, b.sVtablet);
  swap(a.cVmutable, b.cVmutable);
  swap(a.cVantientrophy, b.cVantientrophy);
  swap(a.sVnodeid, b.sVnodeid);
  swap(a.sVnewtoken, b.sVnewtoken);
  swap(a.cVmutabledestination, b.cVmutabledestination);
  swap(a.iVtimestamp, b.iVtimestamp);
  swap(a.__isset, b.__isset);
}

ThrfComm::ThrfComm(const ThrfComm& other170) {
  iVcommand = other170.iVcommand;
  iVsubcommand = other170.iVsubcommand;
  sVreturnmessage = other170.sVreturnmessage;
  sVaddress = other170.sVaddress;
  iVport = other170.iVport;
  sVtablet = other170.sVtablet;
  cVmutable = other170.cVmutable;
  cVantientrophy = other170.cVantientrophy;
  sVnodeid = other170.sVnodeid;
  sVnewtoken = other170.sVnewtoken;
  cVmutabledestination = other170.cVmutabledestination;
  iVtimestamp = other170.iVtimestamp;
  __isset = other170.__isset;
}
ThrfComm& ThrfComm::operator=(const ThrfComm& other171) {
  iVcommand = other171.iVcommand;
  iVsubcommand = other171.iVsubcommand;
  sVreturnmessage = other171.sVreturnmessage;
  sVaddress = other171.sVaddress;
  iVport = other171.iVport;
  sVtablet = other171.sVtablet;
  cVmutable = other171.cVmutable;
  cVantientrophy = other171.cVantientrophy;
  sVnodeid = other171.sVnodeid;
  sVnewtoken = other171.sVnewtoken;
  cVmutabledestination = other171.cVmutabledestination;
  iVtimestamp = other171.iVtimestamp;
  __isset = other171.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfComm& obj) {
  using apache::thrift::to_string;
  out << "ThrfComm(";
  out << "iVcommand=" << to_string(obj.iVcommand);
  out << ", " << "iVsubcommand=" << to_string(obj.iVsubcommand);
  out << ", " << "sVreturnmessage=" << to_string(obj.sVreturnmessage);
  out << ", " << "sVaddress=" << to_string(obj.sVaddress);
  out << ", " << "iVport=" << to_string(obj.iVport);
  out << ", " << "sVtablet=" << to_string(obj.sVtablet);
  out << ", " << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "cVantientrophy=" << to_string(obj.cVantientrophy);
  out << ", " << "sVnodeid=" << to_string(obj.sVnodeid);
  out << ", " << "sVnewtoken=" << to_string(obj.sVnewtoken);
  out << ", " << "cVmutabledestination=" << to_string(obj.cVmutabledestination);
  out << ", " << "iVtimestamp=" << to_string(obj.iVtimestamp);
  out << ")";
  return out;
}


ThrfCort::~ThrfCort() throw() {
}


void ThrfCort::__set_bVreturn(const bool val) {
  this->bVreturn = val;
}

void ThrfCort::__set_sVreturnmessage(const std::string& val) {
  this->sVreturnmessage = val;
}

void ThrfCort::__set_cVreturntable(const ThrfTabl& val) {
  this->cVreturntable = val;
}

void ThrfCort::__set_cVreturnstats(const ThrfStel& val) {
  this->cVreturnstats = val;
}

void ThrfCort::__set_cVreturnthriftstats(const ThrfStth& val) {
  this->cVreturnthriftstats = val;
}

void ThrfCort::__set_cVreturnantientrophy(const ThrfAenp& val) {
  this->cVreturnantientrophy = val;
}

void ThrfCort::__set_cVreturntop(const ThrfTop_& val) {
  this->cVreturntop = val;
}

void ThrfCort::__set_iVreturn(const int64_t val) {
  this->iVreturn = val;
}

const char* ThrfCort::ascii_fingerprint = "13B1E7FD17AF53534595A702E759F57A";
const uint8_t ThrfCort::binary_fingerprint[16] = {0x13,0xB1,0xE7,0xFD,0x17,0xAF,0x53,0x53,0x45,0x95,0xA7,0x02,0xE7,0x59,0xF5,0x7A};

uint32_t ThrfCort::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVreturn);
          this->__isset.bVreturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVreturnmessage);
          this->__isset.sVreturnmessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVreturntable.read(iprot);
          this->__isset.cVreturntable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVreturnstats.read(iprot);
          this->__isset.cVreturnstats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVreturnthriftstats.read(iprot);
          this->__isset.cVreturnthriftstats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVreturnantientrophy.read(iprot);
          this->__isset.cVreturnantientrophy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVreturntop.read(iprot);
          this->__isset.cVreturntop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->iVreturn);
          this->__isset.iVreturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfCort::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfCort");

  xfer += oprot->writeFieldBegin("bVreturn", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bVreturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVreturnmessage", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sVreturnmessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVreturntable", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVreturntable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVreturnstats", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->cVreturnstats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVreturnthriftstats", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->cVreturnthriftstats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVreturnantientrophy", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->cVreturnantientrophy.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVreturntop", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->cVreturntop.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVreturn", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->iVreturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfCort &a, ThrfCort &b) {
  using ::std::swap;
  swap(a.bVreturn, b.bVreturn);
  swap(a.sVreturnmessage, b.sVreturnmessage);
  swap(a.cVreturntable, b.cVreturntable);
  swap(a.cVreturnstats, b.cVreturnstats);
  swap(a.cVreturnthriftstats, b.cVreturnthriftstats);
  swap(a.cVreturnantientrophy, b.cVreturnantientrophy);
  swap(a.cVreturntop, b.cVreturntop);
  swap(a.iVreturn, b.iVreturn);
  swap(a.__isset, b.__isset);
}

ThrfCort::ThrfCort(const ThrfCort& other172) {
  bVreturn = other172.bVreturn;
  sVreturnmessage = other172.sVreturnmessage;
  cVreturntable = other172.cVreturntable;
  cVreturnstats = other172.cVreturnstats;
  cVreturnthriftstats = other172.cVreturnthriftstats;
  cVreturnantientrophy = other172.cVreturnantientrophy;
  cVreturntop = other172.cVreturntop;
  iVreturn = other172.iVreturn;
  __isset = other172.__isset;
}
ThrfCort& ThrfCort::operator=(const ThrfCort& other173) {
  bVreturn = other173.bVreturn;
  sVreturnmessage = other173.sVreturnmessage;
  cVreturntable = other173.cVreturntable;
  cVreturnstats = other173.cVreturnstats;
  cVreturnthriftstats = other173.cVreturnthriftstats;
  cVreturnantientrophy = other173.cVreturnantientrophy;
  cVreturntop = other173.cVreturntop;
  iVreturn = other173.iVreturn;
  __isset = other173.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfCort& obj) {
  using apache::thrift::to_string;
  out << "ThrfCort(";
  out << "bVreturn=" << to_string(obj.bVreturn);
  out << ", " << "sVreturnmessage=" << to_string(obj.sVreturnmessage);
  out << ", " << "cVreturntable=" << to_string(obj.cVreturntable);
  out << ", " << "cVreturnstats=" << to_string(obj.cVreturnstats);
  out << ", " << "cVreturnthriftstats=" << to_string(obj.cVreturnthriftstats);
  out << ", " << "cVreturnantientrophy=" << to_string(obj.cVreturnantientrophy);
  out << ", " << "cVreturntop=" << to_string(obj.cVreturntop);
  out << ", " << "iVreturn=" << to_string(obj.iVreturn);
  out << ")";
  return out;
}


ThrfLqry::~ThrfLqry() throw() {
}


void ThrfLqry::__set_iVquery(const iEquerytype::type val) {
  this->iVquery = val;
}

void ThrfLqry::__set_cVmutable(const ThrfLmtb& val) {
  this->cVmutable = val;
}

void ThrfLqry::__set_cVkey(const ThrfLkey& val) {
  this->cVkey = val;
}

void ThrfLqry::__set_bVdigest(const bool val) {
  this->bVdigest = val;
}

void ThrfLqry::__set_sVcallback(const std::string& val) {
  this->sVcallback = val;
}

const char* ThrfLqry::ascii_fingerprint = "DEF294DA011CE3842D0C4F2FA5E82F3B";
const uint8_t ThrfLqry::binary_fingerprint[16] = {0xDE,0xF2,0x94,0xDA,0x01,0x1C,0xE3,0x84,0x2D,0x0C,0x4F,0x2F,0xA5,0xE8,0x2F,0x3B};

uint32_t ThrfLqry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVquery = false;
  bool isset_cVmutable = false;
  bool isset_cVkey = false;
  bool isset_bVdigest = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast174;
          xfer += iprot->readI32(ecast174);
          this->iVquery = (iEquerytype::type)ecast174;
          isset_iVquery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVmutable.read(iprot);
          isset_cVmutable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVkey.read(iprot);
          isset_cVkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVdigest);
          isset_bVdigest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sVcallback);
          this->__isset.sVcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVquery)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cVmutable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cVkey)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bVdigest)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfLqry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfLqry");

  xfer += oprot->writeFieldBegin("iVquery", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iVquery);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVmutable", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cVmutable.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVkey", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVkey.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVdigest", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bVdigest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVcallback", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sVcallback);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfLqry &a, ThrfLqry &b) {
  using ::std::swap;
  swap(a.iVquery, b.iVquery);
  swap(a.cVmutable, b.cVmutable);
  swap(a.cVkey, b.cVkey);
  swap(a.bVdigest, b.bVdigest);
  swap(a.sVcallback, b.sVcallback);
  swap(a.__isset, b.__isset);
}

ThrfLqry::ThrfLqry(const ThrfLqry& other175) {
  iVquery = other175.iVquery;
  cVmutable = other175.cVmutable;
  cVkey = other175.cVkey;
  bVdigest = other175.bVdigest;
  sVcallback = other175.sVcallback;
  __isset = other175.__isset;
}
ThrfLqry& ThrfLqry::operator=(const ThrfLqry& other176) {
  iVquery = other176.iVquery;
  cVmutable = other176.cVmutable;
  cVkey = other176.cVkey;
  bVdigest = other176.bVdigest;
  sVcallback = other176.sVcallback;
  __isset = other176.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfLqry& obj) {
  using apache::thrift::to_string;
  out << "ThrfLqry(";
  out << "iVquery=" << to_string(obj.iVquery);
  out << ", " << "cVmutable=" << to_string(obj.cVmutable);
  out << ", " << "cVkey=" << to_string(obj.cVkey);
  out << ", " << "bVdigest=" << to_string(obj.bVdigest);
  out << ", " << "sVcallback=" << to_string(obj.sVcallback);
  out << ")";
  return out;
}


ThrfL2qb::~ThrfL2qb() throw() {
}


void ThrfL2qb::__set_cKeyslices(const std::vector<ThrfL2ks> & val) {
  this->cKeyslices = val;
}

void ThrfL2qb::__set_bVreturn(const bool val) {
  this->bVreturn = val;
}

const char* ThrfL2qb::ascii_fingerprint = "BF84E14BCC27A0E775184D2D701A03A2";
const uint8_t ThrfL2qb::binary_fingerprint[16] = {0xBF,0x84,0xE1,0x4B,0xCC,0x27,0xA0,0xE7,0x75,0x18,0x4D,0x2D,0x70,0x1A,0x03,0xA2};

uint32_t ThrfL2qb::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cKeyslices.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->cKeyslices.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += this->cKeyslices[_i181].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cKeyslices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVreturn);
          this->__isset.bVreturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfL2qb::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfL2qb");

  xfer += oprot->writeFieldBegin("cKeyslices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cKeyslices.size()));
    std::vector<ThrfL2ks> ::const_iterator _iter182;
    for (_iter182 = this->cKeyslices.begin(); _iter182 != this->cKeyslices.end(); ++_iter182)
    {
      xfer += (*_iter182).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bVreturn", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bVreturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfL2qb &a, ThrfL2qb &b) {
  using ::std::swap;
  swap(a.cKeyslices, b.cKeyslices);
  swap(a.bVreturn, b.bVreturn);
  swap(a.__isset, b.__isset);
}

ThrfL2qb::ThrfL2qb(const ThrfL2qb& other183) {
  cKeyslices = other183.cKeyslices;
  bVreturn = other183.bVreturn;
  __isset = other183.__isset;
}
ThrfL2qb& ThrfL2qb::operator=(const ThrfL2qb& other184) {
  cKeyslices = other184.cKeyslices;
  bVreturn = other184.bVreturn;
  __isset = other184.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfL2qb& obj) {
  using apache::thrift::to_string;
  out << "ThrfL2qb(";
  out << "cKeyslices=" << to_string(obj.cKeyslices);
  out << ", " << "bVreturn=" << to_string(obj.bVreturn);
  out << ")";
  return out;
}


ThrfSrvc::~ThrfSrvc() throw() {
}


void ThrfSrvc::__set_iVservicetype(const iEservicetype::type val) {
  this->iVservicetype = val;
}

void ThrfSrvc::__set_cVquery(const ThrfL2qr& val) {
  this->cVquery = val;
}

void ThrfSrvc::__set_cVstatement(const ThrfL2st& val) {
  this->cVstatement = val;
}

void ThrfSrvc::__set_cVosql(const ThrfL2os& val) {
  this->cVosql = val;
}

const char* ThrfSrvc::ascii_fingerprint = "81046A41E2B5AFA05FBD807B65C2B276";
const uint8_t ThrfSrvc::binary_fingerprint[16] = {0x81,0x04,0x6A,0x41,0xE2,0xB5,0xAF,0xA0,0x5F,0xBD,0x80,0x7B,0x65,0xC2,0xB2,0x76};

uint32_t ThrfSrvc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVservicetype = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast185;
          xfer += iprot->readI32(ecast185);
          this->iVservicetype = (iEservicetype::type)ecast185;
          isset_iVservicetype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVquery.read(iprot);
          this->__isset.cVquery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVstatement.read(iprot);
          this->__isset.cVstatement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVosql.read(iprot);
          this->__isset.cVosql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVservicetype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfSrvc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfSrvc");

  xfer += oprot->writeFieldBegin("iVservicetype", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iVservicetype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVquery", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cVquery.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVstatement", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVstatement.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVosql", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->cVosql.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfSrvc &a, ThrfSrvc &b) {
  using ::std::swap;
  swap(a.iVservicetype, b.iVservicetype);
  swap(a.cVquery, b.cVquery);
  swap(a.cVstatement, b.cVstatement);
  swap(a.cVosql, b.cVosql);
  swap(a.__isset, b.__isset);
}

ThrfSrvc::ThrfSrvc(const ThrfSrvc& other186) {
  iVservicetype = other186.iVservicetype;
  cVquery = other186.cVquery;
  cVstatement = other186.cVstatement;
  cVosql = other186.cVosql;
  __isset = other186.__isset;
}
ThrfSrvc& ThrfSrvc::operator=(const ThrfSrvc& other187) {
  iVservicetype = other187.iVservicetype;
  cVquery = other187.cVquery;
  cVstatement = other187.cVstatement;
  cVosql = other187.cVosql;
  __isset = other187.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfSrvc& obj) {
  using apache::thrift::to_string;
  out << "ThrfSrvc(";
  out << "iVservicetype=" << to_string(obj.iVservicetype);
  out << ", " << "cVquery=" << to_string(obj.cVquery);
  out << ", " << "cVstatement=" << to_string(obj.cVstatement);
  out << ", " << "cVosql=" << to_string(obj.cVosql);
  out << ")";
  return out;
}


ThrfSrvr::~ThrfSrvr() throw() {
}


void ThrfSrvr::__set_bVreturn(const bool val) {
  this->bVreturn = val;
}

void ThrfSrvr::__set_cVdmlresult(const std::vector<ThrfL2ks> & val) {
  this->cVdmlresult = val;
}

void ThrfSrvr::__set_cVqueryresult(const ThrfL2qb& val) {
  this->cVqueryresult = val;
}

const char* ThrfSrvr::ascii_fingerprint = "E0D4D756AE3B93412174E6B2BC9B6509";
const uint8_t ThrfSrvr::binary_fingerprint[16] = {0xE0,0xD4,0xD7,0x56,0xAE,0x3B,0x93,0x41,0x21,0x74,0xE6,0xB2,0xBC,0x9B,0x65,0x09};

uint32_t ThrfSrvr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bVreturn);
          this->__isset.bVreturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVdmlresult.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _etype191;
            xfer += iprot->readListBegin(_etype191, _size188);
            this->cVdmlresult.resize(_size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              xfer += this->cVdmlresult[_i192].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVdmlresult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVqueryresult.read(iprot);
          this->__isset.cVqueryresult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfSrvr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfSrvr");

  xfer += oprot->writeFieldBegin("bVreturn", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bVreturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVdmlresult", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVdmlresult.size()));
    std::vector<ThrfL2ks> ::const_iterator _iter193;
    for (_iter193 = this->cVdmlresult.begin(); _iter193 != this->cVdmlresult.end(); ++_iter193)
    {
      xfer += (*_iter193).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVqueryresult", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVqueryresult.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfSrvr &a, ThrfSrvr &b) {
  using ::std::swap;
  swap(a.bVreturn, b.bVreturn);
  swap(a.cVdmlresult, b.cVdmlresult);
  swap(a.cVqueryresult, b.cVqueryresult);
  swap(a.__isset, b.__isset);
}

ThrfSrvr::ThrfSrvr(const ThrfSrvr& other194) {
  bVreturn = other194.bVreturn;
  cVdmlresult = other194.cVdmlresult;
  cVqueryresult = other194.cVqueryresult;
  __isset = other194.__isset;
}
ThrfSrvr& ThrfSrvr::operator=(const ThrfSrvr& other195) {
  bVreturn = other195.bVreturn;
  cVdmlresult = other195.cVdmlresult;
  cVqueryresult = other195.cVqueryresult;
  __isset = other195.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfSrvr& obj) {
  using apache::thrift::to_string;
  out << "ThrfSrvr(";
  out << "bVreturn=" << to_string(obj.bVreturn);
  out << ", " << "cVdmlresult=" << to_string(obj.cVdmlresult);
  out << ", " << "cVqueryresult=" << to_string(obj.cVqueryresult);
  out << ")";
  return out;
}


ThrfBsrc::~ThrfBsrc() throw() {
}


void ThrfBsrc::__set_iVbulkservicetype(const iEbulkservicetype::type val) {
  this->iVbulkservicetype = val;
}

void ThrfBsrc::__set_cVbulkthrift(const std::vector<ThrfSrvc> & val) {
  this->cVbulkthrift = val;
}

void ThrfBsrc::__set_cVbulkstring(const std::vector<std::string> & val) {
  this->cVbulkstring = val;
}

void ThrfBsrc::__set_cVsinglethrift(const ThrfSrvc& val) {
  this->cVsinglethrift = val;
}

const char* ThrfBsrc::ascii_fingerprint = "69C64A87683EB9F7241D3F9A6402EC8E";
const uint8_t ThrfBsrc::binary_fingerprint[16] = {0x69,0xC6,0x4A,0x87,0x68,0x3E,0xB9,0xF7,0x24,0x1D,0x3F,0x9A,0x64,0x02,0xEC,0x8E};

uint32_t ThrfBsrc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iVbulkservicetype = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast196;
          xfer += iprot->readI32(ecast196);
          this->iVbulkservicetype = (iEbulkservicetype::type)ecast196;
          isset_iVbulkservicetype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVbulkthrift.clear();
            uint32_t _size197;
            ::apache::thrift::protocol::TType _etype200;
            xfer += iprot->readListBegin(_etype200, _size197);
            this->cVbulkthrift.resize(_size197);
            uint32_t _i201;
            for (_i201 = 0; _i201 < _size197; ++_i201)
            {
              xfer += this->cVbulkthrift[_i201].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVbulkthrift = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVbulkstring.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _etype205;
            xfer += iprot->readListBegin(_etype205, _size202);
            this->cVbulkstring.resize(_size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              xfer += iprot->readString(this->cVbulkstring[_i206]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVbulkstring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVsinglethrift.read(iprot);
          this->__isset.cVsinglethrift = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iVbulkservicetype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThrfBsrc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfBsrc");

  xfer += oprot->writeFieldBegin("iVbulkservicetype", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iVbulkservicetype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVbulkthrift", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVbulkthrift.size()));
    std::vector<ThrfSrvc> ::const_iterator _iter207;
    for (_iter207 = this->cVbulkthrift.begin(); _iter207 != this->cVbulkthrift.end(); ++_iter207)
    {
      xfer += (*_iter207).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVbulkstring", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cVbulkstring.size()));
    std::vector<std::string> ::const_iterator _iter208;
    for (_iter208 = this->cVbulkstring.begin(); _iter208 != this->cVbulkstring.end(); ++_iter208)
    {
      xfer += oprot->writeString((*_iter208));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVsinglethrift", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->cVsinglethrift.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfBsrc &a, ThrfBsrc &b) {
  using ::std::swap;
  swap(a.iVbulkservicetype, b.iVbulkservicetype);
  swap(a.cVbulkthrift, b.cVbulkthrift);
  swap(a.cVbulkstring, b.cVbulkstring);
  swap(a.cVsinglethrift, b.cVsinglethrift);
  swap(a.__isset, b.__isset);
}

ThrfBsrc::ThrfBsrc(const ThrfBsrc& other209) {
  iVbulkservicetype = other209.iVbulkservicetype;
  cVbulkthrift = other209.cVbulkthrift;
  cVbulkstring = other209.cVbulkstring;
  cVsinglethrift = other209.cVsinglethrift;
  __isset = other209.__isset;
}
ThrfBsrc& ThrfBsrc::operator=(const ThrfBsrc& other210) {
  iVbulkservicetype = other210.iVbulkservicetype;
  cVbulkthrift = other210.cVbulkthrift;
  cVbulkstring = other210.cVbulkstring;
  cVsinglethrift = other210.cVsinglethrift;
  __isset = other210.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfBsrc& obj) {
  using apache::thrift::to_string;
  out << "ThrfBsrc(";
  out << "iVbulkservicetype=" << to_string(obj.iVbulkservicetype);
  out << ", " << "cVbulkthrift=" << to_string(obj.cVbulkthrift);
  out << ", " << "cVbulkstring=" << to_string(obj.cVbulkstring);
  out << ", " << "cVsinglethrift=" << to_string(obj.cVsinglethrift);
  out << ")";
  return out;
}


ThrfBsrr::~ThrfBsrr() throw() {
}


void ThrfBsrr::__set_cVbulkthrift(const std::vector<ThrfSrvr> & val) {
  this->cVbulkthrift = val;
}

void ThrfBsrr::__set_cVbulkstring(const std::vector<std::string> & val) {
  this->cVbulkstring = val;
}

void ThrfBsrr::__set_cVsinglethrift(const ThrfSrvr& val) {
  this->cVsinglethrift = val;
}

const char* ThrfBsrr::ascii_fingerprint = "5E68E748C3F239797E8C78FBF8771628";
const uint8_t ThrfBsrr::binary_fingerprint[16] = {0x5E,0x68,0xE7,0x48,0xC3,0xF2,0x39,0x79,0x7E,0x8C,0x78,0xFB,0xF8,0x77,0x16,0x28};

uint32_t ThrfBsrr::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVbulkthrift.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->cVbulkthrift.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              xfer += this->cVbulkthrift[_i215].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVbulkthrift = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cVbulkstring.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _etype219;
            xfer += iprot->readListBegin(_etype219, _size216);
            this->cVbulkstring.resize(_size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              xfer += iprot->readString(this->cVbulkstring[_i220]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cVbulkstring = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cVsinglethrift.read(iprot);
          this->__isset.cVsinglethrift = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrfBsrr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ThrfBsrr");

  xfer += oprot->writeFieldBegin("cVbulkthrift", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cVbulkthrift.size()));
    std::vector<ThrfSrvr> ::const_iterator _iter221;
    for (_iter221 = this->cVbulkthrift.begin(); _iter221 != this->cVbulkthrift.end(); ++_iter221)
    {
      xfer += (*_iter221).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVbulkstring", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cVbulkstring.size()));
    std::vector<std::string> ::const_iterator _iter222;
    for (_iter222 = this->cVbulkstring.begin(); _iter222 != this->cVbulkstring.end(); ++_iter222)
    {
      xfer += oprot->writeString((*_iter222));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cVsinglethrift", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->cVsinglethrift.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ThrfBsrr &a, ThrfBsrr &b) {
  using ::std::swap;
  swap(a.cVbulkthrift, b.cVbulkthrift);
  swap(a.cVbulkstring, b.cVbulkstring);
  swap(a.cVsinglethrift, b.cVsinglethrift);
  swap(a.__isset, b.__isset);
}

ThrfBsrr::ThrfBsrr(const ThrfBsrr& other223) {
  cVbulkthrift = other223.cVbulkthrift;
  cVbulkstring = other223.cVbulkstring;
  cVsinglethrift = other223.cVsinglethrift;
  __isset = other223.__isset;
}
ThrfBsrr& ThrfBsrr::operator=(const ThrfBsrr& other224) {
  cVbulkthrift = other224.cVbulkthrift;
  cVbulkstring = other224.cVbulkstring;
  cVsinglethrift = other224.cVsinglethrift;
  __isset = other224.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ThrfBsrr& obj) {
  using apache::thrift::to_string;
  out << "ThrfBsrr(";
  out << "cVbulkthrift=" << to_string(obj.cVbulkthrift);
  out << ", " << "cVbulkstring=" << to_string(obj.cVbulkstring);
  out << ", " << "cVsinglethrift=" << to_string(obj.cVsinglethrift);
  out << ")";
  return out;
}


