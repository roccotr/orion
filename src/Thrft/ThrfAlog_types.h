/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ThrfAlog_TYPES_H
#define ThrfAlog_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct iEstatetype {
  enum type {
    UPSERT = 0,
    DELTMB = 1
  };
};

extern const std::map<int, const char*> _iEstatetype_VALUES_TO_NAMES;

struct iEcolumntype {
  enum type {
    KEYTYPE___ = 0,
    STRINGTYPE = 1,
    LSTRNGTYPE = 2,
    INTEGRTYPE = 3,
    LINTGRTYPE = 4,
    DOUBLETYPE = 5,
    LDOUBLTYPE = 6,
    BOOLN_TYPE = 7
  };
};

extern const std::map<int, const char*> _iEcolumntype_VALUES_TO_NAMES;

struct iEconditiontype {
  enum type {
    ECOND = 0,
    GCOND = 1,
    LCOND = 2,
    GECOND = 3,
    LECOND = 4
  };
};

extern const std::map<int, const char*> _iEconditiontype_VALUES_TO_NAMES;

struct iEopcodetype {
  enum type {
    MUTATOR = 0,
    REPAIR_ = 2
  };
};

extern const std::map<int, const char*> _iEopcodetype_VALUES_TO_NAMES;

struct iEquerytype {
  enum type {
    EXACTQUERY = 0,
    RANGEQUERY = 1,
    TOKENQUERY = 2,
    TKALLQUERY = 3,
    TKSLWQUERY = 4
  };
};

extern const std::map<int, const char*> _iEquerytype_VALUES_TO_NAMES;

struct iEordertype {
  enum type {
    ASC = 0,
    DESC = 1
  };
};

extern const std::map<int, const char*> _iEordertype_VALUES_TO_NAMES;

struct iEstategossipnode {
  enum type {
    RUNNING = 0,
    JOINING = 1,
    LEAVING = 2,
    STOPPED = 3,
    LOADING = 4
  };
};

extern const std::map<int, const char*> _iEstategossipnode_VALUES_TO_NAMES;

struct iEreservedkeyword {
  enum type {
    STARTUP = 0,
    SHUTDOWN = 1,
    VERS = 2,
    NETWORK = 3,
    ADD = 4,
    REMOVE = 5,
    JOIN = 6,
    LEAVE = 7,
    TABLET = 8,
    STORE = 9,
    FORGET = 10,
    LOAD = 11,
    STATS = 12,
    READ = 13,
    WRITE = 14,
    INFO = 15,
    TOUCH = 16,
    KILL = 17,
    STOPTHRIFT = 18,
    STARTTHRIFT = 19,
    DISCONNECT = 20,
    RESETLOCAL = 21,
    STATSTHRIFT = 22,
    ANTIENTROPHY = 23,
    PULLALL = 24,
    PPULLMATCH = 25,
    PPULLREPAIR = 26,
    TABLE = 27,
    REBUILD = 28,
    SPLIT = 30,
    JOINFAST = 31,
    STOPSEDA = 32,
    STARTSEDA = 33,
    ADDFAST = 34,
    FREEZE = 35,
    RELOAD = 36,
    TOP = 37,
    CLEAN = 38,
    PURGE = 39,
    REPAIR = 40,
    TRUNCATE = 41,
    SHRINK = 42,
    SOFTSHRINK = 43,
    COMPACTION = 44,
    REMOVEFAST = 45,
    LEAVEFAST = 46,
    REBUILDPART = 47,
    SIZE = 48,
    CLONE = 49,
    REBOUND = 50,
    REJOIN = 51,
    NORMAL = 100,
    ABORT = 101
  };
};

extern const std::map<int, const char*> _iEreservedkeyword_VALUES_TO_NAMES;

struct iEtablettype {
  enum type {
    MEMORYTABLETYPE = 0,
    SSTABLETYPE = 1
  };
};

extern const std::map<int, const char*> _iEtablettype_VALUES_TO_NAMES;

struct iEservicetype {
  enum type {
    STATEMENT = 0,
    QUERY = 1,
    OSQL = 2
  };
};

extern const std::map<int, const char*> _iEservicetype_VALUES_TO_NAMES;

struct iEbulkservicetype {
  enum type {
    BULKTHRIFT = 0,
    BULKSTRING = 1,
    SINGLETHRIFT = 2,
    PING = 3
  };
};

extern const std::map<int, const char*> _iEbulkservicetype_VALUES_TO_NAMES;

class ThrfLmtb;

class ThrfLkey;

class ThrfL2cv;

class ThrfL2cl;

class ThrfLval;

class ThrfL1ks;

class ThrfLstm;

class ThrfL2st;

class ThrfL2ag;

class ThrfL2ct;

class ThrfL2ks;

class ThrfL2or;

class ThrfL2wh;

class ThrfL2qr;

class ThrfL2os;

class ThrfGoel;

class ThrfGoss;

class ThrfPtel;

class ThrfTlel;

class ThrfTabl;

class ThrfStel;

class ThrfStth;

class ThrfAenp;

class ThrfTope;

class ThrfTop_;

class ThrfComm;

class ThrfCort;

class ThrfLqry;

class ThrfL2qb;

class ThrfSrvc;

class ThrfSrvr;

class ThrfBsrc;

class ThrfBsrr;

typedef struct _ThrfLmtb__isset {
  _ThrfLmtb__isset() : sVtable(false) {}
  bool sVtable :1;
} _ThrfLmtb__isset;

class ThrfLmtb {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  ThrfLmtb(const ThrfLmtb&);
  ThrfLmtb& operator=(const ThrfLmtb&);
  ThrfLmtb() : sVnamespace(), sVtable() {
  }

  virtual ~ThrfLmtb() throw();
  std::string sVnamespace;
  std::string sVtable;

  _ThrfLmtb__isset __isset;

  void __set_sVnamespace(const std::string& val);

  void __set_sVtable(const std::string& val);

  bool operator == (const ThrfLmtb & rhs) const
  {
    if (!(sVnamespace == rhs.sVnamespace))
      return false;
    if (!(sVtable == rhs.sVtable))
      return false;
    return true;
  }
  bool operator != (const ThrfLmtb &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfLmtb & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfLmtb& obj);
};

void swap(ThrfLmtb &a, ThrfLmtb &b);

typedef struct _ThrfLkey__isset {
  _ThrfLkey__isset() : sVaccessgroup(false), sVqualifier(false), iVstate(false), iVtimestamp(false) {}
  bool sVaccessgroup :1;
  bool sVqualifier :1;
  bool iVstate :1;
  bool iVtimestamp :1;
} _ThrfLkey__isset;

class ThrfLkey {
 public:

  static const char* ascii_fingerprint; // = "222AFB4990285E29234328916DC6F924";
  static const uint8_t binary_fingerprint[16]; // = {0x22,0x2A,0xFB,0x49,0x90,0x28,0x5E,0x29,0x23,0x43,0x28,0x91,0x6D,0xC6,0xF9,0x24};

  ThrfLkey(const ThrfLkey&);
  ThrfLkey& operator=(const ThrfLkey&);
  ThrfLkey() : sVmain(), sVaccessgroup(), sVqualifier(), iVstate((iEstatetype::type)0), iVtimestamp(0) {
  }

  virtual ~ThrfLkey() throw();
  std::string sVmain;
  std::string sVaccessgroup;
  std::string sVqualifier;
  iEstatetype::type iVstate;
  int64_t iVtimestamp;

  _ThrfLkey__isset __isset;

  void __set_sVmain(const std::string& val);

  void __set_sVaccessgroup(const std::string& val);

  void __set_sVqualifier(const std::string& val);

  void __set_iVstate(const iEstatetype::type val);

  void __set_iVtimestamp(const int64_t val);

  bool operator == (const ThrfLkey & rhs) const
  {
    if (!(sVmain == rhs.sVmain))
      return false;
    if (!(sVaccessgroup == rhs.sVaccessgroup))
      return false;
    if (!(sVqualifier == rhs.sVqualifier))
      return false;
    if (!(iVstate == rhs.iVstate))
      return false;
    if (!(iVtimestamp == rhs.iVtimestamp))
      return false;
    return true;
  }
  bool operator != (const ThrfLkey &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfLkey & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfLkey& obj);
};

void swap(ThrfLkey &a, ThrfLkey &b);

typedef struct _ThrfL2cv__isset {
  _ThrfL2cv__isset() : sVvalue(false), sVlistvalue(false), iVvalue(false), iVlistvalue(false), dVvalue(false), dVlistvalue(false), bVvalue(false) {}
  bool sVvalue :1;
  bool sVlistvalue :1;
  bool iVvalue :1;
  bool iVlistvalue :1;
  bool dVvalue :1;
  bool dVlistvalue :1;
  bool bVvalue :1;
} _ThrfL2cv__isset;

class ThrfL2cv {
 public:

  static const char* ascii_fingerprint; // = "EF17F9DF99D07B94B21A8D4343E55659";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0x17,0xF9,0xDF,0x99,0xD0,0x7B,0x94,0xB2,0x1A,0x8D,0x43,0x43,0xE5,0x56,0x59};

  ThrfL2cv(const ThrfL2cv&);
  ThrfL2cv& operator=(const ThrfL2cv&);
  ThrfL2cv() : iVtype((iEcolumntype::type)0), sVvalue(), iVvalue(0), dVvalue(0), bVvalue(0) {
  }

  virtual ~ThrfL2cv() throw();
  iEcolumntype::type iVtype;
  std::string sVvalue;
  std::vector<std::string>  sVlistvalue;
  int32_t iVvalue;
  std::vector<int32_t>  iVlistvalue;
  double dVvalue;
  std::vector<double>  dVlistvalue;
  bool bVvalue;

  _ThrfL2cv__isset __isset;

  void __set_iVtype(const iEcolumntype::type val);

  void __set_sVvalue(const std::string& val);

  void __set_sVlistvalue(const std::vector<std::string> & val);

  void __set_iVvalue(const int32_t val);

  void __set_iVlistvalue(const std::vector<int32_t> & val);

  void __set_dVvalue(const double val);

  void __set_dVlistvalue(const std::vector<double> & val);

  void __set_bVvalue(const bool val);

  bool operator == (const ThrfL2cv & rhs) const
  {
    if (!(iVtype == rhs.iVtype))
      return false;
    if (!(sVvalue == rhs.sVvalue))
      return false;
    if (!(sVlistvalue == rhs.sVlistvalue))
      return false;
    if (!(iVvalue == rhs.iVvalue))
      return false;
    if (!(iVlistvalue == rhs.iVlistvalue))
      return false;
    if (!(dVvalue == rhs.dVvalue))
      return false;
    if (!(dVlistvalue == rhs.dVlistvalue))
      return false;
    if (!(bVvalue == rhs.bVvalue))
      return false;
    return true;
  }
  bool operator != (const ThrfL2cv &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2cv & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2cv& obj);
};

void swap(ThrfL2cv &a, ThrfL2cv &b);

typedef struct _ThrfL2cl__isset {
  _ThrfL2cl__isset() : iVtype(false), cVvalue(false), iVconditiontype(false) {}
  bool iVtype :1;
  bool cVvalue :1;
  bool iVconditiontype :1;
} _ThrfL2cl__isset;

class ThrfL2cl {
 public:

  static const char* ascii_fingerprint; // = "5425A5B0A496E00FFDB490AC0B56ACC2";
  static const uint8_t binary_fingerprint[16]; // = {0x54,0x25,0xA5,0xB0,0xA4,0x96,0xE0,0x0F,0xFD,0xB4,0x90,0xAC,0x0B,0x56,0xAC,0xC2};

  ThrfL2cl(const ThrfL2cl&);
  ThrfL2cl& operator=(const ThrfL2cl&);
  ThrfL2cl() : sVcolumn(), iVtype((iEcolumntype::type)0), iVconditiontype((iEconditiontype::type)0) {
  }

  virtual ~ThrfL2cl() throw();
  std::string sVcolumn;
  iEcolumntype::type iVtype;
  ThrfL2cv cVvalue;
  iEconditiontype::type iVconditiontype;

  _ThrfL2cl__isset __isset;

  void __set_sVcolumn(const std::string& val);

  void __set_iVtype(const iEcolumntype::type val);

  void __set_cVvalue(const ThrfL2cv& val);

  void __set_iVconditiontype(const iEconditiontype::type val);

  bool operator == (const ThrfL2cl & rhs) const
  {
    if (!(sVcolumn == rhs.sVcolumn))
      return false;
    if (!(iVtype == rhs.iVtype))
      return false;
    if (!(cVvalue == rhs.cVvalue))
      return false;
    if (!(iVconditiontype == rhs.iVconditiontype))
      return false;
    return true;
  }
  bool operator != (const ThrfL2cl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2cl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2cl& obj);
};

void swap(ThrfL2cl &a, ThrfL2cl &b);


class ThrfLval {
 public:

  static const char* ascii_fingerprint; // = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

  ThrfLval(const ThrfLval&);
  ThrfLval& operator=(const ThrfLval&);
  ThrfLval() : sVopaquevalue(), iVtimestamp(0) {
  }

  virtual ~ThrfLval() throw();
  std::string sVopaquevalue;
  int64_t iVtimestamp;

  void __set_sVopaquevalue(const std::string& val);

  void __set_iVtimestamp(const int64_t val);

  bool operator == (const ThrfLval & rhs) const
  {
    if (!(sVopaquevalue == rhs.sVopaquevalue))
      return false;
    if (!(iVtimestamp == rhs.iVtimestamp))
      return false;
    return true;
  }
  bool operator != (const ThrfLval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfLval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfLval& obj);
};

void swap(ThrfLval &a, ThrfLval &b);


class ThrfL1ks {
 public:

  static const char* ascii_fingerprint; // = "CC4FFBE08543BFB22DD6DEF04A7E402F";
  static const uint8_t binary_fingerprint[16]; // = {0xCC,0x4F,0xFB,0xE0,0x85,0x43,0xBF,0xB2,0x2D,0xD6,0xDE,0xF0,0x4A,0x7E,0x40,0x2F};

  ThrfL1ks(const ThrfL1ks&);
  ThrfL1ks& operator=(const ThrfL1ks&);
  ThrfL1ks() : bVresult(0) {
  }

  virtual ~ThrfL1ks() throw();
  ThrfLkey cVkey;
  bool bVresult;
  ThrfLval cVvalue;

  void __set_cVkey(const ThrfLkey& val);

  void __set_bVresult(const bool val);

  void __set_cVvalue(const ThrfLval& val);

  bool operator == (const ThrfL1ks & rhs) const
  {
    if (!(cVkey == rhs.cVkey))
      return false;
    if (!(bVresult == rhs.bVresult))
      return false;
    if (!(cVvalue == rhs.cVvalue))
      return false;
    return true;
  }
  bool operator != (const ThrfL1ks &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL1ks & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL1ks& obj);
};

void swap(ThrfL1ks &a, ThrfL1ks &b);

typedef struct _ThrfLstm__isset {
  _ThrfLstm__isset() : iVopcode(true), sVcallback(false) {}
  bool iVopcode :1;
  bool sVcallback :1;
} _ThrfLstm__isset;

class ThrfLstm {
 public:

  static const char* ascii_fingerprint; // = "82696706F701A26A513FB455CAC6DDAA";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x69,0x67,0x06,0xF7,0x01,0xA2,0x6A,0x51,0x3F,0xB4,0x55,0xCA,0xC6,0xDD,0xAA};

  ThrfLstm(const ThrfLstm&);
  ThrfLstm& operator=(const ThrfLstm&);
  ThrfLstm() : iVopcode((iEopcodetype::type)0), sVcallback() {
    iVopcode = (iEopcodetype::type)0;

  }

  virtual ~ThrfLstm() throw();
  ThrfLmtb cVmutable;
  ThrfLkey cVkey;
  ThrfLval cVvalue;
  iEopcodetype::type iVopcode;
  std::string sVcallback;

  _ThrfLstm__isset __isset;

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_cVkey(const ThrfLkey& val);

  void __set_cVvalue(const ThrfLval& val);

  void __set_iVopcode(const iEopcodetype::type val);

  void __set_sVcallback(const std::string& val);

  bool operator == (const ThrfLstm & rhs) const
  {
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(cVkey == rhs.cVkey))
      return false;
    if (!(cVvalue == rhs.cVvalue))
      return false;
    if (!(iVopcode == rhs.iVopcode))
      return false;
    if (!(sVcallback == rhs.sVcallback))
      return false;
    return true;
  }
  bool operator != (const ThrfLstm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfLstm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfLstm& obj);
};

void swap(ThrfLstm &a, ThrfLstm &b);

typedef struct _ThrfL2st__isset {
  _ThrfL2st__isset() : cVcolumns(false), iVopcode(true) {}
  bool cVcolumns :1;
  bool iVopcode :1;
} _ThrfL2st__isset;

class ThrfL2st {
 public:

  static const char* ascii_fingerprint; // = "4798E44E2BCE0A6FF6287FCA51B26071";
  static const uint8_t binary_fingerprint[16]; // = {0x47,0x98,0xE4,0x4E,0x2B,0xCE,0x0A,0x6F,0xF6,0x28,0x7F,0xCA,0x51,0xB2,0x60,0x71};

  ThrfL2st(const ThrfL2st&);
  ThrfL2st& operator=(const ThrfL2st&);
  ThrfL2st() : iVopcode((iEopcodetype::type)0) {
    iVopcode = (iEopcodetype::type)0;

  }

  virtual ~ThrfL2st() throw();
  ThrfLmtb cVmutable;
  ThrfLkey cVkey;
  std::vector<ThrfL2cl>  cVcolumns;
  iEopcodetype::type iVopcode;

  _ThrfL2st__isset __isset;

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_cVkey(const ThrfLkey& val);

  void __set_cVcolumns(const std::vector<ThrfL2cl> & val);

  void __set_iVopcode(const iEopcodetype::type val);

  bool operator == (const ThrfL2st & rhs) const
  {
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(cVkey == rhs.cVkey))
      return false;
    if (!(cVcolumns == rhs.cVcolumns))
      return false;
    if (!(iVopcode == rhs.iVopcode))
      return false;
    return true;
  }
  bool operator != (const ThrfL2st &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2st & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2st& obj);
};

void swap(ThrfL2st &a, ThrfL2st &b);

typedef struct _ThrfL2ag__isset {
  _ThrfL2ag__isset() : sVcolumns(false) {}
  bool sVcolumns :1;
} _ThrfL2ag__isset;

class ThrfL2ag {
 public:

  static const char* ascii_fingerprint; // = "25702B8D5E28AA39160F267DABBC8446";
  static const uint8_t binary_fingerprint[16]; // = {0x25,0x70,0x2B,0x8D,0x5E,0x28,0xAA,0x39,0x16,0x0F,0x26,0x7D,0xAB,0xBC,0x84,0x46};

  ThrfL2ag(const ThrfL2ag&);
  ThrfL2ag& operator=(const ThrfL2ag&);
  ThrfL2ag() : sVname() {
  }

  virtual ~ThrfL2ag() throw();
  std::string sVname;
  std::vector<std::string>  sVcolumns;

  _ThrfL2ag__isset __isset;

  void __set_sVname(const std::string& val);

  void __set_sVcolumns(const std::vector<std::string> & val);

  bool operator == (const ThrfL2ag & rhs) const
  {
    if (!(sVname == rhs.sVname))
      return false;
    if (!(sVcolumns == rhs.sVcolumns))
      return false;
    return true;
  }
  bool operator != (const ThrfL2ag &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2ag & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2ag& obj);
};

void swap(ThrfL2ag &a, ThrfL2ag &b);

typedef struct _ThrfL2ct__isset {
  _ThrfL2ct__isset() : cVcolumns(false), cVaccessgroups(false) {}
  bool cVcolumns :1;
  bool cVaccessgroups :1;
} _ThrfL2ct__isset;

class ThrfL2ct {
 public:

  static const char* ascii_fingerprint; // = "283393C1EF3BAF2E520343AFF1DFA513";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0x33,0x93,0xC1,0xEF,0x3B,0xAF,0x2E,0x52,0x03,0x43,0xAF,0xF1,0xDF,0xA5,0x13};

  ThrfL2ct(const ThrfL2ct&);
  ThrfL2ct& operator=(const ThrfL2ct&);
  ThrfL2ct() {
  }

  virtual ~ThrfL2ct() throw();
  ThrfLmtb cVmutable;
  std::vector<ThrfL2cl>  cVcolumns;
  std::vector<ThrfL2ag>  cVaccessgroups;

  _ThrfL2ct__isset __isset;

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_cVcolumns(const std::vector<ThrfL2cl> & val);

  void __set_cVaccessgroups(const std::vector<ThrfL2ag> & val);

  bool operator == (const ThrfL2ct & rhs) const
  {
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(cVcolumns == rhs.cVcolumns))
      return false;
    if (!(cVaccessgroups == rhs.cVaccessgroups))
      return false;
    return true;
  }
  bool operator != (const ThrfL2ct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2ct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2ct& obj);
};

void swap(ThrfL2ct &a, ThrfL2ct &b);

typedef struct _ThrfL2ks__isset {
  _ThrfL2ks__isset() : cVcolumns(false) {}
  bool cVcolumns :1;
} _ThrfL2ks__isset;

class ThrfL2ks {
 public:

  static const char* ascii_fingerprint; // = "E7E176AF8D5B43BBB1C59E3A993EF742";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0xE1,0x76,0xAF,0x8D,0x5B,0x43,0xBB,0xB1,0xC5,0x9E,0x3A,0x99,0x3E,0xF7,0x42};

  ThrfL2ks(const ThrfL2ks&);
  ThrfL2ks& operator=(const ThrfL2ks&);
  ThrfL2ks() {
  }

  virtual ~ThrfL2ks() throw();
  ThrfLkey cVkey;
  std::vector<ThrfL2cl>  cVcolumns;

  _ThrfL2ks__isset __isset;

  void __set_cVkey(const ThrfLkey& val);

  void __set_cVcolumns(const std::vector<ThrfL2cl> & val);

  bool operator == (const ThrfL2ks & rhs) const
  {
    if (!(cVkey == rhs.cVkey))
      return false;
    if (!(cVcolumns == rhs.cVcolumns))
      return false;
    return true;
  }
  bool operator != (const ThrfL2ks &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2ks & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2ks& obj);
};

void swap(ThrfL2ks &a, ThrfL2ks &b);


class ThrfL2or {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  ThrfL2or(const ThrfL2or&);
  ThrfL2or& operator=(const ThrfL2or&);
  ThrfL2or() : sVcolumn(), iVordertype((iEordertype::type)0) {
  }

  virtual ~ThrfL2or() throw();
  std::string sVcolumn;
  iEordertype::type iVordertype;

  void __set_sVcolumn(const std::string& val);

  void __set_iVordertype(const iEordertype::type val);

  bool operator == (const ThrfL2or & rhs) const
  {
    if (!(sVcolumn == rhs.sVcolumn))
      return false;
    if (!(iVordertype == rhs.iVordertype))
      return false;
    return true;
  }
  bool operator != (const ThrfL2or &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2or & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2or& obj);
};

void swap(ThrfL2or &a, ThrfL2or &b);

typedef struct _ThrfL2wh__isset {
  _ThrfL2wh__isset() : cVcondition(false), cVorderby(false) {}
  bool cVcondition :1;
  bool cVorderby :1;
} _ThrfL2wh__isset;

class ThrfL2wh {
 public:

  static const char* ascii_fingerprint; // = "B406C81429592FB475424F013CCD6826";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0x06,0xC8,0x14,0x29,0x59,0x2F,0xB4,0x75,0x42,0x4F,0x01,0x3C,0xCD,0x68,0x26};

  ThrfL2wh(const ThrfL2wh&);
  ThrfL2wh& operator=(const ThrfL2wh&);
  ThrfL2wh() {
  }

  virtual ~ThrfL2wh() throw();
  std::vector<ThrfL2cl>  cVcondition;
  std::vector<ThrfL2or>  cVorderby;

  _ThrfL2wh__isset __isset;

  void __set_cVcondition(const std::vector<ThrfL2cl> & val);

  void __set_cVorderby(const std::vector<ThrfL2or> & val);

  bool operator == (const ThrfL2wh & rhs) const
  {
    if (!(cVcondition == rhs.cVcondition))
      return false;
    if (!(cVorderby == rhs.cVorderby))
      return false;
    return true;
  }
  bool operator != (const ThrfL2wh &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2wh & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2wh& obj);
};

void swap(ThrfL2wh &a, ThrfL2wh &b);

typedef struct _ThrfL2qr__isset {
  _ThrfL2qr__isset() : cVselect(false), iVquery(false), cVkey_start(false), cVkey_end(false), cVwhere(false), iVcount(true) {}
  bool cVselect :1;
  bool iVquery :1;
  bool cVkey_start :1;
  bool cVkey_end :1;
  bool cVwhere :1;
  bool iVcount :1;
} _ThrfL2qr__isset;

class ThrfL2qr {
 public:

  static const char* ascii_fingerprint; // = "A702846D85FB1FED210EBF9443B5BA24";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x02,0x84,0x6D,0x85,0xFB,0x1F,0xED,0x21,0x0E,0xBF,0x94,0x43,0xB5,0xBA,0x24};

  ThrfL2qr(const ThrfL2qr&);
  ThrfL2qr& operator=(const ThrfL2qr&);
  ThrfL2qr() : iVquery((iEquerytype::type)0), iVcount(100), bVonlysecondary(false), bVdisableteleport(false) {
  }

  virtual ~ThrfL2qr() throw();
  std::vector<ThrfL2cl>  cVselect;
  ThrfLmtb cVmutable;
  iEquerytype::type iVquery;
  ThrfLkey cVkey_start;
  ThrfLkey cVkey_end;
  ThrfL2wh cVwhere;
  int32_t iVcount;
  bool bVonlysecondary;
  bool bVdisableteleport;

  _ThrfL2qr__isset __isset;

  void __set_cVselect(const std::vector<ThrfL2cl> & val);

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_iVquery(const iEquerytype::type val);

  void __set_cVkey_start(const ThrfLkey& val);

  void __set_cVkey_end(const ThrfLkey& val);

  void __set_cVwhere(const ThrfL2wh& val);

  void __set_iVcount(const int32_t val);

  void __set_bVonlysecondary(const bool val);

  void __set_bVdisableteleport(const bool val);

  bool operator == (const ThrfL2qr & rhs) const
  {
    if (!(cVselect == rhs.cVselect))
      return false;
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(iVquery == rhs.iVquery))
      return false;
    if (!(cVkey_start == rhs.cVkey_start))
      return false;
    if (!(cVkey_end == rhs.cVkey_end))
      return false;
    if (!(cVwhere == rhs.cVwhere))
      return false;
    if (!(iVcount == rhs.iVcount))
      return false;
    if (!(bVonlysecondary == rhs.bVonlysecondary))
      return false;
    if (!(bVdisableteleport == rhs.bVdisableteleport))
      return false;
    return true;
  }
  bool operator != (const ThrfL2qr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2qr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2qr& obj);
};

void swap(ThrfL2qr &a, ThrfL2qr &b);

typedef struct _ThrfL2os__isset {
  _ThrfL2os__isset() : cVinputbindings(false), bVdisableteleport(true), iVtimestamp(false), bVfulltablescan(true) {}
  bool cVinputbindings :1;
  bool bVdisableteleport :1;
  bool iVtimestamp :1;
  bool bVfulltablescan :1;
} _ThrfL2os__isset;

class ThrfL2os {
 public:

  static const char* ascii_fingerprint; // = "8D1CEF95AAC64B94AE3750CCF0573671";
  static const uint8_t binary_fingerprint[16]; // = {0x8D,0x1C,0xEF,0x95,0xAA,0xC6,0x4B,0x94,0xAE,0x37,0x50,0xCC,0xF0,0x57,0x36,0x71};

  ThrfL2os(const ThrfL2os&);
  ThrfL2os& operator=(const ThrfL2os&);
  ThrfL2os() : sVnamespace(), sVosqlstring(), bVonlysecondary(false), bVdisableteleport(false), iVtimestamp(0), bVfulltablescan(false) {
  }

  virtual ~ThrfL2os() throw();
  std::string sVnamespace;
  std::string sVosqlstring;
  std::vector<ThrfL2cv>  cVinputbindings;
  bool bVonlysecondary;
  bool bVdisableteleport;
  int64_t iVtimestamp;
  bool bVfulltablescan;

  _ThrfL2os__isset __isset;

  void __set_sVnamespace(const std::string& val);

  void __set_sVosqlstring(const std::string& val);

  void __set_cVinputbindings(const std::vector<ThrfL2cv> & val);

  void __set_bVonlysecondary(const bool val);

  void __set_bVdisableteleport(const bool val);

  void __set_iVtimestamp(const int64_t val);

  void __set_bVfulltablescan(const bool val);

  bool operator == (const ThrfL2os & rhs) const
  {
    if (!(sVnamespace == rhs.sVnamespace))
      return false;
    if (!(sVosqlstring == rhs.sVosqlstring))
      return false;
    if (!(cVinputbindings == rhs.cVinputbindings))
      return false;
    if (!(bVonlysecondary == rhs.bVonlysecondary))
      return false;
    if (!(bVdisableteleport == rhs.bVdisableteleport))
      return false;
    if (!(iVtimestamp == rhs.iVtimestamp))
      return false;
    if (!(bVfulltablescan == rhs.bVfulltablescan))
      return false;
    return true;
  }
  bool operator != (const ThrfL2os &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2os & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2os& obj);
};

void swap(ThrfL2os &a, ThrfL2os &b);

typedef struct _ThrfGoel__isset {
  _ThrfGoel__isset() : sVaddress(false), iVport(false), iVstate(false), iVtimestamp(false), iVsize(false) {}
  bool sVaddress :1;
  bool iVport :1;
  bool iVstate :1;
  bool iVtimestamp :1;
  bool iVsize :1;
} _ThrfGoel__isset;

class ThrfGoel {
 public:

  static const char* ascii_fingerprint; // = "66664E4F8B1E171B59A9581CAD735933";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0x66,0x4E,0x4F,0x8B,0x1E,0x17,0x1B,0x59,0xA9,0x58,0x1C,0xAD,0x73,0x59,0x33};

  ThrfGoel(const ThrfGoel&);
  ThrfGoel& operator=(const ThrfGoel&);
  ThrfGoel() : sVtoken(), sVnodeid(), dVphiaccrual(0), sVaddress(), iVport(0), sVdatacenterid(), iVstate((iEstategossipnode::type)0), iVtimestamp(0), iVsize(0) {
  }

  virtual ~ThrfGoel() throw();
  std::string sVtoken;
  std::string sVnodeid;
  double dVphiaccrual;
  std::string sVaddress;
  int32_t iVport;
  std::string sVdatacenterid;
  iEstategossipnode::type iVstate;
  int64_t iVtimestamp;
  int64_t iVsize;

  _ThrfGoel__isset __isset;

  void __set_sVtoken(const std::string& val);

  void __set_sVnodeid(const std::string& val);

  void __set_dVphiaccrual(const double val);

  void __set_sVaddress(const std::string& val);

  void __set_iVport(const int32_t val);

  void __set_sVdatacenterid(const std::string& val);

  void __set_iVstate(const iEstategossipnode::type val);

  void __set_iVtimestamp(const int64_t val);

  void __set_iVsize(const int64_t val);

  bool operator == (const ThrfGoel & rhs) const
  {
    if (!(sVtoken == rhs.sVtoken))
      return false;
    if (!(sVnodeid == rhs.sVnodeid))
      return false;
    if (!(dVphiaccrual == rhs.dVphiaccrual))
      return false;
    if (!(sVaddress == rhs.sVaddress))
      return false;
    if (!(iVport == rhs.iVport))
      return false;
    if (!(sVdatacenterid == rhs.sVdatacenterid))
      return false;
    if (!(iVstate == rhs.iVstate))
      return false;
    if (!(iVtimestamp == rhs.iVtimestamp))
      return false;
    if (!(iVsize == rhs.iVsize))
      return false;
    return true;
  }
  bool operator != (const ThrfGoel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfGoel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfGoel& obj);
};

void swap(ThrfGoel &a, ThrfGoel &b);

typedef struct _ThrfGoss__isset {
  _ThrfGoss__isset() : cVgossipelement(false) {}
  bool cVgossipelement :1;
} _ThrfGoss__isset;

class ThrfGoss {
 public:

  static const char* ascii_fingerprint; // = "24C4AFFE4AFF374F788CD9DB3DC2A4BA";
  static const uint8_t binary_fingerprint[16]; // = {0x24,0xC4,0xAF,0xFE,0x4A,0xFF,0x37,0x4F,0x78,0x8C,0xD9,0xDB,0x3D,0xC2,0xA4,0xBA};

  ThrfGoss(const ThrfGoss&);
  ThrfGoss& operator=(const ThrfGoss&);
  ThrfGoss() {
  }

  virtual ~ThrfGoss() throw();
  std::vector<ThrfGoel>  cVgossipelement;

  _ThrfGoss__isset __isset;

  void __set_cVgossipelement(const std::vector<ThrfGoel> & val);

  bool operator == (const ThrfGoss & rhs) const
  {
    if (!(cVgossipelement == rhs.cVgossipelement))
      return false;
    return true;
  }
  bool operator != (const ThrfGoss &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfGoss & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfGoss& obj);
};

void swap(ThrfGoss &a, ThrfGoss &b);


class ThrfPtel {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  ThrfPtel(const ThrfPtel&);
  ThrfPtel& operator=(const ThrfPtel&);
  ThrfPtel() : sVnodeid(), sVbound() {
  }

  virtual ~ThrfPtel() throw();
  std::string sVnodeid;
  std::string sVbound;

  void __set_sVnodeid(const std::string& val);

  void __set_sVbound(const std::string& val);

  bool operator == (const ThrfPtel & rhs) const
  {
    if (!(sVnodeid == rhs.sVnodeid))
      return false;
    if (!(sVbound == rhs.sVbound))
      return false;
    return true;
  }
  bool operator != (const ThrfPtel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfPtel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfPtel& obj);
};

void swap(ThrfPtel &a, ThrfPtel &b);


class ThrfTlel {
 public:

  static const char* ascii_fingerprint; // = "BF6A4B72A74CB252F65E60BCB570DEC5";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x6A,0x4B,0x72,0xA7,0x4C,0xB2,0x52,0xF6,0x5E,0x60,0xBC,0xB5,0x70,0xDE,0xC5};

  ThrfTlel(const ThrfTlel&);
  ThrfTlel& operator=(const ThrfTlel&);
  ThrfTlel() : iVtablettype((iEtablettype::type)0), sVname(), bVvalid(0), bVneedcompaction(0), bVvalidasmemorytable(0), iVcompactionlevel(0), sVmemorytable(), iVres(0), iVmapped(0), iVsize(0), iVcount(0), sVredotimestamp(), iVsstabletype(0) {
  }

  virtual ~ThrfTlel() throw();
  iEtablettype::type iVtablettype;
  std::string sVname;
  bool bVvalid;
  bool bVneedcompaction;
  bool bVvalidasmemorytable;
  int32_t iVcompactionlevel;
  std::string sVmemorytable;
  int64_t iVres;
  int64_t iVmapped;
  int64_t iVsize;
  int64_t iVcount;
  std::string sVredotimestamp;
  int32_t iVsstabletype;

  void __set_iVtablettype(const iEtablettype::type val);

  void __set_sVname(const std::string& val);

  void __set_bVvalid(const bool val);

  void __set_bVneedcompaction(const bool val);

  void __set_bVvalidasmemorytable(const bool val);

  void __set_iVcompactionlevel(const int32_t val);

  void __set_sVmemorytable(const std::string& val);

  void __set_iVres(const int64_t val);

  void __set_iVmapped(const int64_t val);

  void __set_iVsize(const int64_t val);

  void __set_iVcount(const int64_t val);

  void __set_sVredotimestamp(const std::string& val);

  void __set_iVsstabletype(const int32_t val);

  bool operator == (const ThrfTlel & rhs) const
  {
    if (!(iVtablettype == rhs.iVtablettype))
      return false;
    if (!(sVname == rhs.sVname))
      return false;
    if (!(bVvalid == rhs.bVvalid))
      return false;
    if (!(bVneedcompaction == rhs.bVneedcompaction))
      return false;
    if (!(bVvalidasmemorytable == rhs.bVvalidasmemorytable))
      return false;
    if (!(iVcompactionlevel == rhs.iVcompactionlevel))
      return false;
    if (!(sVmemorytable == rhs.sVmemorytable))
      return false;
    if (!(iVres == rhs.iVres))
      return false;
    if (!(iVmapped == rhs.iVmapped))
      return false;
    if (!(iVsize == rhs.iVsize))
      return false;
    if (!(iVcount == rhs.iVcount))
      return false;
    if (!(sVredotimestamp == rhs.sVredotimestamp))
      return false;
    if (!(iVsstabletype == rhs.iVsstabletype))
      return false;
    return true;
  }
  bool operator != (const ThrfTlel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfTlel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfTlel& obj);
};

void swap(ThrfTlel &a, ThrfTlel &b);

typedef struct _ThrfTabl__isset {
  _ThrfTabl__isset() : cVpartitionedelements(false), cVpartitionedindexelements(false), cVtabletelement(false), cVindextabletelement(false), sVjoincustompartition(false), sVjoincustompartitionindex(false), sVpartitiontype(false) {}
  bool cVpartitionedelements :1;
  bool cVpartitionedindexelements :1;
  bool cVtabletelement :1;
  bool cVindextabletelement :1;
  bool sVjoincustompartition :1;
  bool sVjoincustompartitionindex :1;
  bool sVpartitiontype :1;
} _ThrfTabl__isset;

class ThrfTabl {
 public:

  static const char* ascii_fingerprint; // = "F47AA2A9521E41A35AA914A39F3CDF3C";
  static const uint8_t binary_fingerprint[16]; // = {0xF4,0x7A,0xA2,0xA9,0x52,0x1E,0x41,0xA3,0x5A,0xA9,0x14,0xA3,0x9F,0x3C,0xDF,0x3C};

  ThrfTabl(const ThrfTabl&);
  ThrfTabl& operator=(const ThrfTabl&);
  ThrfTabl() : sVxml(), sVjoincustompartition(), sVjoincustompartitionindex(), sVpartitiontype() {
  }

  virtual ~ThrfTabl() throw();
  std::string sVxml;
  std::vector<ThrfPtel>  cVpartitionedelements;
  std::vector<ThrfPtel>  cVpartitionedindexelements;
  std::vector<ThrfTlel>  cVtabletelement;
  std::vector<ThrfTlel>  cVindextabletelement;
  std::string sVjoincustompartition;
  std::string sVjoincustompartitionindex;
  std::string sVpartitiontype;

  _ThrfTabl__isset __isset;

  void __set_sVxml(const std::string& val);

  void __set_cVpartitionedelements(const std::vector<ThrfPtel> & val);

  void __set_cVpartitionedindexelements(const std::vector<ThrfPtel> & val);

  void __set_cVtabletelement(const std::vector<ThrfTlel> & val);

  void __set_cVindextabletelement(const std::vector<ThrfTlel> & val);

  void __set_sVjoincustompartition(const std::string& val);

  void __set_sVjoincustompartitionindex(const std::string& val);

  void __set_sVpartitiontype(const std::string& val);

  bool operator == (const ThrfTabl & rhs) const
  {
    if (!(sVxml == rhs.sVxml))
      return false;
    if (!(cVpartitionedelements == rhs.cVpartitionedelements))
      return false;
    if (!(cVpartitionedindexelements == rhs.cVpartitionedindexelements))
      return false;
    if (!(cVtabletelement == rhs.cVtabletelement))
      return false;
    if (!(cVindextabletelement == rhs.cVindextabletelement))
      return false;
    if (!(sVjoincustompartition == rhs.sVjoincustompartition))
      return false;
    if (!(sVjoincustompartitionindex == rhs.sVjoincustompartitionindex))
      return false;
    if (!(sVpartitiontype == rhs.sVpartitiontype))
      return false;
    return true;
  }
  bool operator != (const ThrfTabl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfTabl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfTabl& obj);
};

void swap(ThrfTabl &a, ThrfTabl &b);

typedef struct _ThrfStel__isset {
  _ThrfStel__isset() : iVelapsed(false) {}
  bool iVelapsed :1;
} _ThrfStel__isset;

class ThrfStel {
 public:

  static const char* ascii_fingerprint; // = "AEE2FAF8C83F8A2810461026C139743F";
  static const uint8_t binary_fingerprint[16]; // = {0xAE,0xE2,0xFA,0xF8,0xC8,0x3F,0x8A,0x28,0x10,0x46,0x10,0x26,0xC1,0x39,0x74,0x3F};

  ThrfStel(const ThrfStel&);
  ThrfStel& operator=(const ThrfStel&);
  ThrfStel() : iVcount(0), iVmeandelay(0), iVworstdelay(0), iVsize(0), iVelapsed(0) {
  }

  virtual ~ThrfStel() throw();
  int64_t iVcount;
  int32_t iVmeandelay;
  int32_t iVworstdelay;
  int64_t iVsize;
  int64_t iVelapsed;

  _ThrfStel__isset __isset;

  void __set_iVcount(const int64_t val);

  void __set_iVmeandelay(const int32_t val);

  void __set_iVworstdelay(const int32_t val);

  void __set_iVsize(const int64_t val);

  void __set_iVelapsed(const int64_t val);

  bool operator == (const ThrfStel & rhs) const
  {
    if (!(iVcount == rhs.iVcount))
      return false;
    if (!(iVmeandelay == rhs.iVmeandelay))
      return false;
    if (!(iVworstdelay == rhs.iVworstdelay))
      return false;
    if (!(iVsize == rhs.iVsize))
      return false;
    if (!(iVelapsed == rhs.iVelapsed))
      return false;
    return true;
  }
  bool operator != (const ThrfStel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfStel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfStel& obj);
};

void swap(ThrfStel &a, ThrfStel &b);


class ThrfStth {
 public:

  static const char* ascii_fingerprint; // = "2EB010665070FC89CB24AB9DA34D5F9D";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0xB0,0x10,0x66,0x50,0x70,0xFC,0x89,0xCB,0x24,0xAB,0x9D,0xA3,0x4D,0x5F,0x9D};

  ThrfStth(const ThrfStth&);
  ThrfStth& operator=(const ThrfStth&);
  ThrfStth() : iVprocessors(0), iVconnections(0), iVidleconnections(0), iVmaxprocessors(0), iVmaxconnections(0) {
  }

  virtual ~ThrfStth() throw();
  int32_t iVprocessors;
  int32_t iVconnections;
  int32_t iVidleconnections;
  int32_t iVmaxprocessors;
  int32_t iVmaxconnections;

  void __set_iVprocessors(const int32_t val);

  void __set_iVconnections(const int32_t val);

  void __set_iVidleconnections(const int32_t val);

  void __set_iVmaxprocessors(const int32_t val);

  void __set_iVmaxconnections(const int32_t val);

  bool operator == (const ThrfStth & rhs) const
  {
    if (!(iVprocessors == rhs.iVprocessors))
      return false;
    if (!(iVconnections == rhs.iVconnections))
      return false;
    if (!(iVidleconnections == rhs.iVidleconnections))
      return false;
    if (!(iVmaxprocessors == rhs.iVmaxprocessors))
      return false;
    if (!(iVmaxconnections == rhs.iVmaxconnections))
      return false;
    return true;
  }
  bool operator != (const ThrfStth &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfStth & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfStth& obj);
};

void swap(ThrfStth &a, ThrfStth &b);

typedef struct _ThrfAenp__isset {
  _ThrfAenp__isset() : sVnodeid(false), cVmutable(false), sVkeystart(false), iVlimitsize(false) {}
  bool sVnodeid :1;
  bool cVmutable :1;
  bool sVkeystart :1;
  bool iVlimitsize :1;
} _ThrfAenp__isset;

class ThrfAenp {
 public:

  static const char* ascii_fingerprint; // = "A26670596CD156B37A412F54D08BBA99";
  static const uint8_t binary_fingerprint[16]; // = {0xA2,0x66,0x70,0x59,0x6C,0xD1,0x56,0xB3,0x7A,0x41,0x2F,0x54,0xD0,0x8B,0xBA,0x99};

  ThrfAenp(const ThrfAenp&);
  ThrfAenp& operator=(const ThrfAenp&);
  ThrfAenp() : sVopaquedata(), sVnodeid(), sVkeystart(), iVlimitsize(0) {
  }

  virtual ~ThrfAenp() throw();
  std::string sVopaquedata;
  std::string sVnodeid;
  ThrfLmtb cVmutable;
  std::string sVkeystart;
  int32_t iVlimitsize;

  _ThrfAenp__isset __isset;

  void __set_sVopaquedata(const std::string& val);

  void __set_sVnodeid(const std::string& val);

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_sVkeystart(const std::string& val);

  void __set_iVlimitsize(const int32_t val);

  bool operator == (const ThrfAenp & rhs) const
  {
    if (!(sVopaquedata == rhs.sVopaquedata))
      return false;
    if (!(sVnodeid == rhs.sVnodeid))
      return false;
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(sVkeystart == rhs.sVkeystart))
      return false;
    if (!(iVlimitsize == rhs.iVlimitsize))
      return false;
    return true;
  }
  bool operator != (const ThrfAenp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfAenp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfAenp& obj);
};

void swap(ThrfAenp &a, ThrfAenp &b);


class ThrfTope {
 public:

  static const char* ascii_fingerprint; // = "C81882A778978FEBDADBD08BCE2CD236";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x18,0x82,0xA7,0x78,0x97,0x8F,0xEB,0xDA,0xDB,0xD0,0x8B,0xCE,0x2C,0xD2,0x36};

  ThrfTope(const ThrfTope&);
  ThrfTope& operator=(const ThrfTope&);
  ThrfTope() : sVtablet(), iVreadtime(0), iVwritetime(0), iVreadcountl2(0), iVwritecountl2(0), iVreadcountl1(0), iVwritecountl1(0) {
  }

  virtual ~ThrfTope() throw();
  std::string sVtablet;
  int64_t iVreadtime;
  int64_t iVwritetime;
  int64_t iVreadcountl2;
  int64_t iVwritecountl2;
  int64_t iVreadcountl1;
  int64_t iVwritecountl1;

  void __set_sVtablet(const std::string& val);

  void __set_iVreadtime(const int64_t val);

  void __set_iVwritetime(const int64_t val);

  void __set_iVreadcountl2(const int64_t val);

  void __set_iVwritecountl2(const int64_t val);

  void __set_iVreadcountl1(const int64_t val);

  void __set_iVwritecountl1(const int64_t val);

  bool operator == (const ThrfTope & rhs) const
  {
    if (!(sVtablet == rhs.sVtablet))
      return false;
    if (!(iVreadtime == rhs.iVreadtime))
      return false;
    if (!(iVwritetime == rhs.iVwritetime))
      return false;
    if (!(iVreadcountl2 == rhs.iVreadcountl2))
      return false;
    if (!(iVwritecountl2 == rhs.iVwritecountl2))
      return false;
    if (!(iVreadcountl1 == rhs.iVreadcountl1))
      return false;
    if (!(iVwritecountl1 == rhs.iVwritecountl1))
      return false;
    return true;
  }
  bool operator != (const ThrfTope &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfTope & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfTope& obj);
};

void swap(ThrfTope &a, ThrfTope &b);

typedef struct _ThrfTop___isset {
  _ThrfTop___isset() : cVtopelement(false) {}
  bool cVtopelement :1;
} _ThrfTop___isset;

class ThrfTop_ {
 public:

  static const char* ascii_fingerprint; // = "487841EA677A54A50A3C256DC57687AA";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x78,0x41,0xEA,0x67,0x7A,0x54,0xA5,0x0A,0x3C,0x25,0x6D,0xC5,0x76,0x87,0xAA};

  ThrfTop_(const ThrfTop_&);
  ThrfTop_& operator=(const ThrfTop_&);
  ThrfTop_() : iVtimestamp(0) {
  }

  virtual ~ThrfTop_() throw();
  int64_t iVtimestamp;
  std::vector<ThrfTope>  cVtopelement;

  _ThrfTop___isset __isset;

  void __set_iVtimestamp(const int64_t val);

  void __set_cVtopelement(const std::vector<ThrfTope> & val);

  bool operator == (const ThrfTop_ & rhs) const
  {
    if (!(iVtimestamp == rhs.iVtimestamp))
      return false;
    if (!(cVtopelement == rhs.cVtopelement))
      return false;
    return true;
  }
  bool operator != (const ThrfTop_ &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfTop_ & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfTop_& obj);
};

void swap(ThrfTop_ &a, ThrfTop_ &b);

typedef struct _ThrfComm__isset {
  _ThrfComm__isset() : iVcommand(false), iVsubcommand(false), sVreturnmessage(false), sVaddress(false), iVport(false), sVtablet(false), cVmutable(false), cVantientrophy(false), sVnodeid(false), sVnewtoken(true), cVmutabledestination(false), iVtimestamp(false) {}
  bool iVcommand :1;
  bool iVsubcommand :1;
  bool sVreturnmessage :1;
  bool sVaddress :1;
  bool iVport :1;
  bool sVtablet :1;
  bool cVmutable :1;
  bool cVantientrophy :1;
  bool sVnodeid :1;
  bool sVnewtoken :1;
  bool cVmutabledestination :1;
  bool iVtimestamp :1;
} _ThrfComm__isset;

class ThrfComm {
 public:

  static const char* ascii_fingerprint; // = "E4BD9A2ABEDE2D0D79C3DE2A16D0CF68";
  static const uint8_t binary_fingerprint[16]; // = {0xE4,0xBD,0x9A,0x2A,0xBE,0xDE,0x2D,0x0D,0x79,0xC3,0xDE,0x2A,0x16,0xD0,0xCF,0x68};

  ThrfComm(const ThrfComm&);
  ThrfComm& operator=(const ThrfComm&);
  ThrfComm() : iVcommand((iEreservedkeyword::type)0), iVsubcommand((iEreservedkeyword::type)0), sVreturnmessage(), sVaddress(), iVport(0), sVtablet(), sVnodeid(), sVnewtoken(""), iVtimestamp(0) {
  }

  virtual ~ThrfComm() throw();
  iEreservedkeyword::type iVcommand;
  iEreservedkeyword::type iVsubcommand;
  std::string sVreturnmessage;
  std::string sVaddress;
  int32_t iVport;
  std::string sVtablet;
  ThrfLmtb cVmutable;
  ThrfAenp cVantientrophy;
  std::string sVnodeid;
  std::string sVnewtoken;
  ThrfLmtb cVmutabledestination;
  int64_t iVtimestamp;

  _ThrfComm__isset __isset;

  void __set_iVcommand(const iEreservedkeyword::type val);

  void __set_iVsubcommand(const iEreservedkeyword::type val);

  void __set_sVreturnmessage(const std::string& val);

  void __set_sVaddress(const std::string& val);

  void __set_iVport(const int32_t val);

  void __set_sVtablet(const std::string& val);

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_cVantientrophy(const ThrfAenp& val);

  void __set_sVnodeid(const std::string& val);

  void __set_sVnewtoken(const std::string& val);

  void __set_cVmutabledestination(const ThrfLmtb& val);

  void __set_iVtimestamp(const int64_t val);

  bool operator == (const ThrfComm & rhs) const
  {
    if (!(iVcommand == rhs.iVcommand))
      return false;
    if (!(iVsubcommand == rhs.iVsubcommand))
      return false;
    if (!(sVreturnmessage == rhs.sVreturnmessage))
      return false;
    if (!(sVaddress == rhs.sVaddress))
      return false;
    if (!(iVport == rhs.iVport))
      return false;
    if (!(sVtablet == rhs.sVtablet))
      return false;
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(cVantientrophy == rhs.cVantientrophy))
      return false;
    if (!(sVnodeid == rhs.sVnodeid))
      return false;
    if (!(sVnewtoken == rhs.sVnewtoken))
      return false;
    if (!(cVmutabledestination == rhs.cVmutabledestination))
      return false;
    if (!(iVtimestamp == rhs.iVtimestamp))
      return false;
    return true;
  }
  bool operator != (const ThrfComm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfComm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfComm& obj);
};

void swap(ThrfComm &a, ThrfComm &b);

typedef struct _ThrfCort__isset {
  _ThrfCort__isset() : bVreturn(false), sVreturnmessage(false), cVreturntable(false), cVreturnstats(false), cVreturnthriftstats(false), cVreturnantientrophy(false), cVreturntop(false), iVreturn(false) {}
  bool bVreturn :1;
  bool sVreturnmessage :1;
  bool cVreturntable :1;
  bool cVreturnstats :1;
  bool cVreturnthriftstats :1;
  bool cVreturnantientrophy :1;
  bool cVreturntop :1;
  bool iVreturn :1;
} _ThrfCort__isset;

class ThrfCort {
 public:

  static const char* ascii_fingerprint; // = "13B1E7FD17AF53534595A702E759F57A";
  static const uint8_t binary_fingerprint[16]; // = {0x13,0xB1,0xE7,0xFD,0x17,0xAF,0x53,0x53,0x45,0x95,0xA7,0x02,0xE7,0x59,0xF5,0x7A};

  ThrfCort(const ThrfCort&);
  ThrfCort& operator=(const ThrfCort&);
  ThrfCort() : bVreturn(0), sVreturnmessage(), iVreturn(0) {
  }

  virtual ~ThrfCort() throw();
  bool bVreturn;
  std::string sVreturnmessage;
  ThrfTabl cVreturntable;
  ThrfStel cVreturnstats;
  ThrfStth cVreturnthriftstats;
  ThrfAenp cVreturnantientrophy;
  ThrfTop_ cVreturntop;
  int64_t iVreturn;

  _ThrfCort__isset __isset;

  void __set_bVreturn(const bool val);

  void __set_sVreturnmessage(const std::string& val);

  void __set_cVreturntable(const ThrfTabl& val);

  void __set_cVreturnstats(const ThrfStel& val);

  void __set_cVreturnthriftstats(const ThrfStth& val);

  void __set_cVreturnantientrophy(const ThrfAenp& val);

  void __set_cVreturntop(const ThrfTop_& val);

  void __set_iVreturn(const int64_t val);

  bool operator == (const ThrfCort & rhs) const
  {
    if (!(bVreturn == rhs.bVreturn))
      return false;
    if (!(sVreturnmessage == rhs.sVreturnmessage))
      return false;
    if (!(cVreturntable == rhs.cVreturntable))
      return false;
    if (!(cVreturnstats == rhs.cVreturnstats))
      return false;
    if (!(cVreturnthriftstats == rhs.cVreturnthriftstats))
      return false;
    if (!(cVreturnantientrophy == rhs.cVreturnantientrophy))
      return false;
    if (!(cVreturntop == rhs.cVreturntop))
      return false;
    if (!(iVreturn == rhs.iVreturn))
      return false;
    return true;
  }
  bool operator != (const ThrfCort &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfCort & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfCort& obj);
};

void swap(ThrfCort &a, ThrfCort &b);

typedef struct _ThrfLqry__isset {
  _ThrfLqry__isset() : sVcallback(false) {}
  bool sVcallback :1;
} _ThrfLqry__isset;

class ThrfLqry {
 public:

  static const char* ascii_fingerprint; // = "DEF294DA011CE3842D0C4F2FA5E82F3B";
  static const uint8_t binary_fingerprint[16]; // = {0xDE,0xF2,0x94,0xDA,0x01,0x1C,0xE3,0x84,0x2D,0x0C,0x4F,0x2F,0xA5,0xE8,0x2F,0x3B};

  ThrfLqry(const ThrfLqry&);
  ThrfLqry& operator=(const ThrfLqry&);
  ThrfLqry() : iVquery((iEquerytype::type)0), bVdigest(false), sVcallback() {
  }

  virtual ~ThrfLqry() throw();
  iEquerytype::type iVquery;
  ThrfLmtb cVmutable;
  ThrfLkey cVkey;
  bool bVdigest;
  std::string sVcallback;

  _ThrfLqry__isset __isset;

  void __set_iVquery(const iEquerytype::type val);

  void __set_cVmutable(const ThrfLmtb& val);

  void __set_cVkey(const ThrfLkey& val);

  void __set_bVdigest(const bool val);

  void __set_sVcallback(const std::string& val);

  bool operator == (const ThrfLqry & rhs) const
  {
    if (!(iVquery == rhs.iVquery))
      return false;
    if (!(cVmutable == rhs.cVmutable))
      return false;
    if (!(cVkey == rhs.cVkey))
      return false;
    if (!(bVdigest == rhs.bVdigest))
      return false;
    if (!(sVcallback == rhs.sVcallback))
      return false;
    return true;
  }
  bool operator != (const ThrfLqry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfLqry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfLqry& obj);
};

void swap(ThrfLqry &a, ThrfLqry &b);

typedef struct _ThrfL2qb__isset {
  _ThrfL2qb__isset() : cKeyslices(false), bVreturn(false) {}
  bool cKeyslices :1;
  bool bVreturn :1;
} _ThrfL2qb__isset;

class ThrfL2qb {
 public:

  static const char* ascii_fingerprint; // = "BF84E14BCC27A0E775184D2D701A03A2";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x84,0xE1,0x4B,0xCC,0x27,0xA0,0xE7,0x75,0x18,0x4D,0x2D,0x70,0x1A,0x03,0xA2};

  ThrfL2qb(const ThrfL2qb&);
  ThrfL2qb& operator=(const ThrfL2qb&);
  ThrfL2qb() : bVreturn(0) {
  }

  virtual ~ThrfL2qb() throw();
  std::vector<ThrfL2ks>  cKeyslices;
  bool bVreturn;

  _ThrfL2qb__isset __isset;

  void __set_cKeyslices(const std::vector<ThrfL2ks> & val);

  void __set_bVreturn(const bool val);

  bool operator == (const ThrfL2qb & rhs) const
  {
    if (!(cKeyslices == rhs.cKeyslices))
      return false;
    if (!(bVreturn == rhs.bVreturn))
      return false;
    return true;
  }
  bool operator != (const ThrfL2qb &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfL2qb & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfL2qb& obj);
};

void swap(ThrfL2qb &a, ThrfL2qb &b);

typedef struct _ThrfSrvc__isset {
  _ThrfSrvc__isset() : cVquery(false), cVstatement(false), cVosql(false) {}
  bool cVquery :1;
  bool cVstatement :1;
  bool cVosql :1;
} _ThrfSrvc__isset;

class ThrfSrvc {
 public:

  static const char* ascii_fingerprint; // = "81046A41E2B5AFA05FBD807B65C2B276";
  static const uint8_t binary_fingerprint[16]; // = {0x81,0x04,0x6A,0x41,0xE2,0xB5,0xAF,0xA0,0x5F,0xBD,0x80,0x7B,0x65,0xC2,0xB2,0x76};

  ThrfSrvc(const ThrfSrvc&);
  ThrfSrvc& operator=(const ThrfSrvc&);
  ThrfSrvc() : iVservicetype((iEservicetype::type)0) {
  }

  virtual ~ThrfSrvc() throw();
  iEservicetype::type iVservicetype;
  ThrfL2qr cVquery;
  ThrfL2st cVstatement;
  ThrfL2os cVosql;

  _ThrfSrvc__isset __isset;

  void __set_iVservicetype(const iEservicetype::type val);

  void __set_cVquery(const ThrfL2qr& val);

  void __set_cVstatement(const ThrfL2st& val);

  void __set_cVosql(const ThrfL2os& val);

  bool operator == (const ThrfSrvc & rhs) const
  {
    if (!(iVservicetype == rhs.iVservicetype))
      return false;
    if (!(cVquery == rhs.cVquery))
      return false;
    if (!(cVstatement == rhs.cVstatement))
      return false;
    if (!(cVosql == rhs.cVosql))
      return false;
    return true;
  }
  bool operator != (const ThrfSrvc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfSrvc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfSrvc& obj);
};

void swap(ThrfSrvc &a, ThrfSrvc &b);

typedef struct _ThrfSrvr__isset {
  _ThrfSrvr__isset() : bVreturn(false), cVdmlresult(false), cVqueryresult(false) {}
  bool bVreturn :1;
  bool cVdmlresult :1;
  bool cVqueryresult :1;
} _ThrfSrvr__isset;

class ThrfSrvr {
 public:

  static const char* ascii_fingerprint; // = "E0D4D756AE3B93412174E6B2BC9B6509";
  static const uint8_t binary_fingerprint[16]; // = {0xE0,0xD4,0xD7,0x56,0xAE,0x3B,0x93,0x41,0x21,0x74,0xE6,0xB2,0xBC,0x9B,0x65,0x09};

  ThrfSrvr(const ThrfSrvr&);
  ThrfSrvr& operator=(const ThrfSrvr&);
  ThrfSrvr() : bVreturn(0) {
  }

  virtual ~ThrfSrvr() throw();
  bool bVreturn;
  std::vector<ThrfL2ks>  cVdmlresult;
  ThrfL2qb cVqueryresult;

  _ThrfSrvr__isset __isset;

  void __set_bVreturn(const bool val);

  void __set_cVdmlresult(const std::vector<ThrfL2ks> & val);

  void __set_cVqueryresult(const ThrfL2qb& val);

  bool operator == (const ThrfSrvr & rhs) const
  {
    if (!(bVreturn == rhs.bVreturn))
      return false;
    if (!(cVdmlresult == rhs.cVdmlresult))
      return false;
    if (!(cVqueryresult == rhs.cVqueryresult))
      return false;
    return true;
  }
  bool operator != (const ThrfSrvr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfSrvr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfSrvr& obj);
};

void swap(ThrfSrvr &a, ThrfSrvr &b);

typedef struct _ThrfBsrc__isset {
  _ThrfBsrc__isset() : cVbulkthrift(false), cVbulkstring(false), cVsinglethrift(false) {}
  bool cVbulkthrift :1;
  bool cVbulkstring :1;
  bool cVsinglethrift :1;
} _ThrfBsrc__isset;

class ThrfBsrc {
 public:

  static const char* ascii_fingerprint; // = "69C64A87683EB9F7241D3F9A6402EC8E";
  static const uint8_t binary_fingerprint[16]; // = {0x69,0xC6,0x4A,0x87,0x68,0x3E,0xB9,0xF7,0x24,0x1D,0x3F,0x9A,0x64,0x02,0xEC,0x8E};

  ThrfBsrc(const ThrfBsrc&);
  ThrfBsrc& operator=(const ThrfBsrc&);
  ThrfBsrc() : iVbulkservicetype((iEbulkservicetype::type)0) {
  }

  virtual ~ThrfBsrc() throw();
  iEbulkservicetype::type iVbulkservicetype;
  std::vector<ThrfSrvc>  cVbulkthrift;
  std::vector<std::string>  cVbulkstring;
  ThrfSrvc cVsinglethrift;

  _ThrfBsrc__isset __isset;

  void __set_iVbulkservicetype(const iEbulkservicetype::type val);

  void __set_cVbulkthrift(const std::vector<ThrfSrvc> & val);

  void __set_cVbulkstring(const std::vector<std::string> & val);

  void __set_cVsinglethrift(const ThrfSrvc& val);

  bool operator == (const ThrfBsrc & rhs) const
  {
    if (!(iVbulkservicetype == rhs.iVbulkservicetype))
      return false;
    if (!(cVbulkthrift == rhs.cVbulkthrift))
      return false;
    if (!(cVbulkstring == rhs.cVbulkstring))
      return false;
    if (!(cVsinglethrift == rhs.cVsinglethrift))
      return false;
    return true;
  }
  bool operator != (const ThrfBsrc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfBsrc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfBsrc& obj);
};

void swap(ThrfBsrc &a, ThrfBsrc &b);

typedef struct _ThrfBsrr__isset {
  _ThrfBsrr__isset() : cVbulkthrift(false), cVbulkstring(false), cVsinglethrift(false) {}
  bool cVbulkthrift :1;
  bool cVbulkstring :1;
  bool cVsinglethrift :1;
} _ThrfBsrr__isset;

class ThrfBsrr {
 public:

  static const char* ascii_fingerprint; // = "5E68E748C3F239797E8C78FBF8771628";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0x68,0xE7,0x48,0xC3,0xF2,0x39,0x79,0x7E,0x8C,0x78,0xFB,0xF8,0x77,0x16,0x28};

  ThrfBsrr(const ThrfBsrr&);
  ThrfBsrr& operator=(const ThrfBsrr&);
  ThrfBsrr() {
  }

  virtual ~ThrfBsrr() throw();
  std::vector<ThrfSrvr>  cVbulkthrift;
  std::vector<std::string>  cVbulkstring;
  ThrfSrvr cVsinglethrift;

  _ThrfBsrr__isset __isset;

  void __set_cVbulkthrift(const std::vector<ThrfSrvr> & val);

  void __set_cVbulkstring(const std::vector<std::string> & val);

  void __set_cVsinglethrift(const ThrfSrvr& val);

  bool operator == (const ThrfBsrr & rhs) const
  {
    if (!(cVbulkthrift == rhs.cVbulkthrift))
      return false;
    if (!(cVbulkstring == rhs.cVbulkstring))
      return false;
    if (!(cVsinglethrift == rhs.cVsinglethrift))
      return false;
    return true;
  }
  bool operator != (const ThrfBsrr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThrfBsrr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ThrfBsrr& obj);
};

void swap(ThrfBsrr &a, ThrfBsrr &b);



#endif
