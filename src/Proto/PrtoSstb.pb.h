// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PrtoSstb.proto

#ifndef PROTOBUF_PrtoSstb_2eproto__INCLUDED
#define PROTOBUF_PrtoSstb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace tomting {
namespace orion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PrtoSstb_2eproto();
void protobuf_AssignDesc_PrtoSstb_2eproto();
void protobuf_ShutdownFile_PrtoSstb_2eproto();

class PrtoStix;
class PrtoHash;
class PrtoIndx;
class PrtoIatm;
class PrtoData;

enum iCsstabletype {
  SSTABLE = 0,
  MEMORYSSTABLE = 1,
  PARTIALMEMTABLE = 2
};
bool iCsstabletype_IsValid(int value);
const iCsstabletype iCsstabletype_MIN = SSTABLE;
const iCsstabletype iCsstabletype_MAX = PARTIALMEMTABLE;
const int iCsstabletype_ARRAYSIZE = iCsstabletype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCsstabletype_descriptor();
inline const ::std::string& iCsstabletype_Name(iCsstabletype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCsstabletype_descriptor(), value);
}
inline bool iCsstabletype_Parse(
    const ::std::string& name, iCsstabletype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCsstabletype>(
    iCsstabletype_descriptor(), name, value);
}
// ===================================================================

class PrtoStix : public ::google::protobuf::Message {
 public:
  PrtoStix();
  virtual ~PrtoStix();

  PrtoStix(const PrtoStix& from);

  inline PrtoStix& operator=(const PrtoStix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoStix& default_instance();

  void Swap(PrtoStix* other);

  // implements Message ----------------------------------------------

  PrtoStix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoStix& from);
  void MergeFrom(const PrtoStix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVindex = 1;
  inline bool has_svindex() const;
  inline void clear_svindex();
  static const int kSVindexFieldNumber = 1;
  inline const ::std::string& svindex() const;
  inline void set_svindex(const ::std::string& value);
  inline void set_svindex(const char* value);
  inline void set_svindex(const void* value, size_t size);
  inline ::std::string* mutable_svindex();
  inline ::std::string* release_svindex();
  inline void set_allocated_svindex(::std::string* svindex);

  // required uint32 iVindexed32 = 2;
  inline bool has_ivindexed32() const;
  inline void clear_ivindexed32();
  static const int kIVindexed32FieldNumber = 2;
  inline ::google::protobuf::uint32 ivindexed32() const;
  inline void set_ivindexed32(::google::protobuf::uint32 value);

  // optional uint32 iVmainindexlength = 3;
  inline bool has_ivmainindexlength() const;
  inline void clear_ivmainindexlength();
  static const int kIVmainindexlengthFieldNumber = 3;
  inline ::google::protobuf::uint32 ivmainindexlength() const;
  inline void set_ivmainindexlength(::google::protobuf::uint32 value);

  // optional uint64 iVindexed64 = 4;
  inline bool has_ivindexed64() const;
  inline void clear_ivindexed64();
  static const int kIVindexed64FieldNumber = 4;
  inline ::google::protobuf::uint64 ivindexed64() const;
  inline void set_ivindexed64(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoStix)
 private:
  inline void set_has_svindex();
  inline void clear_has_svindex();
  inline void set_has_ivindexed32();
  inline void clear_has_ivindexed32();
  inline void set_has_ivmainindexlength();
  inline void clear_has_ivmainindexlength();
  inline void set_has_ivindexed64();
  inline void clear_has_ivindexed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svindex_;
  ::google::protobuf::uint32 ivindexed32_;
  ::google::protobuf::uint32 ivmainindexlength_;
  ::google::protobuf::uint64 ivindexed64_;
  friend void  protobuf_AddDesc_PrtoSstb_2eproto();
  friend void protobuf_AssignDesc_PrtoSstb_2eproto();
  friend void protobuf_ShutdownFile_PrtoSstb_2eproto();

  void InitAsDefaultInstance();
  static PrtoStix* default_instance_;
};
// -------------------------------------------------------------------

class PrtoHash : public ::google::protobuf::Message {
 public:
  PrtoHash();
  virtual ~PrtoHash();

  PrtoHash(const PrtoHash& from);

  inline PrtoHash& operator=(const PrtoHash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoHash& default_instance();

  void Swap(PrtoHash* other);

  // implements Message ----------------------------------------------

  PrtoHash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoHash& from);
  void MergeFrom(const PrtoHash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iVindex = 1;
  inline bool has_ivindex() const;
  inline void clear_ivindex();
  static const int kIVindexFieldNumber = 1;
  inline ::google::protobuf::int32 ivindex() const;
  inline void set_ivindex(::google::protobuf::int32 value);

  // required uint32 iVhash = 2;
  inline bool has_ivhash() const;
  inline void clear_ivhash();
  static const int kIVhashFieldNumber = 2;
  inline ::google::protobuf::uint32 ivhash() const;
  inline void set_ivhash(::google::protobuf::uint32 value);

  // required int32 iVsortedradix = 3;
  inline bool has_ivsortedradix() const;
  inline void clear_ivsortedradix();
  static const int kIVsortedradixFieldNumber = 3;
  inline ::google::protobuf::int32 ivsortedradix() const;
  inline void set_ivsortedradix(::google::protobuf::int32 value);

  // required int32 iVchained = 4;
  inline bool has_ivchained() const;
  inline void clear_ivchained();
  static const int kIVchainedFieldNumber = 4;
  inline ::google::protobuf::int32 ivchained() const;
  inline void set_ivchained(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoHash)
 private:
  inline void set_has_ivindex();
  inline void clear_has_ivindex();
  inline void set_has_ivhash();
  inline void clear_has_ivhash();
  inline void set_has_ivsortedradix();
  inline void clear_has_ivsortedradix();
  inline void set_has_ivchained();
  inline void clear_has_ivchained();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ivindex_;
  ::google::protobuf::uint32 ivhash_;
  ::google::protobuf::int32 ivsortedradix_;
  ::google::protobuf::int32 ivchained_;
  friend void  protobuf_AddDesc_PrtoSstb_2eproto();
  friend void protobuf_AssignDesc_PrtoSstb_2eproto();
  friend void protobuf_ShutdownFile_PrtoSstb_2eproto();

  void InitAsDefaultInstance();
  static PrtoHash* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIndx : public ::google::protobuf::Message {
 public:
  PrtoIndx();
  virtual ~PrtoIndx();

  PrtoIndx(const PrtoIndx& from);

  inline PrtoIndx& operator=(const PrtoIndx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIndx& default_instance();

  void Swap(PrtoIndx* other);

  // implements Message ----------------------------------------------

  PrtoIndx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIndx& from);
  void MergeFrom(const PrtoIndx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoStix cVstix = 1;
  inline int cvstix_size() const;
  inline void clear_cvstix();
  static const int kCVstixFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoStix& cvstix(int index) const;
  inline ::com::tomting::orion::PrtoStix* mutable_cvstix(int index);
  inline ::com::tomting::orion::PrtoStix* add_cvstix();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >&
      cvstix() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >*
      mutable_cvstix();

  // repeated .com.tomting.orion.PrtoHash cVhash = 2;
  inline int cvhash_size() const;
  inline void clear_cvhash();
  static const int kCVhashFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoHash& cvhash(int index) const;
  inline ::com::tomting::orion::PrtoHash* mutable_cvhash(int index);
  inline ::com::tomting::orion::PrtoHash* add_cvhash();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >&
      cvhash() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >*
      mutable_cvhash();

  // optional uint32 iVhashtablesize = 3;
  inline bool has_ivhashtablesize() const;
  inline void clear_ivhashtablesize();
  static const int kIVhashtablesizeFieldNumber = 3;
  inline ::google::protobuf::uint32 ivhashtablesize() const;
  inline void set_ivhashtablesize(::google::protobuf::uint32 value);

  // optional uint32 iVhashtablerealsize = 4;
  inline bool has_ivhashtablerealsize() const;
  inline void clear_ivhashtablerealsize();
  static const int kIVhashtablerealsizeFieldNumber = 4;
  inline ::google::protobuf::uint32 ivhashtablerealsize() const;
  inline void set_ivhashtablerealsize(::google::protobuf::uint32 value);

  // required .com.tomting.orion.iCsstabletype iVsstabletype = 5;
  inline bool has_ivsstabletype() const;
  inline void clear_ivsstabletype();
  static const int kIVsstabletypeFieldNumber = 5;
  inline ::com::tomting::orion::iCsstabletype ivsstabletype() const;
  inline void set_ivsstabletype(::com::tomting::orion::iCsstabletype value);

  // required bytes sVredotimestamp = 6;
  inline bool has_svredotimestamp() const;
  inline void clear_svredotimestamp();
  static const int kSVredotimestampFieldNumber = 6;
  inline const ::std::string& svredotimestamp() const;
  inline void set_svredotimestamp(const ::std::string& value);
  inline void set_svredotimestamp(const char* value);
  inline void set_svredotimestamp(const void* value, size_t size);
  inline ::std::string* mutable_svredotimestamp();
  inline ::std::string* release_svredotimestamp();
  inline void set_allocated_svredotimestamp(::std::string* svredotimestamp);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIndx)
 private:
  inline void set_has_ivhashtablesize();
  inline void clear_has_ivhashtablesize();
  inline void set_has_ivhashtablerealsize();
  inline void clear_has_ivhashtablerealsize();
  inline void set_has_ivsstabletype();
  inline void clear_has_ivsstabletype();
  inline void set_has_svredotimestamp();
  inline void clear_has_svredotimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix > cvstix_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash > cvhash_;
  ::google::protobuf::uint32 ivhashtablesize_;
  ::google::protobuf::uint32 ivhashtablerealsize_;
  ::std::string* svredotimestamp_;
  int ivsstabletype_;
  friend void  protobuf_AddDesc_PrtoSstb_2eproto();
  friend void protobuf_AssignDesc_PrtoSstb_2eproto();
  friend void protobuf_ShutdownFile_PrtoSstb_2eproto();

  void InitAsDefaultInstance();
  static PrtoIndx* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIatm : public ::google::protobuf::Message {
 public:
  PrtoIatm();
  virtual ~PrtoIatm();

  PrtoIatm(const PrtoIatm& from);

  inline PrtoIatm& operator=(const PrtoIatm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIatm& default_instance();

  void Swap(PrtoIatm* other);

  // implements Message ----------------------------------------------

  PrtoIatm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIatm& from);
  void MergeFrom(const PrtoIatm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoStix cVstix = 1;
  inline int cvstix_size() const;
  inline void clear_cvstix();
  static const int kCVstixFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoStix& cvstix(int index) const;
  inline ::com::tomting::orion::PrtoStix* mutable_cvstix(int index);
  inline ::com::tomting::orion::PrtoStix* add_cvstix();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >&
      cvstix() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >*
      mutable_cvstix();

  // repeated .com.tomting.orion.PrtoHash cVhash = 2;
  inline int cvhash_size() const;
  inline void clear_cvhash();
  static const int kCVhashFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoHash& cvhash(int index) const;
  inline ::com::tomting::orion::PrtoHash* mutable_cvhash(int index);
  inline ::com::tomting::orion::PrtoHash* add_cvhash();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >&
      cvhash() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >*
      mutable_cvhash();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIatm)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix > cvstix_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash > cvhash_;
  friend void  protobuf_AddDesc_PrtoSstb_2eproto();
  friend void protobuf_AssignDesc_PrtoSstb_2eproto();
  friend void protobuf_ShutdownFile_PrtoSstb_2eproto();

  void InitAsDefaultInstance();
  static PrtoIatm* default_instance_;
};
// -------------------------------------------------------------------

class PrtoData : public ::google::protobuf::Message {
 public:
  PrtoData();
  virtual ~PrtoData();

  PrtoData(const PrtoData& from);

  inline PrtoData& operator=(const PrtoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoData& default_instance();

  void Swap(PrtoData* other);

  // implements Message ----------------------------------------------

  PrtoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoData& from);
  void MergeFrom(const PrtoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVkey = 1;
  inline bool has_svkey() const;
  inline void clear_svkey();
  static const int kSVkeyFieldNumber = 1;
  inline const ::std::string& svkey() const;
  inline void set_svkey(const ::std::string& value);
  inline void set_svkey(const char* value);
  inline void set_svkey(const void* value, size_t size);
  inline ::std::string* mutable_svkey();
  inline ::std::string* release_svkey();
  inline void set_allocated_svkey(::std::string* svkey);

  // required uint32 iVmainkeylength = 2;
  inline bool has_ivmainkeylength() const;
  inline void clear_ivmainkeylength();
  static const int kIVmainkeylengthFieldNumber = 2;
  inline ::google::protobuf::uint32 ivmainkeylength() const;
  inline void set_ivmainkeylength(::google::protobuf::uint32 value);

  // required bytes sVopaquevalue = 3;
  inline bool has_svopaquevalue() const;
  inline void clear_svopaquevalue();
  static const int kSVopaquevalueFieldNumber = 3;
  inline const ::std::string& svopaquevalue() const;
  inline void set_svopaquevalue(const ::std::string& value);
  inline void set_svopaquevalue(const char* value);
  inline void set_svopaquevalue(const void* value, size_t size);
  inline ::std::string* mutable_svopaquevalue();
  inline ::std::string* release_svopaquevalue();
  inline void set_allocated_svopaquevalue(::std::string* svopaquevalue);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoData)
 private:
  inline void set_has_svkey();
  inline void clear_has_svkey();
  inline void set_has_ivmainkeylength();
  inline void clear_has_ivmainkeylength();
  inline void set_has_svopaquevalue();
  inline void clear_has_svopaquevalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svkey_;
  ::std::string* svopaquevalue_;
  ::google::protobuf::uint32 ivmainkeylength_;
  friend void  protobuf_AddDesc_PrtoSstb_2eproto();
  friend void protobuf_AssignDesc_PrtoSstb_2eproto();
  friend void protobuf_ShutdownFile_PrtoSstb_2eproto();

  void InitAsDefaultInstance();
  static PrtoData* default_instance_;
};
// ===================================================================


// ===================================================================

// PrtoStix

// required bytes sVindex = 1;
inline bool PrtoStix::has_svindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoStix::set_has_svindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoStix::clear_has_svindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoStix::clear_svindex() {
  if (svindex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_->clear();
  }
  clear_has_svindex();
}
inline const ::std::string& PrtoStix::svindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStix.sVindex)
  return *svindex_;
}
inline void PrtoStix::set_svindex(const ::std::string& value) {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  svindex_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStix.sVindex)
}
inline void PrtoStix::set_svindex(const char* value) {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  svindex_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoStix.sVindex)
}
inline void PrtoStix::set_svindex(const void* value, size_t size) {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  svindex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoStix.sVindex)
}
inline ::std::string* PrtoStix::mutable_svindex() {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoStix.sVindex)
  return svindex_;
}
inline ::std::string* PrtoStix::release_svindex() {
  clear_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svindex_;
    svindex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoStix::set_allocated_svindex(::std::string* svindex) {
  if (svindex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svindex_;
  }
  if (svindex) {
    set_has_svindex();
    svindex_ = svindex;
  } else {
    clear_has_svindex();
    svindex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoStix.sVindex)
}

// required uint32 iVindexed32 = 2;
inline bool PrtoStix::has_ivindexed32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoStix::set_has_ivindexed32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoStix::clear_has_ivindexed32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoStix::clear_ivindexed32() {
  ivindexed32_ = 0u;
  clear_has_ivindexed32();
}
inline ::google::protobuf::uint32 PrtoStix::ivindexed32() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStix.iVindexed32)
  return ivindexed32_;
}
inline void PrtoStix::set_ivindexed32(::google::protobuf::uint32 value) {
  set_has_ivindexed32();
  ivindexed32_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStix.iVindexed32)
}

// optional uint32 iVmainindexlength = 3;
inline bool PrtoStix::has_ivmainindexlength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoStix::set_has_ivmainindexlength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoStix::clear_has_ivmainindexlength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoStix::clear_ivmainindexlength() {
  ivmainindexlength_ = 0u;
  clear_has_ivmainindexlength();
}
inline ::google::protobuf::uint32 PrtoStix::ivmainindexlength() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStix.iVmainindexlength)
  return ivmainindexlength_;
}
inline void PrtoStix::set_ivmainindexlength(::google::protobuf::uint32 value) {
  set_has_ivmainindexlength();
  ivmainindexlength_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStix.iVmainindexlength)
}

// optional uint64 iVindexed64 = 4;
inline bool PrtoStix::has_ivindexed64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoStix::set_has_ivindexed64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoStix::clear_has_ivindexed64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoStix::clear_ivindexed64() {
  ivindexed64_ = GOOGLE_ULONGLONG(0);
  clear_has_ivindexed64();
}
inline ::google::protobuf::uint64 PrtoStix::ivindexed64() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStix.iVindexed64)
  return ivindexed64_;
}
inline void PrtoStix::set_ivindexed64(::google::protobuf::uint64 value) {
  set_has_ivindexed64();
  ivindexed64_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStix.iVindexed64)
}

// -------------------------------------------------------------------

// PrtoHash

// required int32 iVindex = 1;
inline bool PrtoHash::has_ivindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoHash::set_has_ivindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoHash::clear_has_ivindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoHash::clear_ivindex() {
  ivindex_ = 0;
  clear_has_ivindex();
}
inline ::google::protobuf::int32 PrtoHash::ivindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoHash.iVindex)
  return ivindex_;
}
inline void PrtoHash::set_ivindex(::google::protobuf::int32 value) {
  set_has_ivindex();
  ivindex_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoHash.iVindex)
}

// required uint32 iVhash = 2;
inline bool PrtoHash::has_ivhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoHash::set_has_ivhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoHash::clear_has_ivhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoHash::clear_ivhash() {
  ivhash_ = 0u;
  clear_has_ivhash();
}
inline ::google::protobuf::uint32 PrtoHash::ivhash() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoHash.iVhash)
  return ivhash_;
}
inline void PrtoHash::set_ivhash(::google::protobuf::uint32 value) {
  set_has_ivhash();
  ivhash_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoHash.iVhash)
}

// required int32 iVsortedradix = 3;
inline bool PrtoHash::has_ivsortedradix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoHash::set_has_ivsortedradix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoHash::clear_has_ivsortedradix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoHash::clear_ivsortedradix() {
  ivsortedradix_ = 0;
  clear_has_ivsortedradix();
}
inline ::google::protobuf::int32 PrtoHash::ivsortedradix() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoHash.iVsortedradix)
  return ivsortedradix_;
}
inline void PrtoHash::set_ivsortedradix(::google::protobuf::int32 value) {
  set_has_ivsortedradix();
  ivsortedradix_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoHash.iVsortedradix)
}

// required int32 iVchained = 4;
inline bool PrtoHash::has_ivchained() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoHash::set_has_ivchained() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoHash::clear_has_ivchained() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoHash::clear_ivchained() {
  ivchained_ = 0;
  clear_has_ivchained();
}
inline ::google::protobuf::int32 PrtoHash::ivchained() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoHash.iVchained)
  return ivchained_;
}
inline void PrtoHash::set_ivchained(::google::protobuf::int32 value) {
  set_has_ivchained();
  ivchained_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoHash.iVchained)
}

// -------------------------------------------------------------------

// PrtoIndx

// repeated .com.tomting.orion.PrtoStix cVstix = 1;
inline int PrtoIndx::cvstix_size() const {
  return cvstix_.size();
}
inline void PrtoIndx::clear_cvstix() {
  cvstix_.Clear();
}
inline const ::com::tomting::orion::PrtoStix& PrtoIndx::cvstix(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIndx.cVstix)
  return cvstix_.Get(index);
}
inline ::com::tomting::orion::PrtoStix* PrtoIndx::mutable_cvstix(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIndx.cVstix)
  return cvstix_.Mutable(index);
}
inline ::com::tomting::orion::PrtoStix* PrtoIndx::add_cvstix() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoIndx.cVstix)
  return cvstix_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >&
PrtoIndx::cvstix() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoIndx.cVstix)
  return cvstix_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >*
PrtoIndx::mutable_cvstix() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoIndx.cVstix)
  return &cvstix_;
}

// repeated .com.tomting.orion.PrtoHash cVhash = 2;
inline int PrtoIndx::cvhash_size() const {
  return cvhash_.size();
}
inline void PrtoIndx::clear_cvhash() {
  cvhash_.Clear();
}
inline const ::com::tomting::orion::PrtoHash& PrtoIndx::cvhash(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIndx.cVhash)
  return cvhash_.Get(index);
}
inline ::com::tomting::orion::PrtoHash* PrtoIndx::mutable_cvhash(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIndx.cVhash)
  return cvhash_.Mutable(index);
}
inline ::com::tomting::orion::PrtoHash* PrtoIndx::add_cvhash() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoIndx.cVhash)
  return cvhash_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >&
PrtoIndx::cvhash() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoIndx.cVhash)
  return cvhash_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >*
PrtoIndx::mutable_cvhash() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoIndx.cVhash)
  return &cvhash_;
}

// optional uint32 iVhashtablesize = 3;
inline bool PrtoIndx::has_ivhashtablesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoIndx::set_has_ivhashtablesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoIndx::clear_has_ivhashtablesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoIndx::clear_ivhashtablesize() {
  ivhashtablesize_ = 0u;
  clear_has_ivhashtablesize();
}
inline ::google::protobuf::uint32 PrtoIndx::ivhashtablesize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIndx.iVhashtablesize)
  return ivhashtablesize_;
}
inline void PrtoIndx::set_ivhashtablesize(::google::protobuf::uint32 value) {
  set_has_ivhashtablesize();
  ivhashtablesize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIndx.iVhashtablesize)
}

// optional uint32 iVhashtablerealsize = 4;
inline bool PrtoIndx::has_ivhashtablerealsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoIndx::set_has_ivhashtablerealsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoIndx::clear_has_ivhashtablerealsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoIndx::clear_ivhashtablerealsize() {
  ivhashtablerealsize_ = 0u;
  clear_has_ivhashtablerealsize();
}
inline ::google::protobuf::uint32 PrtoIndx::ivhashtablerealsize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIndx.iVhashtablerealsize)
  return ivhashtablerealsize_;
}
inline void PrtoIndx::set_ivhashtablerealsize(::google::protobuf::uint32 value) {
  set_has_ivhashtablerealsize();
  ivhashtablerealsize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIndx.iVhashtablerealsize)
}

// required .com.tomting.orion.iCsstabletype iVsstabletype = 5;
inline bool PrtoIndx::has_ivsstabletype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoIndx::set_has_ivsstabletype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoIndx::clear_has_ivsstabletype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoIndx::clear_ivsstabletype() {
  ivsstabletype_ = 0;
  clear_has_ivsstabletype();
}
inline ::com::tomting::orion::iCsstabletype PrtoIndx::ivsstabletype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIndx.iVsstabletype)
  return static_cast< ::com::tomting::orion::iCsstabletype >(ivsstabletype_);
}
inline void PrtoIndx::set_ivsstabletype(::com::tomting::orion::iCsstabletype value) {
  assert(::com::tomting::orion::iCsstabletype_IsValid(value));
  set_has_ivsstabletype();
  ivsstabletype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIndx.iVsstabletype)
}

// required bytes sVredotimestamp = 6;
inline bool PrtoIndx::has_svredotimestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoIndx::set_has_svredotimestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoIndx::clear_has_svredotimestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoIndx::clear_svredotimestamp() {
  if (svredotimestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_->clear();
  }
  clear_has_svredotimestamp();
}
inline const ::std::string& PrtoIndx::svredotimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIndx.sVredotimestamp)
  return *svredotimestamp_;
}
inline void PrtoIndx::set_svredotimestamp(const ::std::string& value) {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  svredotimestamp_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIndx.sVredotimestamp)
}
inline void PrtoIndx::set_svredotimestamp(const char* value) {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  svredotimestamp_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIndx.sVredotimestamp)
}
inline void PrtoIndx::set_svredotimestamp(const void* value, size_t size) {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  svredotimestamp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIndx.sVredotimestamp)
}
inline ::std::string* PrtoIndx::mutable_svredotimestamp() {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIndx.sVredotimestamp)
  return svredotimestamp_;
}
inline ::std::string* PrtoIndx::release_svredotimestamp() {
  clear_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svredotimestamp_;
    svredotimestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIndx::set_allocated_svredotimestamp(::std::string* svredotimestamp) {
  if (svredotimestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svredotimestamp_;
  }
  if (svredotimestamp) {
    set_has_svredotimestamp();
    svredotimestamp_ = svredotimestamp;
  } else {
    clear_has_svredotimestamp();
    svredotimestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIndx.sVredotimestamp)
}

// -------------------------------------------------------------------

// PrtoIatm

// repeated .com.tomting.orion.PrtoStix cVstix = 1;
inline int PrtoIatm::cvstix_size() const {
  return cvstix_.size();
}
inline void PrtoIatm::clear_cvstix() {
  cvstix_.Clear();
}
inline const ::com::tomting::orion::PrtoStix& PrtoIatm::cvstix(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIatm.cVstix)
  return cvstix_.Get(index);
}
inline ::com::tomting::orion::PrtoStix* PrtoIatm::mutable_cvstix(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIatm.cVstix)
  return cvstix_.Mutable(index);
}
inline ::com::tomting::orion::PrtoStix* PrtoIatm::add_cvstix() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoIatm.cVstix)
  return cvstix_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >&
PrtoIatm::cvstix() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoIatm.cVstix)
  return cvstix_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoStix >*
PrtoIatm::mutable_cvstix() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoIatm.cVstix)
  return &cvstix_;
}

// repeated .com.tomting.orion.PrtoHash cVhash = 2;
inline int PrtoIatm::cvhash_size() const {
  return cvhash_.size();
}
inline void PrtoIatm::clear_cvhash() {
  cvhash_.Clear();
}
inline const ::com::tomting::orion::PrtoHash& PrtoIatm::cvhash(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIatm.cVhash)
  return cvhash_.Get(index);
}
inline ::com::tomting::orion::PrtoHash* PrtoIatm::mutable_cvhash(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIatm.cVhash)
  return cvhash_.Mutable(index);
}
inline ::com::tomting::orion::PrtoHash* PrtoIatm::add_cvhash() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoIatm.cVhash)
  return cvhash_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >&
PrtoIatm::cvhash() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoIatm.cVhash)
  return cvhash_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoHash >*
PrtoIatm::mutable_cvhash() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoIatm.cVhash)
  return &cvhash_;
}

// -------------------------------------------------------------------

// PrtoData

// required bytes sVkey = 1;
inline bool PrtoData::has_svkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoData::set_has_svkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoData::clear_has_svkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoData::clear_svkey() {
  if (svkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkey_->clear();
  }
  clear_has_svkey();
}
inline const ::std::string& PrtoData::svkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoData.sVkey)
  return *svkey_;
}
inline void PrtoData::set_svkey(const ::std::string& value) {
  set_has_svkey();
  if (svkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkey_ = new ::std::string;
  }
  svkey_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoData.sVkey)
}
inline void PrtoData::set_svkey(const char* value) {
  set_has_svkey();
  if (svkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkey_ = new ::std::string;
  }
  svkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoData.sVkey)
}
inline void PrtoData::set_svkey(const void* value, size_t size) {
  set_has_svkey();
  if (svkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkey_ = new ::std::string;
  }
  svkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoData.sVkey)
}
inline ::std::string* PrtoData::mutable_svkey() {
  set_has_svkey();
  if (svkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoData.sVkey)
  return svkey_;
}
inline ::std::string* PrtoData::release_svkey() {
  clear_has_svkey();
  if (svkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svkey_;
    svkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoData::set_allocated_svkey(::std::string* svkey) {
  if (svkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svkey_;
  }
  if (svkey) {
    set_has_svkey();
    svkey_ = svkey;
  } else {
    clear_has_svkey();
    svkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoData.sVkey)
}

// required uint32 iVmainkeylength = 2;
inline bool PrtoData::has_ivmainkeylength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoData::set_has_ivmainkeylength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoData::clear_has_ivmainkeylength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoData::clear_ivmainkeylength() {
  ivmainkeylength_ = 0u;
  clear_has_ivmainkeylength();
}
inline ::google::protobuf::uint32 PrtoData::ivmainkeylength() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoData.iVmainkeylength)
  return ivmainkeylength_;
}
inline void PrtoData::set_ivmainkeylength(::google::protobuf::uint32 value) {
  set_has_ivmainkeylength();
  ivmainkeylength_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoData.iVmainkeylength)
}

// required bytes sVopaquevalue = 3;
inline bool PrtoData::has_svopaquevalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoData::set_has_svopaquevalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoData::clear_has_svopaquevalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoData::clear_svopaquevalue() {
  if (svopaquevalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_->clear();
  }
  clear_has_svopaquevalue();
}
inline const ::std::string& PrtoData::svopaquevalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoData.sVopaquevalue)
  return *svopaquevalue_;
}
inline void PrtoData::set_svopaquevalue(const ::std::string& value) {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  svopaquevalue_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoData.sVopaquevalue)
}
inline void PrtoData::set_svopaquevalue(const char* value) {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  svopaquevalue_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoData.sVopaquevalue)
}
inline void PrtoData::set_svopaquevalue(const void* value, size_t size) {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  svopaquevalue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoData.sVopaquevalue)
}
inline ::std::string* PrtoData::mutable_svopaquevalue() {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoData.sVopaquevalue)
  return svopaquevalue_;
}
inline ::std::string* PrtoData::release_svopaquevalue() {
  clear_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svopaquevalue_;
    svopaquevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoData::set_allocated_svopaquevalue(::std::string* svopaquevalue) {
  if (svopaquevalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svopaquevalue_;
  }
  if (svopaquevalue) {
    set_has_svopaquevalue();
    svopaquevalue_ = svopaquevalue;
  } else {
    clear_has_svopaquevalue();
    svopaquevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoData.sVopaquevalue)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace orion
}  // namespace tomting
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::tomting::orion::iCsstabletype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCsstabletype>() {
  return ::com::tomting::orion::iCsstabletype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PrtoSstb_2eproto__INCLUDED
