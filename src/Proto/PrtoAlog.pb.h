// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PrtoAlog.proto

#ifndef PROTOBUF_PrtoAlog_2eproto__INCLUDED
#define PROTOBUF_PrtoAlog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace tomting {
namespace orion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PrtoAlog_2eproto();
void protobuf_AssignDesc_PrtoAlog_2eproto();
void protobuf_ShutdownFile_PrtoAlog_2eproto();

class PrtoSsls;
class PrtoLstr;
class PrtoLmtb;
class PrtoLkey;
class PrtoLval;
class PrtoLstm;
class PrtoLsts;
class PrtoLqry;
class PrtoLlog;
class PrtoL2cv;
class PrtoL2cl;
class PrtoL2st;
class PrtoL2ag;
class PrtoL2ix;
class PrtoL2ct;
class PrtoL2ao;
class PrtoL2vo;
class PrtoL2ks;
class PrtoL2or;
class PrtoL2wh;
class PrtoL2qr;
class PrtoL2os;
class PrtoL1mr;
class PrtoL2mr;
class PrtoL2iv;
class PrtoGoel;
class PrtoGoss;
class PrtoGosr;
class PrtoHiha;
class PrtoPtel;
class PrtoStel;
class PrtoTlel;
class PrtoTabl;
class PrtoAenp;
class PrtoTope;
class PrtoTop_;
class PrtoSrvc;
class PrtoSrvr;
class PrtoBsrc;
class PrtoBsrr;
class PrtoIoop;
class PrtoIwop;
class PrtoIrop;
class PrtoIgop;
class PrtoIsop;
class PrtoIqop;

enum iCpartitiontype {
  NOPARTITION = 0,
  RANDOMPARTITION = 1,
  BYTEORDERPARTITION = 2,
  CUSTOMPARTITION = 3,
  BALANCEDCUSTOMPARTITION = 4
};
bool iCpartitiontype_IsValid(int value);
const iCpartitiontype iCpartitiontype_MIN = NOPARTITION;
const iCpartitiontype iCpartitiontype_MAX = BALANCEDCUSTOMPARTITION;
const int iCpartitiontype_ARRAYSIZE = iCpartitiontype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCpartitiontype_descriptor();
inline const ::std::string& iCpartitiontype_Name(iCpartitiontype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCpartitiontype_descriptor(), value);
}
inline bool iCpartitiontype_Parse(
    const ::std::string& name, iCpartitiontype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCpartitiontype>(
    iCpartitiontype_descriptor(), name, value);
}
enum iCstatetype {
  UPSERT = 0,
  DELTMB = 1
};
bool iCstatetype_IsValid(int value);
const iCstatetype iCstatetype_MIN = UPSERT;
const iCstatetype iCstatetype_MAX = DELTMB;
const int iCstatetype_ARRAYSIZE = iCstatetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCstatetype_descriptor();
inline const ::std::string& iCstatetype_Name(iCstatetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCstatetype_descriptor(), value);
}
inline bool iCstatetype_Parse(
    const ::std::string& name, iCstatetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCstatetype>(
    iCstatetype_descriptor(), name, value);
}
enum iCopcodetype {
  MUTATOR = 0,
  STORAGE = 1,
  REPAIR_ = 2
};
bool iCopcodetype_IsValid(int value);
const iCopcodetype iCopcodetype_MIN = MUTATOR;
const iCopcodetype iCopcodetype_MAX = REPAIR_;
const int iCopcodetype_ARRAYSIZE = iCopcodetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCopcodetype_descriptor();
inline const ::std::string& iCopcodetype_Name(iCopcodetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCopcodetype_descriptor(), value);
}
inline bool iCopcodetype_Parse(
    const ::std::string& name, iCopcodetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCopcodetype>(
    iCopcodetype_descriptor(), name, value);
}
enum iCquerytype {
  EXACTQUERY = 0,
  RANGEQUERY = 1,
  TOKENQUERY = 2,
  TKSLWQUERY = 4,
  NRNGEQUERY = 5
};
bool iCquerytype_IsValid(int value);
const iCquerytype iCquerytype_MIN = EXACTQUERY;
const iCquerytype iCquerytype_MAX = NRNGEQUERY;
const int iCquerytype_ARRAYSIZE = iCquerytype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCquerytype_descriptor();
inline const ::std::string& iCquerytype_Name(iCquerytype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCquerytype_descriptor(), value);
}
inline bool iCquerytype_Parse(
    const ::std::string& name, iCquerytype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCquerytype>(
    iCquerytype_descriptor(), name, value);
}
enum iCtablettype {
  MEMORYTABLETYPE = 0,
  SSTABLETYPE = 1,
  VOLATILETABLETYPE = 2
};
bool iCtablettype_IsValid(int value);
const iCtablettype iCtablettype_MIN = MEMORYTABLETYPE;
const iCtablettype iCtablettype_MAX = VOLATILETABLETYPE;
const int iCtablettype_ARRAYSIZE = iCtablettype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCtablettype_descriptor();
inline const ::std::string& iCtablettype_Name(iCtablettype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCtablettype_descriptor(), value);
}
inline bool iCtablettype_Parse(
    const ::std::string& name, iCtablettype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCtablettype>(
    iCtablettype_descriptor(), name, value);
}
enum iCcolumntype {
  KEYTYPE___ = 0,
  STRINGTYPE = 1,
  LSTRNGTYPE = 2,
  INTEGRTYPE = 3,
  LINTGRTYPE = 4,
  DOUBLETYPE = 5,
  LDOUBLTYPE = 6,
  BOOLN_TYPE = 7
};
bool iCcolumntype_IsValid(int value);
const iCcolumntype iCcolumntype_MIN = KEYTYPE___;
const iCcolumntype iCcolumntype_MAX = BOOLN_TYPE;
const int iCcolumntype_ARRAYSIZE = iCcolumntype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCcolumntype_descriptor();
inline const ::std::string& iCcolumntype_Name(iCcolumntype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCcolumntype_descriptor(), value);
}
inline bool iCcolumntype_Parse(
    const ::std::string& name, iCcolumntype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCcolumntype>(
    iCcolumntype_descriptor(), name, value);
}
enum iCconditiontype {
  ECOND = 0,
  GCOND = 1,
  LCOND = 2,
  GECOND = 3,
  LECOND = 4
};
bool iCconditiontype_IsValid(int value);
const iCconditiontype iCconditiontype_MIN = ECOND;
const iCconditiontype iCconditiontype_MAX = LECOND;
const int iCconditiontype_ARRAYSIZE = iCconditiontype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCconditiontype_descriptor();
inline const ::std::string& iCconditiontype_Name(iCconditiontype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCconditiontype_descriptor(), value);
}
inline bool iCconditiontype_Parse(
    const ::std::string& name, iCconditiontype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCconditiontype>(
    iCconditiontype_descriptor(), name, value);
}
enum iCtabletype {
  STANDARDTABLE = 0,
  MEMORYTABLE__ = 1,
  VOLATILETABLE = 2
};
bool iCtabletype_IsValid(int value);
const iCtabletype iCtabletype_MIN = STANDARDTABLE;
const iCtabletype iCtabletype_MAX = VOLATILETABLE;
const int iCtabletype_ARRAYSIZE = iCtabletype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCtabletype_descriptor();
inline const ::std::string& iCtabletype_Name(iCtabletype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCtabletype_descriptor(), value);
}
inline bool iCtabletype_Parse(
    const ::std::string& name, iCtabletype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCtabletype>(
    iCtabletype_descriptor(), name, value);
}
enum iCindextype {
  DISTRINDEX = 0,
  LOCALINDEX = 1
};
bool iCindextype_IsValid(int value);
const iCindextype iCindextype_MIN = DISTRINDEX;
const iCindextype iCindextype_MAX = LOCALINDEX;
const int iCindextype_ARRAYSIZE = iCindextype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCindextype_descriptor();
inline const ::std::string& iCindextype_Name(iCindextype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCindextype_descriptor(), value);
}
inline bool iCindextype_Parse(
    const ::std::string& name, iCindextype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCindextype>(
    iCindextype_descriptor(), name, value);
}
enum iCordertype {
  ASC = 0,
  DESC = 1
};
bool iCordertype_IsValid(int value);
const iCordertype iCordertype_MIN = ASC;
const iCordertype iCordertype_MAX = DESC;
const int iCordertype_ARRAYSIZE = iCordertype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCordertype_descriptor();
inline const ::std::string& iCordertype_Name(iCordertype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCordertype_descriptor(), value);
}
inline bool iCordertype_Parse(
    const ::std::string& name, iCordertype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCordertype>(
    iCordertype_descriptor(), name, value);
}
enum iCstategossipnode {
  RUNNING = 0,
  JOINING = 1,
  LEAVING = 2,
  STOPPED = 3
};
bool iCstategossipnode_IsValid(int value);
const iCstategossipnode iCstategossipnode_MIN = RUNNING;
const iCstategossipnode iCstategossipnode_MAX = STOPPED;
const int iCstategossipnode_ARRAYSIZE = iCstategossipnode_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCstategossipnode_descriptor();
inline const ::std::string& iCstategossipnode_Name(iCstategossipnode value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCstategossipnode_descriptor(), value);
}
inline bool iCstategossipnode_Parse(
    const ::std::string& name, iCstategossipnode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCstategossipnode>(
    iCstategossipnode_descriptor(), name, value);
}
enum iCstatstype {
  READ = 0,
  WRITE = 1
};
bool iCstatstype_IsValid(int value);
const iCstatstype iCstatstype_MIN = READ;
const iCstatstype iCstatstype_MAX = WRITE;
const int iCstatstype_ARRAYSIZE = iCstatstype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCstatstype_descriptor();
inline const ::std::string& iCstatstype_Name(iCstatstype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCstatstype_descriptor(), value);
}
inline bool iCstatstype_Parse(
    const ::std::string& name, iCstatstype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCstatstype>(
    iCstatstype_descriptor(), name, value);
}
enum iCservicetype {
  STATEMENT = 0,
  QUERY = 1,
  OSQL = 2,
  STORAGEL2 = 3,
  STATEMENTL1 = 4,
  QUERYL1 = 5,
  STORAGEL1 = 6
};
bool iCservicetype_IsValid(int value);
const iCservicetype iCservicetype_MIN = STATEMENT;
const iCservicetype iCservicetype_MAX = STORAGEL1;
const int iCservicetype_ARRAYSIZE = iCservicetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCservicetype_descriptor();
inline const ::std::string& iCservicetype_Name(iCservicetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCservicetype_descriptor(), value);
}
inline bool iCservicetype_Parse(
    const ::std::string& name, iCservicetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCservicetype>(
    iCservicetype_descriptor(), name, value);
}
enum iCbulkservicetype {
  BULKPROTO = 0,
  BULKSTRING = 1,
  SINGLEPROTO = 2,
  PING = 3
};
bool iCbulkservicetype_IsValid(int value);
const iCbulkservicetype iCbulkservicetype_MIN = BULKPROTO;
const iCbulkservicetype iCbulkservicetype_MAX = PING;
const int iCbulkservicetype_ARRAYSIZE = iCbulkservicetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCbulkservicetype_descriptor();
inline const ::std::string& iCbulkservicetype_Name(iCbulkservicetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCbulkservicetype_descriptor(), value);
}
inline bool iCbulkservicetype_Parse(
    const ::std::string& name, iCbulkservicetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCbulkservicetype>(
    iCbulkservicetype_descriptor(), name, value);
}
enum iCdbleveltype {
  L1 = 1,
  L2 = 2
};
bool iCdbleveltype_IsValid(int value);
const iCdbleveltype iCdbleveltype_MIN = L1;
const iCdbleveltype iCdbleveltype_MAX = L2;
const int iCdbleveltype_ARRAYSIZE = iCdbleveltype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCdbleveltype_descriptor();
inline const ::std::string& iCdbleveltype_Name(iCdbleveltype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCdbleveltype_descriptor(), value);
}
inline bool iCdbleveltype_Parse(
    const ::std::string& name, iCdbleveltype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCdbleveltype>(
    iCdbleveltype_descriptor(), name, value);
}
enum iCembeddedservicetype {
  EMBEDDEDWRITE = 1,
  EMBEDDEDSTORAGE = 2,
  EMBEDDEDREAD = 3,
  EMBEDDEDOSQL = 4
};
bool iCembeddedservicetype_IsValid(int value);
const iCembeddedservicetype iCembeddedservicetype_MIN = EMBEDDEDWRITE;
const iCembeddedservicetype iCembeddedservicetype_MAX = EMBEDDEDOSQL;
const int iCembeddedservicetype_ARRAYSIZE = iCembeddedservicetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCembeddedservicetype_descriptor();
inline const ::std::string& iCembeddedservicetype_Name(iCembeddedservicetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCembeddedservicetype_descriptor(), value);
}
inline bool iCembeddedservicetype_Parse(
    const ::std::string& name, iCembeddedservicetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCembeddedservicetype>(
    iCembeddedservicetype_descriptor(), name, value);
}
// ===================================================================

class PrtoSsls : public ::google::protobuf::Message {
 public:
  PrtoSsls();
  virtual ~PrtoSsls();

  PrtoSsls(const PrtoSsls& from);

  inline PrtoSsls& operator=(const PrtoSsls& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoSsls& default_instance();

  void Swap(PrtoSsls* other);

  // implements Message ----------------------------------------------

  PrtoSsls* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoSsls& from);
  void MergeFrom(const PrtoSsls& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes sVlistindex = 1;
  inline int svlistindex_size() const;
  inline void clear_svlistindex();
  static const int kSVlistindexFieldNumber = 1;
  inline const ::std::string& svlistindex(int index) const;
  inline ::std::string* mutable_svlistindex(int index);
  inline void set_svlistindex(int index, const ::std::string& value);
  inline void set_svlistindex(int index, const char* value);
  inline void set_svlistindex(int index, const void* value, size_t size);
  inline ::std::string* add_svlistindex();
  inline void add_svlistindex(const ::std::string& value);
  inline void add_svlistindex(const char* value);
  inline void add_svlistindex(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& svlistindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_svlistindex();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoSsls)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> svlistindex_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoSsls* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLstr : public ::google::protobuf::Message {
 public:
  PrtoLstr();
  virtual ~PrtoLstr();

  PrtoLstr(const PrtoLstr& from);

  inline PrtoLstr& operator=(const PrtoLstr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLstr& default_instance();

  void Swap(PrtoLstr* other);

  // implements Message ----------------------------------------------

  PrtoLstr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLstr& from);
  void MergeFrom(const PrtoLstr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 iVmemtabledim = 1;
  inline bool has_ivmemtabledim() const;
  inline void clear_ivmemtabledim();
  static const int kIVmemtabledimFieldNumber = 1;
  inline ::google::protobuf::int32 ivmemtabledim() const;
  inline void set_ivmemtabledim(::google::protobuf::int32 value);

  // optional int32 iVmemtablesize = 2;
  inline bool has_ivmemtablesize() const;
  inline void clear_ivmemtablesize();
  static const int kIVmemtablesizeFieldNumber = 2;
  inline ::google::protobuf::int32 ivmemtablesize() const;
  inline void set_ivmemtablesize(::google::protobuf::int32 value);

  // optional int32 iVmemtablechunk = 8;
  inline bool has_ivmemtablechunk() const;
  inline void clear_ivmemtablechunk();
  static const int kIVmemtablechunkFieldNumber = 8;
  inline ::google::protobuf::int32 ivmemtablechunk() const;
  inline void set_ivmemtablechunk(::google::protobuf::int32 value);

  // optional bool bVmemorytable = 3 [default = false];
  inline bool has_bvmemorytable() const;
  inline void clear_bvmemorytable();
  static const int kBVmemorytableFieldNumber = 3;
  inline bool bvmemorytable() const;
  inline void set_bvmemorytable(bool value);

  // optional bool bVvolatiletable = 11 [default = false];
  inline bool has_bvvolatiletable() const;
  inline void clear_bvvolatiletable();
  static const int kBVvolatiletableFieldNumber = 11;
  inline bool bvvolatiletable() const;
  inline void set_bvvolatiletable(bool value);

  // optional bool bVlocalindex = 12 [default = false];
  inline bool has_bvlocalindex() const;
  inline void clear_bvlocalindex();
  static const int kBVlocalindexFieldNumber = 12;
  inline bool bvlocalindex() const;
  inline void set_bvlocalindex(bool value);

  // optional bool bVfastkey = 14 [default = false];
  inline bool has_bvfastkey() const;
  inline void clear_bvfastkey();
  static const int kBVfastkeyFieldNumber = 14;
  inline bool bvfastkey() const;
  inline void set_bvfastkey(bool value);

  // optional bytes sVshardingfrom = 4;
  inline bool has_svshardingfrom() const;
  inline void clear_svshardingfrom();
  static const int kSVshardingfromFieldNumber = 4;
  inline const ::std::string& svshardingfrom() const;
  inline void set_svshardingfrom(const ::std::string& value);
  inline void set_svshardingfrom(const char* value);
  inline void set_svshardingfrom(const void* value, size_t size);
  inline ::std::string* mutable_svshardingfrom();
  inline ::std::string* release_svshardingfrom();
  inline void set_allocated_svshardingfrom(::std::string* svshardingfrom);

  // optional bytes sVshardingto = 5;
  inline bool has_svshardingto() const;
  inline void clear_svshardingto();
  static const int kSVshardingtoFieldNumber = 5;
  inline const ::std::string& svshardingto() const;
  inline void set_svshardingto(const ::std::string& value);
  inline void set_svshardingto(const char* value);
  inline void set_svshardingto(const void* value, size_t size);
  inline ::std::string* mutable_svshardingto();
  inline ::std::string* release_svshardingto();
  inline void set_allocated_svshardingto(::std::string* svshardingto);

  // optional bytes sVshardingindexfrom = 6;
  inline bool has_svshardingindexfrom() const;
  inline void clear_svshardingindexfrom();
  static const int kSVshardingindexfromFieldNumber = 6;
  inline const ::std::string& svshardingindexfrom() const;
  inline void set_svshardingindexfrom(const ::std::string& value);
  inline void set_svshardingindexfrom(const char* value);
  inline void set_svshardingindexfrom(const void* value, size_t size);
  inline ::std::string* mutable_svshardingindexfrom();
  inline ::std::string* release_svshardingindexfrom();
  inline void set_allocated_svshardingindexfrom(::std::string* svshardingindexfrom);

  // optional bytes sVshardingindexto = 7;
  inline bool has_svshardingindexto() const;
  inline void clear_svshardingindexto();
  static const int kSVshardingindextoFieldNumber = 7;
  inline const ::std::string& svshardingindexto() const;
  inline void set_svshardingindexto(const ::std::string& value);
  inline void set_svshardingindexto(const char* value);
  inline void set_svshardingindexto(const void* value, size_t size);
  inline ::std::string* mutable_svshardingindexto();
  inline ::std::string* release_svshardingindexto();
  inline void set_allocated_svshardingindexto(::std::string* svshardingindexto);

  // optional .com.tomting.orion.iCpartitiontype iVpartitiontype = 9;
  inline bool has_ivpartitiontype() const;
  inline void clear_ivpartitiontype();
  static const int kIVpartitiontypeFieldNumber = 9;
  inline ::com::tomting::orion::iCpartitiontype ivpartitiontype() const;
  inline void set_ivpartitiontype(::com::tomting::orion::iCpartitiontype value);

  // optional bool bVrepair = 10 [default = false];
  inline bool has_bvrepair() const;
  inline void clear_bvrepair();
  static const int kBVrepairFieldNumber = 10;
  inline bool bvrepair() const;
  inline void set_bvrepair(bool value);

  // optional int32 iVreplicationfactor = 13 [default = -1];
  inline bool has_ivreplicationfactor() const;
  inline void clear_ivreplicationfactor();
  static const int kIVreplicationfactorFieldNumber = 13;
  inline ::google::protobuf::int32 ivreplicationfactor() const;
  inline void set_ivreplicationfactor(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLstr)
 private:
  inline void set_has_ivmemtabledim();
  inline void clear_has_ivmemtabledim();
  inline void set_has_ivmemtablesize();
  inline void clear_has_ivmemtablesize();
  inline void set_has_ivmemtablechunk();
  inline void clear_has_ivmemtablechunk();
  inline void set_has_bvmemorytable();
  inline void clear_has_bvmemorytable();
  inline void set_has_bvvolatiletable();
  inline void clear_has_bvvolatiletable();
  inline void set_has_bvlocalindex();
  inline void clear_has_bvlocalindex();
  inline void set_has_bvfastkey();
  inline void clear_has_bvfastkey();
  inline void set_has_svshardingfrom();
  inline void clear_has_svshardingfrom();
  inline void set_has_svshardingto();
  inline void clear_has_svshardingto();
  inline void set_has_svshardingindexfrom();
  inline void clear_has_svshardingindexfrom();
  inline void set_has_svshardingindexto();
  inline void clear_has_svshardingindexto();
  inline void set_has_ivpartitiontype();
  inline void clear_has_ivpartitiontype();
  inline void set_has_bvrepair();
  inline void clear_has_bvrepair();
  inline void set_has_ivreplicationfactor();
  inline void clear_has_ivreplicationfactor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 ivmemtabledim_;
  ::google::protobuf::int32 ivmemtablesize_;
  ::google::protobuf::int32 ivmemtablechunk_;
  bool bvmemorytable_;
  bool bvvolatiletable_;
  bool bvlocalindex_;
  bool bvfastkey_;
  ::std::string* svshardingfrom_;
  ::std::string* svshardingto_;
  ::std::string* svshardingindexfrom_;
  ::std::string* svshardingindexto_;
  int ivpartitiontype_;
  bool bvrepair_;
  ::google::protobuf::int32 ivreplicationfactor_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLstr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLmtb : public ::google::protobuf::Message {
 public:
  PrtoLmtb();
  virtual ~PrtoLmtb();

  PrtoLmtb(const PrtoLmtb& from);

  inline PrtoLmtb& operator=(const PrtoLmtb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLmtb& default_instance();

  void Swap(PrtoLmtb* other);

  // implements Message ----------------------------------------------

  PrtoLmtb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLmtb& from);
  void MergeFrom(const PrtoLmtb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVnamespace = 1;
  inline bool has_svnamespace() const;
  inline void clear_svnamespace();
  static const int kSVnamespaceFieldNumber = 1;
  inline const ::std::string& svnamespace() const;
  inline void set_svnamespace(const ::std::string& value);
  inline void set_svnamespace(const char* value);
  inline void set_svnamespace(const void* value, size_t size);
  inline ::std::string* mutable_svnamespace();
  inline ::std::string* release_svnamespace();
  inline void set_allocated_svnamespace(::std::string* svnamespace);

  // optional bytes sVtable = 2;
  inline bool has_svtable() const;
  inline void clear_svtable();
  static const int kSVtableFieldNumber = 2;
  inline const ::std::string& svtable() const;
  inline void set_svtable(const ::std::string& value);
  inline void set_svtable(const char* value);
  inline void set_svtable(const void* value, size_t size);
  inline ::std::string* mutable_svtable();
  inline ::std::string* release_svtable();
  inline void set_allocated_svtable(::std::string* svtable);

  // optional .com.tomting.orion.PrtoLstr cVstorage = 3;
  inline bool has_cvstorage() const;
  inline void clear_cvstorage();
  static const int kCVstorageFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoLstr& cvstorage() const;
  inline ::com::tomting::orion::PrtoLstr* mutable_cvstorage();
  inline ::com::tomting::orion::PrtoLstr* release_cvstorage();
  inline void set_allocated_cvstorage(::com::tomting::orion::PrtoLstr* cvstorage);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLmtb)
 private:
  inline void set_has_svnamespace();
  inline void clear_has_svnamespace();
  inline void set_has_svtable();
  inline void clear_has_svtable();
  inline void set_has_cvstorage();
  inline void clear_has_cvstorage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnamespace_;
  ::std::string* svtable_;
  ::com::tomting::orion::PrtoLstr* cvstorage_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLmtb* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLkey : public ::google::protobuf::Message {
 public:
  PrtoLkey();
  virtual ~PrtoLkey();

  PrtoLkey(const PrtoLkey& from);

  inline PrtoLkey& operator=(const PrtoLkey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLkey& default_instance();

  void Swap(PrtoLkey* other);

  // implements Message ----------------------------------------------

  PrtoLkey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLkey& from);
  void MergeFrom(const PrtoLkey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVmain = 1;
  inline bool has_svmain() const;
  inline void clear_svmain();
  static const int kSVmainFieldNumber = 1;
  inline const ::std::string& svmain() const;
  inline void set_svmain(const ::std::string& value);
  inline void set_svmain(const char* value);
  inline void set_svmain(const void* value, size_t size);
  inline ::std::string* mutable_svmain();
  inline ::std::string* release_svmain();
  inline void set_allocated_svmain(::std::string* svmain);

  // optional bytes sVaccessgroup = 2 [default = ""];
  inline bool has_svaccessgroup() const;
  inline void clear_svaccessgroup();
  static const int kSVaccessgroupFieldNumber = 2;
  inline const ::std::string& svaccessgroup() const;
  inline void set_svaccessgroup(const ::std::string& value);
  inline void set_svaccessgroup(const char* value);
  inline void set_svaccessgroup(const void* value, size_t size);
  inline ::std::string* mutable_svaccessgroup();
  inline ::std::string* release_svaccessgroup();
  inline void set_allocated_svaccessgroup(::std::string* svaccessgroup);

  // optional bytes sVqualifier = 3 [default = ""];
  inline bool has_svqualifier() const;
  inline void clear_svqualifier();
  static const int kSVqualifierFieldNumber = 3;
  inline const ::std::string& svqualifier() const;
  inline void set_svqualifier(const ::std::string& value);
  inline void set_svqualifier(const char* value);
  inline void set_svqualifier(const void* value, size_t size);
  inline ::std::string* mutable_svqualifier();
  inline ::std::string* release_svqualifier();
  inline void set_allocated_svqualifier(::std::string* svqualifier);

  // optional .com.tomting.orion.iCstatetype iVstate = 4 [default = UPSERT];
  inline bool has_ivstate() const;
  inline void clear_ivstate();
  static const int kIVstateFieldNumber = 4;
  inline ::com::tomting::orion::iCstatetype ivstate() const;
  inline void set_ivstate(::com::tomting::orion::iCstatetype value);

  // optional int64 iVtimestamp = 5 [default = 0];
  inline bool has_ivtimestamp() const;
  inline void clear_ivtimestamp();
  static const int kIVtimestampFieldNumber = 5;
  inline ::google::protobuf::int64 ivtimestamp() const;
  inline void set_ivtimestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLkey)
 private:
  inline void set_has_svmain();
  inline void clear_has_svmain();
  inline void set_has_svaccessgroup();
  inline void clear_has_svaccessgroup();
  inline void set_has_svqualifier();
  inline void clear_has_svqualifier();
  inline void set_has_ivstate();
  inline void clear_has_ivstate();
  inline void set_has_ivtimestamp();
  inline void clear_has_ivtimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svmain_;
  ::std::string* svaccessgroup_;
  ::std::string* svqualifier_;
  ::google::protobuf::int64 ivtimestamp_;
  int ivstate_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLkey* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLval : public ::google::protobuf::Message {
 public:
  PrtoLval();
  virtual ~PrtoLval();

  PrtoLval(const PrtoLval& from);

  inline PrtoLval& operator=(const PrtoLval& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLval& default_instance();

  void Swap(PrtoLval* other);

  // implements Message ----------------------------------------------

  PrtoLval* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLval& from);
  void MergeFrom(const PrtoLval& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVopaquevalue = 1;
  inline bool has_svopaquevalue() const;
  inline void clear_svopaquevalue();
  static const int kSVopaquevalueFieldNumber = 1;
  inline const ::std::string& svopaquevalue() const;
  inline void set_svopaquevalue(const ::std::string& value);
  inline void set_svopaquevalue(const char* value);
  inline void set_svopaquevalue(const void* value, size_t size);
  inline ::std::string* mutable_svopaquevalue();
  inline ::std::string* release_svopaquevalue();
  inline void set_allocated_svopaquevalue(::std::string* svopaquevalue);

  // required int64 iVtimestamp = 2;
  inline bool has_ivtimestamp() const;
  inline void clear_ivtimestamp();
  static const int kIVtimestampFieldNumber = 2;
  inline ::google::protobuf::int64 ivtimestamp() const;
  inline void set_ivtimestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLval)
 private:
  inline void set_has_svopaquevalue();
  inline void clear_has_svopaquevalue();
  inline void set_has_ivtimestamp();
  inline void clear_has_ivtimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svopaquevalue_;
  ::google::protobuf::int64 ivtimestamp_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLval* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLstm : public ::google::protobuf::Message {
 public:
  PrtoLstm();
  virtual ~PrtoLstm();

  PrtoLstm(const PrtoLstm& from);

  inline PrtoLstm& operator=(const PrtoLstm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLstm& default_instance();

  void Swap(PrtoLstm* other);

  // implements Message ----------------------------------------------

  PrtoLstm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLstm& from);
  void MergeFrom(const PrtoLstm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCopcodetype iVopcode = 1;
  inline bool has_ivopcode() const;
  inline void clear_ivopcode();
  static const int kIVopcodeFieldNumber = 1;
  inline ::com::tomting::orion::iCopcodetype ivopcode() const;
  inline void set_ivopcode(::com::tomting::orion::iCopcodetype value);

  // required .com.tomting.orion.PrtoLmtb cVmutable = 2;
  inline bool has_cvmutable() const;
  inline void clear_cvmutable();
  static const int kCVmutableFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLmtb& cvmutable() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvmutable();
  inline ::com::tomting::orion::PrtoLmtb* release_cvmutable();
  inline void set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable);

  // optional .com.tomting.orion.PrtoLkey cVkey = 4;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // optional .com.tomting.orion.PrtoLval cVvalue = 5;
  inline bool has_cvvalue() const;
  inline void clear_cvvalue();
  static const int kCVvalueFieldNumber = 5;
  inline const ::com::tomting::orion::PrtoLval& cvvalue() const;
  inline ::com::tomting::orion::PrtoLval* mutable_cvvalue();
  inline ::com::tomting::orion::PrtoLval* release_cvvalue();
  inline void set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLstm)
 private:
  inline void set_has_ivopcode();
  inline void clear_has_ivopcode();
  inline void set_has_cvmutable();
  inline void clear_has_cvmutable();
  inline void set_has_cvkey();
  inline void clear_has_cvkey();
  inline void set_has_cvvalue();
  inline void clear_has_cvvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLmtb* cvmutable_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  ::com::tomting::orion::PrtoLval* cvvalue_;
  int ivopcode_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLstm* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLsts : public ::google::protobuf::Message {
 public:
  PrtoLsts();
  virtual ~PrtoLsts();

  PrtoLsts(const PrtoLsts& from);

  inline PrtoLsts& operator=(const PrtoLsts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLsts& default_instance();

  void Swap(PrtoLsts* other);

  // implements Message ----------------------------------------------

  PrtoLsts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLsts& from);
  void MergeFrom(const PrtoLsts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoLstm cVliststatement = 1;
  inline int cvliststatement_size() const;
  inline void clear_cvliststatement();
  static const int kCVliststatementFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoLstm& cvliststatement(int index) const;
  inline ::com::tomting::orion::PrtoLstm* mutable_cvliststatement(int index);
  inline ::com::tomting::orion::PrtoLstm* add_cvliststatement();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoLstm >&
      cvliststatement() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoLstm >*
      mutable_cvliststatement();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLsts)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoLstm > cvliststatement_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLsts* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLqry : public ::google::protobuf::Message {
 public:
  PrtoLqry();
  virtual ~PrtoLqry();

  PrtoLqry(const PrtoLqry& from);

  inline PrtoLqry& operator=(const PrtoLqry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLqry& default_instance();

  void Swap(PrtoLqry* other);

  // implements Message ----------------------------------------------

  PrtoLqry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLqry& from);
  void MergeFrom(const PrtoLqry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCquerytype iVquery = 1;
  inline bool has_ivquery() const;
  inline void clear_ivquery();
  static const int kIVqueryFieldNumber = 1;
  inline ::com::tomting::orion::iCquerytype ivquery() const;
  inline void set_ivquery(::com::tomting::orion::iCquerytype value);

  // required .com.tomting.orion.PrtoLmtb cVmutable = 2;
  inline bool has_cvmutable() const;
  inline void clear_cvmutable();
  static const int kCVmutableFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLmtb& cvmutable() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvmutable();
  inline ::com::tomting::orion::PrtoLmtb* release_cvmutable();
  inline void set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable);

  // required .com.tomting.orion.PrtoLkey cVkey = 4;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // required bool bVdigest = 5 [default = false];
  inline bool has_bvdigest() const;
  inline void clear_bvdigest();
  static const int kBVdigestFieldNumber = 5;
  inline bool bvdigest() const;
  inline void set_bvdigest(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLqry)
 private:
  inline void set_has_ivquery();
  inline void clear_has_ivquery();
  inline void set_has_cvmutable();
  inline void clear_has_cvmutable();
  inline void set_has_cvkey();
  inline void clear_has_cvkey();
  inline void set_has_bvdigest();
  inline void clear_has_bvdigest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLmtb* cvmutable_;
  int ivquery_;
  bool bvdigest_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLqry* default_instance_;
};
// -------------------------------------------------------------------

class PrtoLlog : public ::google::protobuf::Message {
 public:
  PrtoLlog();
  virtual ~PrtoLlog();

  PrtoLlog(const PrtoLlog& from);

  inline PrtoLlog& operator=(const PrtoLlog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoLlog& default_instance();

  void Swap(PrtoLlog* other);

  // implements Message ----------------------------------------------

  PrtoLlog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoLlog& from);
  void MergeFrom(const PrtoLlog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVtimestamp = 1;
  inline bool has_svtimestamp() const;
  inline void clear_svtimestamp();
  static const int kSVtimestampFieldNumber = 1;
  inline const ::std::string& svtimestamp() const;
  inline void set_svtimestamp(const ::std::string& value);
  inline void set_svtimestamp(const char* value);
  inline void set_svtimestamp(const void* value, size_t size);
  inline ::std::string* mutable_svtimestamp();
  inline ::std::string* release_svtimestamp();
  inline void set_allocated_svtimestamp(::std::string* svtimestamp);

  // required .com.tomting.orion.PrtoLstm cVstatement = 2;
  inline bool has_cvstatement() const;
  inline void clear_cvstatement();
  static const int kCVstatementFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLstm& cvstatement() const;
  inline ::com::tomting::orion::PrtoLstm* mutable_cvstatement();
  inline ::com::tomting::orion::PrtoLstm* release_cvstatement();
  inline void set_allocated_cvstatement(::com::tomting::orion::PrtoLstm* cvstatement);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoLlog)
 private:
  inline void set_has_svtimestamp();
  inline void clear_has_svtimestamp();
  inline void set_has_cvstatement();
  inline void clear_has_cvstatement();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svtimestamp_;
  ::com::tomting::orion::PrtoLstm* cvstatement_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoLlog* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2cv : public ::google::protobuf::Message {
 public:
  PrtoL2cv();
  virtual ~PrtoL2cv();

  PrtoL2cv(const PrtoL2cv& from);

  inline PrtoL2cv& operator=(const PrtoL2cv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2cv& default_instance();

  void Swap(PrtoL2cv* other);

  // implements Message ----------------------------------------------

  PrtoL2cv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2cv& from);
  void MergeFrom(const PrtoL2cv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.tomting.orion.iCcolumntype iVtype = 1 [default = STRINGTYPE];
  inline bool has_ivtype() const;
  inline void clear_ivtype();
  static const int kIVtypeFieldNumber = 1;
  inline ::com::tomting::orion::iCcolumntype ivtype() const;
  inline void set_ivtype(::com::tomting::orion::iCcolumntype value);

  // optional bytes sVvalue = 2;
  inline bool has_svvalue() const;
  inline void clear_svvalue();
  static const int kSVvalueFieldNumber = 2;
  inline const ::std::string& svvalue() const;
  inline void set_svvalue(const ::std::string& value);
  inline void set_svvalue(const char* value);
  inline void set_svvalue(const void* value, size_t size);
  inline ::std::string* mutable_svvalue();
  inline ::std::string* release_svvalue();
  inline void set_allocated_svvalue(::std::string* svvalue);

  // repeated bytes sVlistvalue = 3;
  inline int svlistvalue_size() const;
  inline void clear_svlistvalue();
  static const int kSVlistvalueFieldNumber = 3;
  inline const ::std::string& svlistvalue(int index) const;
  inline ::std::string* mutable_svlistvalue(int index);
  inline void set_svlistvalue(int index, const ::std::string& value);
  inline void set_svlistvalue(int index, const char* value);
  inline void set_svlistvalue(int index, const void* value, size_t size);
  inline ::std::string* add_svlistvalue();
  inline void add_svlistvalue(const ::std::string& value);
  inline void add_svlistvalue(const char* value);
  inline void add_svlistvalue(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& svlistvalue() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_svlistvalue();

  // optional int32 iVvalue = 4;
  inline bool has_ivvalue() const;
  inline void clear_ivvalue();
  static const int kIVvalueFieldNumber = 4;
  inline ::google::protobuf::int32 ivvalue() const;
  inline void set_ivvalue(::google::protobuf::int32 value);

  // repeated int32 iVlistvalue = 5;
  inline int ivlistvalue_size() const;
  inline void clear_ivlistvalue();
  static const int kIVlistvalueFieldNumber = 5;
  inline ::google::protobuf::int32 ivlistvalue(int index) const;
  inline void set_ivlistvalue(int index, ::google::protobuf::int32 value);
  inline void add_ivlistvalue(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ivlistvalue() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ivlistvalue();

  // optional double dVvalue = 6;
  inline bool has_dvvalue() const;
  inline void clear_dvvalue();
  static const int kDVvalueFieldNumber = 6;
  inline double dvvalue() const;
  inline void set_dvvalue(double value);

  // repeated double dVlistvalue = 7;
  inline int dvlistvalue_size() const;
  inline void clear_dvlistvalue();
  static const int kDVlistvalueFieldNumber = 7;
  inline double dvlistvalue(int index) const;
  inline void set_dvlistvalue(int index, double value);
  inline void add_dvlistvalue(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      dvlistvalue() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_dvlistvalue();

  // optional bool bVvalue = 8;
  inline bool has_bvvalue() const;
  inline void clear_bvvalue();
  static const int kBVvalueFieldNumber = 8;
  inline bool bvvalue() const;
  inline void set_bvvalue(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2cv)
 private:
  inline void set_has_ivtype();
  inline void clear_has_ivtype();
  inline void set_has_svvalue();
  inline void clear_has_svvalue();
  inline void set_has_ivvalue();
  inline void clear_has_ivvalue();
  inline void set_has_dvvalue();
  inline void clear_has_dvvalue();
  inline void set_has_bvvalue();
  inline void clear_has_bvvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svvalue_;
  int ivtype_;
  ::google::protobuf::int32 ivvalue_;
  ::google::protobuf::RepeatedPtrField< ::std::string> svlistvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ivlistvalue_;
  double dvvalue_;
  ::google::protobuf::RepeatedField< double > dvlistvalue_;
  bool bvvalue_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2cv* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2cl : public ::google::protobuf::Message {
 public:
  PrtoL2cl();
  virtual ~PrtoL2cl();

  PrtoL2cl(const PrtoL2cl& from);

  inline PrtoL2cl& operator=(const PrtoL2cl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2cl& default_instance();

  void Swap(PrtoL2cl* other);

  // implements Message ----------------------------------------------

  PrtoL2cl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2cl& from);
  void MergeFrom(const PrtoL2cl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVcolumn = 1;
  inline bool has_svcolumn() const;
  inline void clear_svcolumn();
  static const int kSVcolumnFieldNumber = 1;
  inline const ::std::string& svcolumn() const;
  inline void set_svcolumn(const ::std::string& value);
  inline void set_svcolumn(const char* value);
  inline void set_svcolumn(const void* value, size_t size);
  inline ::std::string* mutable_svcolumn();
  inline ::std::string* release_svcolumn();
  inline void set_allocated_svcolumn(::std::string* svcolumn);

  // optional .com.tomting.orion.iCcolumntype iVtype = 2 [default = STRINGTYPE];
  inline bool has_ivtype() const;
  inline void clear_ivtype();
  static const int kIVtypeFieldNumber = 2;
  inline ::com::tomting::orion::iCcolumntype ivtype() const;
  inline void set_ivtype(::com::tomting::orion::iCcolumntype value);

  // optional .com.tomting.orion.PrtoL2cv cVvalue = 3;
  inline bool has_cvvalue() const;
  inline void clear_cvvalue();
  static const int kCVvalueFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2cv& cvvalue() const;
  inline ::com::tomting::orion::PrtoL2cv* mutable_cvvalue();
  inline ::com::tomting::orion::PrtoL2cv* release_cvvalue();
  inline void set_allocated_cvvalue(::com::tomting::orion::PrtoL2cv* cvvalue);

  // optional .com.tomting.orion.iCconditiontype iVconditiontype = 4;
  inline bool has_ivconditiontype() const;
  inline void clear_ivconditiontype();
  static const int kIVconditiontypeFieldNumber = 4;
  inline ::com::tomting::orion::iCconditiontype ivconditiontype() const;
  inline void set_ivconditiontype(::com::tomting::orion::iCconditiontype value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2cl)
 private:
  inline void set_has_svcolumn();
  inline void clear_has_svcolumn();
  inline void set_has_ivtype();
  inline void clear_has_ivtype();
  inline void set_has_cvvalue();
  inline void clear_has_cvvalue();
  inline void set_has_ivconditiontype();
  inline void clear_has_ivconditiontype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svcolumn_;
  ::com::tomting::orion::PrtoL2cv* cvvalue_;
  int ivtype_;
  int ivconditiontype_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2cl* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2st : public ::google::protobuf::Message {
 public:
  PrtoL2st();
  virtual ~PrtoL2st();

  PrtoL2st(const PrtoL2st& from);

  inline PrtoL2st& operator=(const PrtoL2st& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2st& default_instance();

  void Swap(PrtoL2st* other);

  // implements Message ----------------------------------------------

  PrtoL2st* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2st& from);
  void MergeFrom(const PrtoL2st& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.tomting.orion.iCopcodetype iVopcode = 1 [default = MUTATOR];
  inline bool has_ivopcode() const;
  inline void clear_ivopcode();
  static const int kIVopcodeFieldNumber = 1;
  inline ::com::tomting::orion::iCopcodetype ivopcode() const;
  inline void set_ivopcode(::com::tomting::orion::iCopcodetype value);

  // required .com.tomting.orion.PrtoLmtb cVmutable = 2;
  inline bool has_cvmutable() const;
  inline void clear_cvmutable();
  static const int kCVmutableFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLmtb& cvmutable() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvmutable();
  inline ::com::tomting::orion::PrtoLmtb* release_cvmutable();
  inline void set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable);

  // required .com.tomting.orion.PrtoLkey cVkey = 3;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // repeated .com.tomting.orion.PrtoL2cl cVcolumns = 4;
  inline int cvcolumns_size() const;
  inline void clear_cvcolumns();
  static const int kCVcolumnsFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoL2cl& cvcolumns(int index) const;
  inline ::com::tomting::orion::PrtoL2cl* mutable_cvcolumns(int index);
  inline ::com::tomting::orion::PrtoL2cl* add_cvcolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
      cvcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
      mutable_cvcolumns();

  // optional int64 iVtimestamp = 5 [default = 0];
  inline bool has_ivtimestamp() const;
  inline void clear_ivtimestamp();
  static const int kIVtimestampFieldNumber = 5;
  inline ::google::protobuf::int64 ivtimestamp() const;
  inline void set_ivtimestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2st)
 private:
  inline void set_has_ivopcode();
  inline void clear_has_ivopcode();
  inline void set_has_cvmutable();
  inline void clear_has_cvmutable();
  inline void set_has_cvkey();
  inline void clear_has_cvkey();
  inline void set_has_ivtimestamp();
  inline void clear_has_ivtimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLmtb* cvmutable_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl > cvcolumns_;
  ::google::protobuf::int64 ivtimestamp_;
  int ivopcode_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2st* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2ag : public ::google::protobuf::Message {
 public:
  PrtoL2ag();
  virtual ~PrtoL2ag();

  PrtoL2ag(const PrtoL2ag& from);

  inline PrtoL2ag& operator=(const PrtoL2ag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2ag& default_instance();

  void Swap(PrtoL2ag* other);

  // implements Message ----------------------------------------------

  PrtoL2ag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2ag& from);
  void MergeFrom(const PrtoL2ag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVname = 1;
  inline bool has_svname() const;
  inline void clear_svname();
  static const int kSVnameFieldNumber = 1;
  inline const ::std::string& svname() const;
  inline void set_svname(const ::std::string& value);
  inline void set_svname(const char* value);
  inline void set_svname(const void* value, size_t size);
  inline ::std::string* mutable_svname();
  inline ::std::string* release_svname();
  inline void set_allocated_svname(::std::string* svname);

  // repeated bytes sVcolumns = 2;
  inline int svcolumns_size() const;
  inline void clear_svcolumns();
  static const int kSVcolumnsFieldNumber = 2;
  inline const ::std::string& svcolumns(int index) const;
  inline ::std::string* mutable_svcolumns(int index);
  inline void set_svcolumns(int index, const ::std::string& value);
  inline void set_svcolumns(int index, const char* value);
  inline void set_svcolumns(int index, const void* value, size_t size);
  inline ::std::string* add_svcolumns();
  inline void add_svcolumns(const ::std::string& value);
  inline void add_svcolumns(const char* value);
  inline void add_svcolumns(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& svcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_svcolumns();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2ag)
 private:
  inline void set_has_svname();
  inline void clear_has_svname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> svcolumns_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2ag* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2ix : public ::google::protobuf::Message {
 public:
  PrtoL2ix();
  virtual ~PrtoL2ix();

  PrtoL2ix(const PrtoL2ix& from);

  inline PrtoL2ix& operator=(const PrtoL2ix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2ix& default_instance();

  void Swap(PrtoL2ix* other);

  // implements Message ----------------------------------------------

  PrtoL2ix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2ix& from);
  void MergeFrom(const PrtoL2ix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVindex = 1;
  inline bool has_svindex() const;
  inline void clear_svindex();
  static const int kSVindexFieldNumber = 1;
  inline const ::std::string& svindex() const;
  inline void set_svindex(const ::std::string& value);
  inline void set_svindex(const char* value);
  inline void set_svindex(const void* value, size_t size);
  inline ::std::string* mutable_svindex();
  inline ::std::string* release_svindex();
  inline void set_allocated_svindex(::std::string* svindex);

  // repeated .com.tomting.orion.PrtoL2or cVcolumn = 2;
  inline int cvcolumn_size() const;
  inline void clear_cvcolumn();
  static const int kCVcolumnFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL2or& cvcolumn(int index) const;
  inline ::com::tomting::orion::PrtoL2or* mutable_cvcolumn(int index);
  inline ::com::tomting::orion::PrtoL2or* add_cvcolumn();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >&
      cvcolumn() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >*
      mutable_cvcolumn();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2ix)
 private:
  inline void set_has_svindex();
  inline void clear_has_svindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svindex_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or > cvcolumn_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2ix* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2ct : public ::google::protobuf::Message {
 public:
  PrtoL2ct();
  virtual ~PrtoL2ct();

  PrtoL2ct(const PrtoL2ct& from);

  inline PrtoL2ct& operator=(const PrtoL2ct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2ct& default_instance();

  void Swap(PrtoL2ct* other);

  // implements Message ----------------------------------------------

  PrtoL2ct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2ct& from);
  void MergeFrom(const PrtoL2ct& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.PrtoLmtb cVmutable = 1;
  inline bool has_cvmutable() const;
  inline void clear_cvmutable();
  static const int kCVmutableFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoLmtb& cvmutable() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvmutable();
  inline ::com::tomting::orion::PrtoLmtb* release_cvmutable();
  inline void set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable);

  // repeated .com.tomting.orion.PrtoL2cl cVcolumns = 2;
  inline int cvcolumns_size() const;
  inline void clear_cvcolumns();
  static const int kCVcolumnsFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL2cl& cvcolumns(int index) const;
  inline ::com::tomting::orion::PrtoL2cl* mutable_cvcolumns(int index);
  inline ::com::tomting::orion::PrtoL2cl* add_cvcolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
      cvcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
      mutable_cvcolumns();

  // repeated .com.tomting.orion.PrtoL2ag cVaccessgroups = 3;
  inline int cvaccessgroups_size() const;
  inline void clear_cvaccessgroups();
  static const int kCVaccessgroupsFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2ag& cvaccessgroups(int index) const;
  inline ::com::tomting::orion::PrtoL2ag* mutable_cvaccessgroups(int index);
  inline ::com::tomting::orion::PrtoL2ag* add_cvaccessgroups();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ag >&
      cvaccessgroups() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ag >*
      mutable_cvaccessgroups();

  // optional int32 iVmemtabledim = 4 [default = 0];
  inline bool has_ivmemtabledim() const;
  inline void clear_ivmemtabledim();
  static const int kIVmemtabledimFieldNumber = 4;
  inline ::google::protobuf::int32 ivmemtabledim() const;
  inline void set_ivmemtabledim(::google::protobuf::int32 value);

  // optional int32 iVreplicationfactor = 5 [default = 1];
  inline bool has_ivreplicationfactor() const;
  inline void clear_ivreplicationfactor();
  static const int kIVreplicationfactorFieldNumber = 5;
  inline ::google::protobuf::int32 ivreplicationfactor() const;
  inline void set_ivreplicationfactor(::google::protobuf::int32 value);

  // optional .com.tomting.orion.iCtabletype iVtabletype = 6 [default = VOLATILETABLE];
  inline bool has_ivtabletype() const;
  inline void clear_ivtabletype();
  static const int kIVtabletypeFieldNumber = 6;
  inline ::com::tomting::orion::iCtabletype ivtabletype() const;
  inline void set_ivtabletype(::com::tomting::orion::iCtabletype value);

  // optional .com.tomting.orion.iCpartitiontype iVpartitiontype = 7 [default = NOPARTITION];
  inline bool has_ivpartitiontype() const;
  inline void clear_ivpartitiontype();
  static const int kIVpartitiontypeFieldNumber = 7;
  inline ::com::tomting::orion::iCpartitiontype ivpartitiontype() const;
  inline void set_ivpartitiontype(::com::tomting::orion::iCpartitiontype value);

  // optional .com.tomting.orion.iCindextype iVindextype = 8 [default = DISTRINDEX];
  inline bool has_ivindextype() const;
  inline void clear_ivindextype();
  static const int kIVindextypeFieldNumber = 8;
  inline ::com::tomting::orion::iCindextype ivindextype() const;
  inline void set_ivindextype(::com::tomting::orion::iCindextype value);

  // repeated .com.tomting.orion.PrtoL2ix cVindexes = 9;
  inline int cvindexes_size() const;
  inline void clear_cvindexes();
  static const int kCVindexesFieldNumber = 9;
  inline const ::com::tomting::orion::PrtoL2ix& cvindexes(int index) const;
  inline ::com::tomting::orion::PrtoL2ix* mutable_cvindexes(int index);
  inline ::com::tomting::orion::PrtoL2ix* add_cvindexes();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ix >&
      cvindexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ix >*
      mutable_cvindexes();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2ct)
 private:
  inline void set_has_cvmutable();
  inline void clear_has_cvmutable();
  inline void set_has_ivmemtabledim();
  inline void clear_has_ivmemtabledim();
  inline void set_has_ivreplicationfactor();
  inline void clear_has_ivreplicationfactor();
  inline void set_has_ivtabletype();
  inline void clear_has_ivtabletype();
  inline void set_has_ivpartitiontype();
  inline void clear_has_ivpartitiontype();
  inline void set_has_ivindextype();
  inline void clear_has_ivindextype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLmtb* cvmutable_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl > cvcolumns_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ag > cvaccessgroups_;
  ::google::protobuf::int32 ivmemtabledim_;
  ::google::protobuf::int32 ivreplicationfactor_;
  int ivtabletype_;
  int ivpartitiontype_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ix > cvindexes_;
  int ivindextype_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2ct* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2ao : public ::google::protobuf::Message {
 public:
  PrtoL2ao();
  virtual ~PrtoL2ao();

  PrtoL2ao(const PrtoL2ao& from);

  inline PrtoL2ao& operator=(const PrtoL2ao& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2ao& default_instance();

  void Swap(PrtoL2ao* other);

  // implements Message ----------------------------------------------

  PrtoL2ao* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2ao& from);
  void MergeFrom(const PrtoL2ao& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoL2cl cVcolumns = 1;
  inline int cvcolumns_size() const;
  inline void clear_cvcolumns();
  static const int kCVcolumnsFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoL2cl& cvcolumns(int index) const;
  inline ::com::tomting::orion::PrtoL2cl* mutable_cvcolumns(int index);
  inline ::com::tomting::orion::PrtoL2cl* add_cvcolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
      cvcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
      mutable_cvcolumns();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2ao)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl > cvcolumns_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2ao* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2vo : public ::google::protobuf::Message {
 public:
  PrtoL2vo();
  virtual ~PrtoL2vo();

  PrtoL2vo(const PrtoL2vo& from);

  inline PrtoL2vo& operator=(const PrtoL2vo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2vo& default_instance();

  void Swap(PrtoL2vo* other);

  // implements Message ----------------------------------------------

  PrtoL2vo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2vo& from);
  void MergeFrom(const PrtoL2vo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoL2ao cVaccessobject = 1;
  inline int cvaccessobject_size() const;
  inline void clear_cvaccessobject();
  static const int kCVaccessobjectFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoL2ao& cvaccessobject(int index) const;
  inline ::com::tomting::orion::PrtoL2ao* mutable_cvaccessobject(int index);
  inline ::com::tomting::orion::PrtoL2ao* add_cvaccessobject();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ao >&
      cvaccessobject() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ao >*
      mutable_cvaccessobject();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2vo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ao > cvaccessobject_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2vo* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2ks : public ::google::protobuf::Message {
 public:
  PrtoL2ks();
  virtual ~PrtoL2ks();

  PrtoL2ks(const PrtoL2ks& from);

  inline PrtoL2ks& operator=(const PrtoL2ks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2ks& default_instance();

  void Swap(PrtoL2ks* other);

  // implements Message ----------------------------------------------

  PrtoL2ks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2ks& from);
  void MergeFrom(const PrtoL2ks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.PrtoLkey cVkey = 1;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // repeated .com.tomting.orion.PrtoL2cl cVcolumns = 2;
  inline int cvcolumns_size() const;
  inline void clear_cvcolumns();
  static const int kCVcolumnsFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL2cl& cvcolumns(int index) const;
  inline ::com::tomting::orion::PrtoL2cl* mutable_cvcolumns(int index);
  inline ::com::tomting::orion::PrtoL2cl* add_cvcolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
      cvcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
      mutable_cvcolumns();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2ks)
 private:
  inline void set_has_cvkey();
  inline void clear_has_cvkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl > cvcolumns_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2ks* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2or : public ::google::protobuf::Message {
 public:
  PrtoL2or();
  virtual ~PrtoL2or();

  PrtoL2or(const PrtoL2or& from);

  inline PrtoL2or& operator=(const PrtoL2or& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2or& default_instance();

  void Swap(PrtoL2or* other);

  // implements Message ----------------------------------------------

  PrtoL2or* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2or& from);
  void MergeFrom(const PrtoL2or& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVcolumn = 1;
  inline bool has_svcolumn() const;
  inline void clear_svcolumn();
  static const int kSVcolumnFieldNumber = 1;
  inline const ::std::string& svcolumn() const;
  inline void set_svcolumn(const ::std::string& value);
  inline void set_svcolumn(const char* value);
  inline void set_svcolumn(const void* value, size_t size);
  inline ::std::string* mutable_svcolumn();
  inline ::std::string* release_svcolumn();
  inline void set_allocated_svcolumn(::std::string* svcolumn);

  // required .com.tomting.orion.iCordertype iVordertype = 2;
  inline bool has_ivordertype() const;
  inline void clear_ivordertype();
  static const int kIVordertypeFieldNumber = 2;
  inline ::com::tomting::orion::iCordertype ivordertype() const;
  inline void set_ivordertype(::com::tomting::orion::iCordertype value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2or)
 private:
  inline void set_has_svcolumn();
  inline void clear_has_svcolumn();
  inline void set_has_ivordertype();
  inline void clear_has_ivordertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svcolumn_;
  int ivordertype_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2or* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2wh : public ::google::protobuf::Message {
 public:
  PrtoL2wh();
  virtual ~PrtoL2wh();

  PrtoL2wh(const PrtoL2wh& from);

  inline PrtoL2wh& operator=(const PrtoL2wh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2wh& default_instance();

  void Swap(PrtoL2wh* other);

  // implements Message ----------------------------------------------

  PrtoL2wh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2wh& from);
  void MergeFrom(const PrtoL2wh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoL2cl cVcondition = 1;
  inline int cvcondition_size() const;
  inline void clear_cvcondition();
  static const int kCVconditionFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoL2cl& cvcondition(int index) const;
  inline ::com::tomting::orion::PrtoL2cl* mutable_cvcondition(int index);
  inline ::com::tomting::orion::PrtoL2cl* add_cvcondition();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
      cvcondition() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
      mutable_cvcondition();

  // repeated .com.tomting.orion.PrtoL2or cVorderby = 2;
  inline int cvorderby_size() const;
  inline void clear_cvorderby();
  static const int kCVorderbyFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL2or& cvorderby(int index) const;
  inline ::com::tomting::orion::PrtoL2or* mutable_cvorderby(int index);
  inline ::com::tomting::orion::PrtoL2or* add_cvorderby();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >&
      cvorderby() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >*
      mutable_cvorderby();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2wh)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl > cvcondition_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or > cvorderby_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2wh* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2qr : public ::google::protobuf::Message {
 public:
  PrtoL2qr();
  virtual ~PrtoL2qr();

  PrtoL2qr(const PrtoL2qr& from);

  inline PrtoL2qr& operator=(const PrtoL2qr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2qr& default_instance();

  void Swap(PrtoL2qr* other);

  // implements Message ----------------------------------------------

  PrtoL2qr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2qr& from);
  void MergeFrom(const PrtoL2qr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoL2cl cVselect = 1;
  inline int cvselect_size() const;
  inline void clear_cvselect();
  static const int kCVselectFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoL2cl& cvselect(int index) const;
  inline ::com::tomting::orion::PrtoL2cl* mutable_cvselect(int index);
  inline ::com::tomting::orion::PrtoL2cl* add_cvselect();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
      cvselect() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
      mutable_cvselect();

  // required .com.tomting.orion.PrtoLmtb cVmutable = 2;
  inline bool has_cvmutable() const;
  inline void clear_cvmutable();
  static const int kCVmutableFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLmtb& cvmutable() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvmutable();
  inline ::com::tomting::orion::PrtoLmtb* release_cvmutable();
  inline void set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable);

  // optional .com.tomting.orion.iCquerytype iVquery = 3;
  inline bool has_ivquery() const;
  inline void clear_ivquery();
  static const int kIVqueryFieldNumber = 3;
  inline ::com::tomting::orion::iCquerytype ivquery() const;
  inline void set_ivquery(::com::tomting::orion::iCquerytype value);

  // optional .com.tomting.orion.PrtoLkey cVkey_start = 4;
  inline bool has_cvkey_start() const;
  inline void clear_cvkey_start();
  static const int kCVkeyStartFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoLkey& cvkey_start() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey_start();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey_start();
  inline void set_allocated_cvkey_start(::com::tomting::orion::PrtoLkey* cvkey_start);

  // optional .com.tomting.orion.PrtoLkey cVkey_end = 5;
  inline bool has_cvkey_end() const;
  inline void clear_cvkey_end();
  static const int kCVkeyEndFieldNumber = 5;
  inline const ::com::tomting::orion::PrtoLkey& cvkey_end() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey_end();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey_end();
  inline void set_allocated_cvkey_end(::com::tomting::orion::PrtoLkey* cvkey_end);

  // optional .com.tomting.orion.PrtoL2wh cVwhere = 6;
  inline bool has_cvwhere() const;
  inline void clear_cvwhere();
  static const int kCVwhereFieldNumber = 6;
  inline const ::com::tomting::orion::PrtoL2wh& cvwhere() const;
  inline ::com::tomting::orion::PrtoL2wh* mutable_cvwhere();
  inline ::com::tomting::orion::PrtoL2wh* release_cvwhere();
  inline void set_allocated_cvwhere(::com::tomting::orion::PrtoL2wh* cvwhere);

  // optional int32 iVcount = 7 [default = 100];
  inline bool has_ivcount() const;
  inline void clear_ivcount();
  static const int kIVcountFieldNumber = 7;
  inline ::google::protobuf::int32 ivcount() const;
  inline void set_ivcount(::google::protobuf::int32 value);

  // optional bool bVonlysecondary = 8 [default = false];
  inline bool has_bvonlysecondary() const;
  inline void clear_bvonlysecondary();
  static const int kBVonlysecondaryFieldNumber = 8;
  inline bool bvonlysecondary() const;
  inline void set_bvonlysecondary(bool value);

  // optional bool bVdisableteleport = 9 [default = false];
  inline bool has_bvdisableteleport() const;
  inline void clear_bvdisableteleport();
  static const int kBVdisableteleportFieldNumber = 9;
  inline bool bvdisableteleport() const;
  inline void set_bvdisableteleport(bool value);

  // optional bool bVfulltablescan = 10 [default = false];
  inline bool has_bvfulltablescan() const;
  inline void clear_bvfulltablescan();
  static const int kBVfulltablescanFieldNumber = 10;
  inline bool bvfulltablescan() const;
  inline void set_bvfulltablescan(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2qr)
 private:
  inline void set_has_cvmutable();
  inline void clear_has_cvmutable();
  inline void set_has_ivquery();
  inline void clear_has_ivquery();
  inline void set_has_cvkey_start();
  inline void clear_has_cvkey_start();
  inline void set_has_cvkey_end();
  inline void clear_has_cvkey_end();
  inline void set_has_cvwhere();
  inline void clear_has_cvwhere();
  inline void set_has_ivcount();
  inline void clear_has_ivcount();
  inline void set_has_bvonlysecondary();
  inline void clear_has_bvonlysecondary();
  inline void set_has_bvdisableteleport();
  inline void clear_has_bvdisableteleport();
  inline void set_has_bvfulltablescan();
  inline void clear_has_bvfulltablescan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl > cvselect_;
  ::com::tomting::orion::PrtoLmtb* cvmutable_;
  ::com::tomting::orion::PrtoLkey* cvkey_start_;
  ::com::tomting::orion::PrtoLkey* cvkey_end_;
  int ivquery_;
  ::google::protobuf::int32 ivcount_;
  ::com::tomting::orion::PrtoL2wh* cvwhere_;
  bool bvonlysecondary_;
  bool bvdisableteleport_;
  bool bvfulltablescan_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2qr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2os : public ::google::protobuf::Message {
 public:
  PrtoL2os();
  virtual ~PrtoL2os();

  PrtoL2os(const PrtoL2os& from);

  inline PrtoL2os& operator=(const PrtoL2os& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2os& default_instance();

  void Swap(PrtoL2os* other);

  // implements Message ----------------------------------------------

  PrtoL2os* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2os& from);
  void MergeFrom(const PrtoL2os& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVnamespace = 1;
  inline bool has_svnamespace() const;
  inline void clear_svnamespace();
  static const int kSVnamespaceFieldNumber = 1;
  inline const ::std::string& svnamespace() const;
  inline void set_svnamespace(const ::std::string& value);
  inline void set_svnamespace(const char* value);
  inline void set_svnamespace(const void* value, size_t size);
  inline ::std::string* mutable_svnamespace();
  inline ::std::string* release_svnamespace();
  inline void set_allocated_svnamespace(::std::string* svnamespace);

  // required bytes sVosqlstring = 2;
  inline bool has_svosqlstring() const;
  inline void clear_svosqlstring();
  static const int kSVosqlstringFieldNumber = 2;
  inline const ::std::string& svosqlstring() const;
  inline void set_svosqlstring(const ::std::string& value);
  inline void set_svosqlstring(const char* value);
  inline void set_svosqlstring(const void* value, size_t size);
  inline ::std::string* mutable_svosqlstring();
  inline ::std::string* release_svosqlstring();
  inline void set_allocated_svosqlstring(::std::string* svosqlstring);

  // repeated .com.tomting.orion.PrtoL2cv cVinputbindings = 3;
  inline int cvinputbindings_size() const;
  inline void clear_cvinputbindings();
  static const int kCVinputbindingsFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2cv& cvinputbindings(int index) const;
  inline ::com::tomting::orion::PrtoL2cv* mutable_cvinputbindings(int index);
  inline ::com::tomting::orion::PrtoL2cv* add_cvinputbindings();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cv >&
      cvinputbindings() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cv >*
      mutable_cvinputbindings();

  // optional bool bVonlysecondary = 4 [default = false];
  inline bool has_bvonlysecondary() const;
  inline void clear_bvonlysecondary();
  static const int kBVonlysecondaryFieldNumber = 4;
  inline bool bvonlysecondary() const;
  inline void set_bvonlysecondary(bool value);

  // optional bool bVdisableteleport = 5 [default = false];
  inline bool has_bvdisableteleport() const;
  inline void clear_bvdisableteleport();
  static const int kBVdisableteleportFieldNumber = 5;
  inline bool bvdisableteleport() const;
  inline void set_bvdisableteleport(bool value);

  // optional int64 iVtimestamp = 6 [default = 0];
  inline bool has_ivtimestamp() const;
  inline void clear_ivtimestamp();
  static const int kIVtimestampFieldNumber = 6;
  inline ::google::protobuf::int64 ivtimestamp() const;
  inline void set_ivtimestamp(::google::protobuf::int64 value);

  // optional bool bVfulltablescan = 7 [default = false];
  inline bool has_bvfulltablescan() const;
  inline void clear_bvfulltablescan();
  static const int kBVfulltablescanFieldNumber = 7;
  inline bool bvfulltablescan() const;
  inline void set_bvfulltablescan(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2os)
 private:
  inline void set_has_svnamespace();
  inline void clear_has_svnamespace();
  inline void set_has_svosqlstring();
  inline void clear_has_svosqlstring();
  inline void set_has_bvonlysecondary();
  inline void clear_has_bvonlysecondary();
  inline void set_has_bvdisableteleport();
  inline void clear_has_bvdisableteleport();
  inline void set_has_ivtimestamp();
  inline void clear_has_ivtimestamp();
  inline void set_has_bvfulltablescan();
  inline void clear_has_bvfulltablescan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnamespace_;
  ::std::string* svosqlstring_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cv > cvinputbindings_;
  ::google::protobuf::int64 ivtimestamp_;
  bool bvonlysecondary_;
  bool bvdisableteleport_;
  bool bvfulltablescan_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2os* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL1mr : public ::google::protobuf::Message {
 public:
  PrtoL1mr();
  virtual ~PrtoL1mr();

  PrtoL1mr(const PrtoL1mr& from);

  inline PrtoL1mr& operator=(const PrtoL1mr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL1mr& default_instance();

  void Swap(PrtoL1mr* other);

  // implements Message ----------------------------------------------

  PrtoL1mr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL1mr& from);
  void MergeFrom(const PrtoL1mr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.tomting.orion.PrtoLkey cVkey = 1;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // optional .com.tomting.orion.PrtoLval cVvalue = 2;
  inline bool has_cvvalue() const;
  inline void clear_cvvalue();
  static const int kCVvalueFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLval& cvvalue() const;
  inline ::com::tomting::orion::PrtoLval* mutable_cvvalue();
  inline ::com::tomting::orion::PrtoLval* release_cvvalue();
  inline void set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL1mr)
 private:
  inline void set_has_cvkey();
  inline void clear_has_cvkey();
  inline void set_has_cvvalue();
  inline void clear_has_cvvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  ::com::tomting::orion::PrtoLval* cvvalue_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL1mr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2mr : public ::google::protobuf::Message {
 public:
  PrtoL2mr();
  virtual ~PrtoL2mr();

  PrtoL2mr(const PrtoL2mr& from);

  inline PrtoL2mr& operator=(const PrtoL2mr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2mr& default_instance();

  void Swap(PrtoL2mr* other);

  // implements Message ----------------------------------------------

  PrtoL2mr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2mr& from);
  void MergeFrom(const PrtoL2mr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoL2ks cVkeyslice = 1;
  inline int cvkeyslice_size() const;
  inline void clear_cvkeyslice();
  static const int kCVkeysliceFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoL2ks& cvkeyslice(int index) const;
  inline ::com::tomting::orion::PrtoL2ks* mutable_cvkeyslice(int index);
  inline ::com::tomting::orion::PrtoL2ks* add_cvkeyslice();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ks >&
      cvkeyslice() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ks >*
      mutable_cvkeyslice();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2mr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ks > cvkeyslice_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2mr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoL2iv : public ::google::protobuf::Message {
 public:
  PrtoL2iv();
  virtual ~PrtoL2iv();

  PrtoL2iv(const PrtoL2iv& from);

  inline PrtoL2iv& operator=(const PrtoL2iv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoL2iv& default_instance();

  void Swap(PrtoL2iv* other);

  // implements Message ----------------------------------------------

  PrtoL2iv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoL2iv& from);
  void MergeFrom(const PrtoL2iv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 iVkeydelimiters = 1;
  inline int ivkeydelimiters_size() const;
  inline void clear_ivkeydelimiters();
  static const int kIVkeydelimitersFieldNumber = 1;
  inline ::google::protobuf::int32 ivkeydelimiters(int index) const;
  inline void set_ivkeydelimiters(int index, ::google::protobuf::int32 value);
  inline void add_ivkeydelimiters(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ivkeydelimiters() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ivkeydelimiters();

  // required bytes sVoriginalkey = 2;
  inline bool has_svoriginalkey() const;
  inline void clear_svoriginalkey();
  static const int kSVoriginalkeyFieldNumber = 2;
  inline const ::std::string& svoriginalkey() const;
  inline void set_svoriginalkey(const ::std::string& value);
  inline void set_svoriginalkey(const char* value);
  inline void set_svoriginalkey(const void* value, size_t size);
  inline ::std::string* mutable_svoriginalkey();
  inline ::std::string* release_svoriginalkey();
  inline void set_allocated_svoriginalkey(::std::string* svoriginalkey);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoL2iv)
 private:
  inline void set_has_svoriginalkey();
  inline void clear_has_svoriginalkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ivkeydelimiters_;
  ::std::string* svoriginalkey_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoL2iv* default_instance_;
};
// -------------------------------------------------------------------

class PrtoGoel : public ::google::protobuf::Message {
 public:
  PrtoGoel();
  virtual ~PrtoGoel();

  PrtoGoel(const PrtoGoel& from);

  inline PrtoGoel& operator=(const PrtoGoel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoGoel& default_instance();

  void Swap(PrtoGoel* other);

  // implements Message ----------------------------------------------

  PrtoGoel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoGoel& from);
  void MergeFrom(const PrtoGoel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVtoken = 1;
  inline bool has_svtoken() const;
  inline void clear_svtoken();
  static const int kSVtokenFieldNumber = 1;
  inline const ::std::string& svtoken() const;
  inline void set_svtoken(const ::std::string& value);
  inline void set_svtoken(const char* value);
  inline void set_svtoken(const void* value, size_t size);
  inline ::std::string* mutable_svtoken();
  inline ::std::string* release_svtoken();
  inline void set_allocated_svtoken(::std::string* svtoken);

  // required bytes sVnodeid = 2;
  inline bool has_svnodeid() const;
  inline void clear_svnodeid();
  static const int kSVnodeidFieldNumber = 2;
  inline const ::std::string& svnodeid() const;
  inline void set_svnodeid(const ::std::string& value);
  inline void set_svnodeid(const char* value);
  inline void set_svnodeid(const void* value, size_t size);
  inline ::std::string* mutable_svnodeid();
  inline ::std::string* release_svnodeid();
  inline void set_allocated_svnodeid(::std::string* svnodeid);

  // required bytes sVdatacenterid = 3;
  inline bool has_svdatacenterid() const;
  inline void clear_svdatacenterid();
  static const int kSVdatacenteridFieldNumber = 3;
  inline const ::std::string& svdatacenterid() const;
  inline void set_svdatacenterid(const ::std::string& value);
  inline void set_svdatacenterid(const char* value);
  inline void set_svdatacenterid(const void* value, size_t size);
  inline ::std::string* mutable_svdatacenterid();
  inline ::std::string* release_svdatacenterid();
  inline void set_allocated_svdatacenterid(::std::string* svdatacenterid);

  // optional double dVphiaccrual = 4;
  inline bool has_dvphiaccrual() const;
  inline void clear_dvphiaccrual();
  static const int kDVphiaccrualFieldNumber = 4;
  inline double dvphiaccrual() const;
  inline void set_dvphiaccrual(double value);

  // optional bytes sVaddress = 5;
  inline bool has_svaddress() const;
  inline void clear_svaddress();
  static const int kSVaddressFieldNumber = 5;
  inline const ::std::string& svaddress() const;
  inline void set_svaddress(const ::std::string& value);
  inline void set_svaddress(const char* value);
  inline void set_svaddress(const void* value, size_t size);
  inline ::std::string* mutable_svaddress();
  inline ::std::string* release_svaddress();
  inline void set_allocated_svaddress(::std::string* svaddress);

  // optional int32 iVport = 6;
  inline bool has_ivport() const;
  inline void clear_ivport();
  static const int kIVportFieldNumber = 6;
  inline ::google::protobuf::int32 ivport() const;
  inline void set_ivport(::google::protobuf::int32 value);

  // optional bytes sVreader = 7;
  inline bool has_svreader() const;
  inline void clear_svreader();
  static const int kSVreaderFieldNumber = 7;
  inline const ::std::string& svreader() const;
  inline void set_svreader(const ::std::string& value);
  inline void set_svreader(const char* value);
  inline void set_svreader(const void* value, size_t size);
  inline ::std::string* mutable_svreader();
  inline ::std::string* release_svreader();
  inline void set_allocated_svreader(::std::string* svreader);

  // optional bytes sVwriter = 8;
  inline bool has_svwriter() const;
  inline void clear_svwriter();
  static const int kSVwriterFieldNumber = 8;
  inline const ::std::string& svwriter() const;
  inline void set_svwriter(const ::std::string& value);
  inline void set_svwriter(const char* value);
  inline void set_svwriter(const void* value, size_t size);
  inline ::std::string* mutable_svwriter();
  inline ::std::string* release_svwriter();
  inline void set_allocated_svwriter(::std::string* svwriter);

  // optional .com.tomting.orion.iCstategossipnode iVstate = 9;
  inline bool has_ivstate() const;
  inline void clear_ivstate();
  static const int kIVstateFieldNumber = 9;
  inline ::com::tomting::orion::iCstategossipnode ivstate() const;
  inline void set_ivstate(::com::tomting::orion::iCstategossipnode value);

  // optional int64 iVtimestamp = 10;
  inline bool has_ivtimestamp() const;
  inline void clear_ivtimestamp();
  static const int kIVtimestampFieldNumber = 10;
  inline ::google::protobuf::int64 ivtimestamp() const;
  inline void set_ivtimestamp(::google::protobuf::int64 value);

  // optional int64 iVsize = 11;
  inline bool has_ivsize() const;
  inline void clear_ivsize();
  static const int kIVsizeFieldNumber = 11;
  inline ::google::protobuf::int64 ivsize() const;
  inline void set_ivsize(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoGoel)
 private:
  inline void set_has_svtoken();
  inline void clear_has_svtoken();
  inline void set_has_svnodeid();
  inline void clear_has_svnodeid();
  inline void set_has_svdatacenterid();
  inline void clear_has_svdatacenterid();
  inline void set_has_dvphiaccrual();
  inline void clear_has_dvphiaccrual();
  inline void set_has_svaddress();
  inline void clear_has_svaddress();
  inline void set_has_ivport();
  inline void clear_has_ivport();
  inline void set_has_svreader();
  inline void clear_has_svreader();
  inline void set_has_svwriter();
  inline void clear_has_svwriter();
  inline void set_has_ivstate();
  inline void clear_has_ivstate();
  inline void set_has_ivtimestamp();
  inline void clear_has_ivtimestamp();
  inline void set_has_ivsize();
  inline void clear_has_ivsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svtoken_;
  ::std::string* svnodeid_;
  ::std::string* svdatacenterid_;
  double dvphiaccrual_;
  ::std::string* svaddress_;
  ::std::string* svreader_;
  ::google::protobuf::int32 ivport_;
  int ivstate_;
  ::std::string* svwriter_;
  ::google::protobuf::int64 ivtimestamp_;
  ::google::protobuf::int64 ivsize_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoGoel* default_instance_;
};
// -------------------------------------------------------------------

class PrtoGoss : public ::google::protobuf::Message {
 public:
  PrtoGoss();
  virtual ~PrtoGoss();

  PrtoGoss(const PrtoGoss& from);

  inline PrtoGoss& operator=(const PrtoGoss& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoGoss& default_instance();

  void Swap(PrtoGoss* other);

  // implements Message ----------------------------------------------

  PrtoGoss* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoGoss& from);
  void MergeFrom(const PrtoGoss& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoGoel cVgossipelement = 1;
  inline int cvgossipelement_size() const;
  inline void clear_cvgossipelement();
  static const int kCVgossipelementFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoGoel& cvgossipelement(int index) const;
  inline ::com::tomting::orion::PrtoGoel* mutable_cvgossipelement(int index);
  inline ::com::tomting::orion::PrtoGoel* add_cvgossipelement();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >&
      cvgossipelement() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >*
      mutable_cvgossipelement();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoGoss)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel > cvgossipelement_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoGoss* default_instance_;
};
// -------------------------------------------------------------------

class PrtoGosr : public ::google::protobuf::Message {
 public:
  PrtoGosr();
  virtual ~PrtoGosr();

  PrtoGosr(const PrtoGosr& from);

  inline PrtoGosr& operator=(const PrtoGosr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoGosr& default_instance();

  void Swap(PrtoGosr* other);

  // implements Message ----------------------------------------------

  PrtoGosr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoGosr& from);
  void MergeFrom(const PrtoGosr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.PrtoGoel cVgossipelement = 1;
  inline bool has_cvgossipelement() const;
  inline void clear_cvgossipelement();
  static const int kCVgossipelementFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoGoel& cvgossipelement() const;
  inline ::com::tomting::orion::PrtoGoel* mutable_cvgossipelement();
  inline ::com::tomting::orion::PrtoGoel* release_cvgossipelement();
  inline void set_allocated_cvgossipelement(::com::tomting::orion::PrtoGoel* cvgossipelement);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoGosr)
 private:
  inline void set_has_cvgossipelement();
  inline void clear_has_cvgossipelement();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoGoel* cvgossipelement_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoGosr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoHiha : public ::google::protobuf::Message {
 public:
  PrtoHiha();
  virtual ~PrtoHiha();

  PrtoHiha(const PrtoHiha& from);

  inline PrtoHiha& operator=(const PrtoHiha& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoHiha& default_instance();

  void Swap(PrtoHiha* other);

  // implements Message ----------------------------------------------

  PrtoHiha* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoHiha& from);
  void MergeFrom(const PrtoHiha& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVnode = 1;
  inline bool has_svnode() const;
  inline void clear_svnode();
  static const int kSVnodeFieldNumber = 1;
  inline const ::std::string& svnode() const;
  inline void set_svnode(const ::std::string& value);
  inline void set_svnode(const char* value);
  inline void set_svnode(const void* value, size_t size);
  inline ::std::string* mutable_svnode();
  inline ::std::string* release_svnode();
  inline void set_allocated_svnode(::std::string* svnode);

  // required .com.tomting.orion.PrtoLsts cVstatements = 2;
  inline bool has_cvstatements() const;
  inline void clear_cvstatements();
  static const int kCVstatementsFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLsts& cvstatements() const;
  inline ::com::tomting::orion::PrtoLsts* mutable_cvstatements();
  inline ::com::tomting::orion::PrtoLsts* release_cvstatements();
  inline void set_allocated_cvstatements(::com::tomting::orion::PrtoLsts* cvstatements);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoHiha)
 private:
  inline void set_has_svnode();
  inline void clear_has_svnode();
  inline void set_has_cvstatements();
  inline void clear_has_cvstatements();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnode_;
  ::com::tomting::orion::PrtoLsts* cvstatements_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoHiha* default_instance_;
};
// -------------------------------------------------------------------

class PrtoPtel : public ::google::protobuf::Message {
 public:
  PrtoPtel();
  virtual ~PrtoPtel();

  PrtoPtel(const PrtoPtel& from);

  inline PrtoPtel& operator=(const PrtoPtel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoPtel& default_instance();

  void Swap(PrtoPtel* other);

  // implements Message ----------------------------------------------

  PrtoPtel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoPtel& from);
  void MergeFrom(const PrtoPtel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVnodeid = 1;
  inline bool has_svnodeid() const;
  inline void clear_svnodeid();
  static const int kSVnodeidFieldNumber = 1;
  inline const ::std::string& svnodeid() const;
  inline void set_svnodeid(const ::std::string& value);
  inline void set_svnodeid(const char* value);
  inline void set_svnodeid(const void* value, size_t size);
  inline ::std::string* mutable_svnodeid();
  inline ::std::string* release_svnodeid();
  inline void set_allocated_svnodeid(::std::string* svnodeid);

  // required bytes sVbound = 2;
  inline bool has_svbound() const;
  inline void clear_svbound();
  static const int kSVboundFieldNumber = 2;
  inline const ::std::string& svbound() const;
  inline void set_svbound(const ::std::string& value);
  inline void set_svbound(const char* value);
  inline void set_svbound(const void* value, size_t size);
  inline ::std::string* mutable_svbound();
  inline ::std::string* release_svbound();
  inline void set_allocated_svbound(::std::string* svbound);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoPtel)
 private:
  inline void set_has_svnodeid();
  inline void clear_has_svnodeid();
  inline void set_has_svbound();
  inline void clear_has_svbound();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnodeid_;
  ::std::string* svbound_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoPtel* default_instance_;
};
// -------------------------------------------------------------------

class PrtoStel : public ::google::protobuf::Message {
 public:
  PrtoStel();
  virtual ~PrtoStel();

  PrtoStel(const PrtoStel& from);

  inline PrtoStel& operator=(const PrtoStel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoStel& default_instance();

  void Swap(PrtoStel* other);

  // implements Message ----------------------------------------------

  PrtoStel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoStel& from);
  void MergeFrom(const PrtoStel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 iVcount = 1;
  inline bool has_ivcount() const;
  inline void clear_ivcount();
  static const int kIVcountFieldNumber = 1;
  inline ::google::protobuf::int64 ivcount() const;
  inline void set_ivcount(::google::protobuf::int64 value);

  // required int32 iVmeandelay = 2;
  inline bool has_ivmeandelay() const;
  inline void clear_ivmeandelay();
  static const int kIVmeandelayFieldNumber = 2;
  inline ::google::protobuf::int32 ivmeandelay() const;
  inline void set_ivmeandelay(::google::protobuf::int32 value);

  // required int32 iVworstdelay = 3;
  inline bool has_ivworstdelay() const;
  inline void clear_ivworstdelay();
  static const int kIVworstdelayFieldNumber = 3;
  inline ::google::protobuf::int32 ivworstdelay() const;
  inline void set_ivworstdelay(::google::protobuf::int32 value);

  // required int64 iVsize = 4;
  inline bool has_ivsize() const;
  inline void clear_ivsize();
  static const int kIVsizeFieldNumber = 4;
  inline ::google::protobuf::int64 ivsize() const;
  inline void set_ivsize(::google::protobuf::int64 value);

  // optional int64 iVelapsed = 5;
  inline bool has_ivelapsed() const;
  inline void clear_ivelapsed();
  static const int kIVelapsedFieldNumber = 5;
  inline ::google::protobuf::int64 ivelapsed() const;
  inline void set_ivelapsed(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoStel)
 private:
  inline void set_has_ivcount();
  inline void clear_has_ivcount();
  inline void set_has_ivmeandelay();
  inline void clear_has_ivmeandelay();
  inline void set_has_ivworstdelay();
  inline void clear_has_ivworstdelay();
  inline void set_has_ivsize();
  inline void clear_has_ivsize();
  inline void set_has_ivelapsed();
  inline void clear_has_ivelapsed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 ivcount_;
  ::google::protobuf::int32 ivmeandelay_;
  ::google::protobuf::int32 ivworstdelay_;
  ::google::protobuf::int64 ivsize_;
  ::google::protobuf::int64 ivelapsed_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoStel* default_instance_;
};
// -------------------------------------------------------------------

class PrtoTlel : public ::google::protobuf::Message {
 public:
  PrtoTlel();
  virtual ~PrtoTlel();

  PrtoTlel(const PrtoTlel& from);

  inline PrtoTlel& operator=(const PrtoTlel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoTlel& default_instance();

  void Swap(PrtoTlel* other);

  // implements Message ----------------------------------------------

  PrtoTlel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoTlel& from);
  void MergeFrom(const PrtoTlel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCtablettype iVtablettype = 1;
  inline bool has_ivtablettype() const;
  inline void clear_ivtablettype();
  static const int kIVtablettypeFieldNumber = 1;
  inline ::com::tomting::orion::iCtablettype ivtablettype() const;
  inline void set_ivtablettype(::com::tomting::orion::iCtablettype value);

  // required bytes sVname = 2;
  inline bool has_svname() const;
  inline void clear_svname();
  static const int kSVnameFieldNumber = 2;
  inline const ::std::string& svname() const;
  inline void set_svname(const ::std::string& value);
  inline void set_svname(const char* value);
  inline void set_svname(const void* value, size_t size);
  inline ::std::string* mutable_svname();
  inline ::std::string* release_svname();
  inline void set_allocated_svname(::std::string* svname);

  // required bool bVvalid = 3;
  inline bool has_bvvalid() const;
  inline void clear_bvvalid();
  static const int kBVvalidFieldNumber = 3;
  inline bool bvvalid() const;
  inline void set_bvvalid(bool value);

  // required bool bVneedcompaction = 4;
  inline bool has_bvneedcompaction() const;
  inline void clear_bvneedcompaction();
  static const int kBVneedcompactionFieldNumber = 4;
  inline bool bvneedcompaction() const;
  inline void set_bvneedcompaction(bool value);

  // required bool bVvalidasmemorytable = 5;
  inline bool has_bvvalidasmemorytable() const;
  inline void clear_bvvalidasmemorytable();
  static const int kBVvalidasmemorytableFieldNumber = 5;
  inline bool bvvalidasmemorytable() const;
  inline void set_bvvalidasmemorytable(bool value);

  // required int32 iVcompactionlevel = 6;
  inline bool has_ivcompactionlevel() const;
  inline void clear_ivcompactionlevel();
  static const int kIVcompactionlevelFieldNumber = 6;
  inline ::google::protobuf::int32 ivcompactionlevel() const;
  inline void set_ivcompactionlevel(::google::protobuf::int32 value);

  // required bytes sVmemorytable = 7;
  inline bool has_svmemorytable() const;
  inline void clear_svmemorytable();
  static const int kSVmemorytableFieldNumber = 7;
  inline const ::std::string& svmemorytable() const;
  inline void set_svmemorytable(const ::std::string& value);
  inline void set_svmemorytable(const char* value);
  inline void set_svmemorytable(const void* value, size_t size);
  inline ::std::string* mutable_svmemorytable();
  inline ::std::string* release_svmemorytable();
  inline void set_allocated_svmemorytable(::std::string* svmemorytable);

  // required int64 iVres = 8;
  inline bool has_ivres() const;
  inline void clear_ivres();
  static const int kIVresFieldNumber = 8;
  inline ::google::protobuf::int64 ivres() const;
  inline void set_ivres(::google::protobuf::int64 value);

  // required int64 iVmapped = 9;
  inline bool has_ivmapped() const;
  inline void clear_ivmapped();
  static const int kIVmappedFieldNumber = 9;
  inline ::google::protobuf::int64 ivmapped() const;
  inline void set_ivmapped(::google::protobuf::int64 value);

  // required int64 iVsize = 10;
  inline bool has_ivsize() const;
  inline void clear_ivsize();
  static const int kIVsizeFieldNumber = 10;
  inline ::google::protobuf::int64 ivsize() const;
  inline void set_ivsize(::google::protobuf::int64 value);

  // required int64 iVcount = 11;
  inline bool has_ivcount() const;
  inline void clear_ivcount();
  static const int kIVcountFieldNumber = 11;
  inline ::google::protobuf::int64 ivcount() const;
  inline void set_ivcount(::google::protobuf::int64 value);

  // required bytes sVredotimestamp = 12;
  inline bool has_svredotimestamp() const;
  inline void clear_svredotimestamp();
  static const int kSVredotimestampFieldNumber = 12;
  inline const ::std::string& svredotimestamp() const;
  inline void set_svredotimestamp(const ::std::string& value);
  inline void set_svredotimestamp(const char* value);
  inline void set_svredotimestamp(const void* value, size_t size);
  inline ::std::string* mutable_svredotimestamp();
  inline ::std::string* release_svredotimestamp();
  inline void set_allocated_svredotimestamp(::std::string* svredotimestamp);

  // required int32 iVsstabletype = 13;
  inline bool has_ivsstabletype() const;
  inline void clear_ivsstabletype();
  static const int kIVsstabletypeFieldNumber = 13;
  inline ::google::protobuf::int32 ivsstabletype() const;
  inline void set_ivsstabletype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoTlel)
 private:
  inline void set_has_ivtablettype();
  inline void clear_has_ivtablettype();
  inline void set_has_svname();
  inline void clear_has_svname();
  inline void set_has_bvvalid();
  inline void clear_has_bvvalid();
  inline void set_has_bvneedcompaction();
  inline void clear_has_bvneedcompaction();
  inline void set_has_bvvalidasmemorytable();
  inline void clear_has_bvvalidasmemorytable();
  inline void set_has_ivcompactionlevel();
  inline void clear_has_ivcompactionlevel();
  inline void set_has_svmemorytable();
  inline void clear_has_svmemorytable();
  inline void set_has_ivres();
  inline void clear_has_ivres();
  inline void set_has_ivmapped();
  inline void clear_has_ivmapped();
  inline void set_has_ivsize();
  inline void clear_has_ivsize();
  inline void set_has_ivcount();
  inline void clear_has_ivcount();
  inline void set_has_svredotimestamp();
  inline void clear_has_svredotimestamp();
  inline void set_has_ivsstabletype();
  inline void clear_has_ivsstabletype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svname_;
  int ivtablettype_;
  bool bvvalid_;
  bool bvneedcompaction_;
  bool bvvalidasmemorytable_;
  ::std::string* svmemorytable_;
  ::google::protobuf::int64 ivres_;
  ::google::protobuf::int64 ivmapped_;
  ::google::protobuf::int32 ivcompactionlevel_;
  ::google::protobuf::int32 ivsstabletype_;
  ::google::protobuf::int64 ivsize_;
  ::google::protobuf::int64 ivcount_;
  ::std::string* svredotimestamp_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoTlel* default_instance_;
};
// -------------------------------------------------------------------

class PrtoTabl : public ::google::protobuf::Message {
 public:
  PrtoTabl();
  virtual ~PrtoTabl();

  PrtoTabl(const PrtoTabl& from);

  inline PrtoTabl& operator=(const PrtoTabl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoTabl& default_instance();

  void Swap(PrtoTabl* other);

  // implements Message ----------------------------------------------

  PrtoTabl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoTabl& from);
  void MergeFrom(const PrtoTabl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVxml = 1;
  inline bool has_svxml() const;
  inline void clear_svxml();
  static const int kSVxmlFieldNumber = 1;
  inline const ::std::string& svxml() const;
  inline void set_svxml(const ::std::string& value);
  inline void set_svxml(const char* value);
  inline void set_svxml(const void* value, size_t size);
  inline ::std::string* mutable_svxml();
  inline ::std::string* release_svxml();
  inline void set_allocated_svxml(::std::string* svxml);

  // repeated .com.tomting.orion.PrtoPtel cVpartitionedelements = 2;
  inline int cvpartitionedelements_size() const;
  inline void clear_cvpartitionedelements();
  static const int kCVpartitionedelementsFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoPtel& cvpartitionedelements(int index) const;
  inline ::com::tomting::orion::PrtoPtel* mutable_cvpartitionedelements(int index);
  inline ::com::tomting::orion::PrtoPtel* add_cvpartitionedelements();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >&
      cvpartitionedelements() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >*
      mutable_cvpartitionedelements();

  // repeated .com.tomting.orion.PrtoPtel cVpartitionedindexelements = 3;
  inline int cvpartitionedindexelements_size() const;
  inline void clear_cvpartitionedindexelements();
  static const int kCVpartitionedindexelementsFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoPtel& cvpartitionedindexelements(int index) const;
  inline ::com::tomting::orion::PrtoPtel* mutable_cvpartitionedindexelements(int index);
  inline ::com::tomting::orion::PrtoPtel* add_cvpartitionedindexelements();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >&
      cvpartitionedindexelements() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >*
      mutable_cvpartitionedindexelements();

  // repeated .com.tomting.orion.PrtoTlel cVtabletelement = 4;
  inline int cvtabletelement_size() const;
  inline void clear_cvtabletelement();
  static const int kCVtabletelementFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoTlel& cvtabletelement(int index) const;
  inline ::com::tomting::orion::PrtoTlel* mutable_cvtabletelement(int index);
  inline ::com::tomting::orion::PrtoTlel* add_cvtabletelement();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >&
      cvtabletelement() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >*
      mutable_cvtabletelement();

  // repeated .com.tomting.orion.PrtoTlel cVindextabletelement = 5;
  inline int cvindextabletelement_size() const;
  inline void clear_cvindextabletelement();
  static const int kCVindextabletelementFieldNumber = 5;
  inline const ::com::tomting::orion::PrtoTlel& cvindextabletelement(int index) const;
  inline ::com::tomting::orion::PrtoTlel* mutable_cvindextabletelement(int index);
  inline ::com::tomting::orion::PrtoTlel* add_cvindextabletelement();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >&
      cvindextabletelement() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >*
      mutable_cvindextabletelement();

  // optional bytes sVjoincustompartition = 6;
  inline bool has_svjoincustompartition() const;
  inline void clear_svjoincustompartition();
  static const int kSVjoincustompartitionFieldNumber = 6;
  inline const ::std::string& svjoincustompartition() const;
  inline void set_svjoincustompartition(const ::std::string& value);
  inline void set_svjoincustompartition(const char* value);
  inline void set_svjoincustompartition(const void* value, size_t size);
  inline ::std::string* mutable_svjoincustompartition();
  inline ::std::string* release_svjoincustompartition();
  inline void set_allocated_svjoincustompartition(::std::string* svjoincustompartition);

  // optional bytes sVjoincustompartitionindex = 7;
  inline bool has_svjoincustompartitionindex() const;
  inline void clear_svjoincustompartitionindex();
  static const int kSVjoincustompartitionindexFieldNumber = 7;
  inline const ::std::string& svjoincustompartitionindex() const;
  inline void set_svjoincustompartitionindex(const ::std::string& value);
  inline void set_svjoincustompartitionindex(const char* value);
  inline void set_svjoincustompartitionindex(const void* value, size_t size);
  inline ::std::string* mutable_svjoincustompartitionindex();
  inline ::std::string* release_svjoincustompartitionindex();
  inline void set_allocated_svjoincustompartitionindex(::std::string* svjoincustompartitionindex);

  // optional bytes sVpartitiontype = 8;
  inline bool has_svpartitiontype() const;
  inline void clear_svpartitiontype();
  static const int kSVpartitiontypeFieldNumber = 8;
  inline const ::std::string& svpartitiontype() const;
  inline void set_svpartitiontype(const ::std::string& value);
  inline void set_svpartitiontype(const char* value);
  inline void set_svpartitiontype(const void* value, size_t size);
  inline ::std::string* mutable_svpartitiontype();
  inline ::std::string* release_svpartitiontype();
  inline void set_allocated_svpartitiontype(::std::string* svpartitiontype);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoTabl)
 private:
  inline void set_has_svxml();
  inline void clear_has_svxml();
  inline void set_has_svjoincustompartition();
  inline void clear_has_svjoincustompartition();
  inline void set_has_svjoincustompartitionindex();
  inline void clear_has_svjoincustompartitionindex();
  inline void set_has_svpartitiontype();
  inline void clear_has_svpartitiontype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svxml_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel > cvpartitionedelements_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel > cvpartitionedindexelements_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel > cvtabletelement_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel > cvindextabletelement_;
  ::std::string* svjoincustompartition_;
  ::std::string* svjoincustompartitionindex_;
  ::std::string* svpartitiontype_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoTabl* default_instance_;
};
// -------------------------------------------------------------------

class PrtoAenp : public ::google::protobuf::Message {
 public:
  PrtoAenp();
  virtual ~PrtoAenp();

  PrtoAenp(const PrtoAenp& from);

  inline PrtoAenp& operator=(const PrtoAenp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoAenp& default_instance();

  void Swap(PrtoAenp* other);

  // implements Message ----------------------------------------------

  PrtoAenp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoAenp& from);
  void MergeFrom(const PrtoAenp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVopaquedata = 1;
  inline bool has_svopaquedata() const;
  inline void clear_svopaquedata();
  static const int kSVopaquedataFieldNumber = 1;
  inline const ::std::string& svopaquedata() const;
  inline void set_svopaquedata(const ::std::string& value);
  inline void set_svopaquedata(const char* value);
  inline void set_svopaquedata(const void* value, size_t size);
  inline ::std::string* mutable_svopaquedata();
  inline ::std::string* release_svopaquedata();
  inline void set_allocated_svopaquedata(::std::string* svopaquedata);

  // optional bytes sVnodeid = 2;
  inline bool has_svnodeid() const;
  inline void clear_svnodeid();
  static const int kSVnodeidFieldNumber = 2;
  inline const ::std::string& svnodeid() const;
  inline void set_svnodeid(const ::std::string& value);
  inline void set_svnodeid(const char* value);
  inline void set_svnodeid(const void* value, size_t size);
  inline ::std::string* mutable_svnodeid();
  inline ::std::string* release_svnodeid();
  inline void set_allocated_svnodeid(::std::string* svnodeid);

  // optional .com.tomting.orion.PrtoLmtb cVmutable = 3;
  inline bool has_cvmutable() const;
  inline void clear_cvmutable();
  static const int kCVmutableFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoLmtb& cvmutable() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvmutable();
  inline ::com::tomting::orion::PrtoLmtb* release_cvmutable();
  inline void set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable);

  // optional bytes sVkeystart = 4;
  inline bool has_svkeystart() const;
  inline void clear_svkeystart();
  static const int kSVkeystartFieldNumber = 4;
  inline const ::std::string& svkeystart() const;
  inline void set_svkeystart(const ::std::string& value);
  inline void set_svkeystart(const char* value);
  inline void set_svkeystart(const void* value, size_t size);
  inline ::std::string* mutable_svkeystart();
  inline ::std::string* release_svkeystart();
  inline void set_allocated_svkeystart(::std::string* svkeystart);

  // optional int32 iVlimitsize = 5;
  inline bool has_ivlimitsize() const;
  inline void clear_ivlimitsize();
  static const int kIVlimitsizeFieldNumber = 5;
  inline ::google::protobuf::int32 ivlimitsize() const;
  inline void set_ivlimitsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoAenp)
 private:
  inline void set_has_svopaquedata();
  inline void clear_has_svopaquedata();
  inline void set_has_svnodeid();
  inline void clear_has_svnodeid();
  inline void set_has_cvmutable();
  inline void clear_has_cvmutable();
  inline void set_has_svkeystart();
  inline void clear_has_svkeystart();
  inline void set_has_ivlimitsize();
  inline void clear_has_ivlimitsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svopaquedata_;
  ::std::string* svnodeid_;
  ::com::tomting::orion::PrtoLmtb* cvmutable_;
  ::std::string* svkeystart_;
  ::google::protobuf::int32 ivlimitsize_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoAenp* default_instance_;
};
// -------------------------------------------------------------------

class PrtoTope : public ::google::protobuf::Message {
 public:
  PrtoTope();
  virtual ~PrtoTope();

  PrtoTope(const PrtoTope& from);

  inline PrtoTope& operator=(const PrtoTope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoTope& default_instance();

  void Swap(PrtoTope* other);

  // implements Message ----------------------------------------------

  PrtoTope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoTope& from);
  void MergeFrom(const PrtoTope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVtablet = 1;
  inline bool has_svtablet() const;
  inline void clear_svtablet();
  static const int kSVtabletFieldNumber = 1;
  inline const ::std::string& svtablet() const;
  inline void set_svtablet(const ::std::string& value);
  inline void set_svtablet(const char* value);
  inline void set_svtablet(const void* value, size_t size);
  inline ::std::string* mutable_svtablet();
  inline ::std::string* release_svtablet();
  inline void set_allocated_svtablet(::std::string* svtablet);

  // optional int64 iVreadtime = 2;
  inline bool has_ivreadtime() const;
  inline void clear_ivreadtime();
  static const int kIVreadtimeFieldNumber = 2;
  inline ::google::protobuf::int64 ivreadtime() const;
  inline void set_ivreadtime(::google::protobuf::int64 value);

  // optional int64 iVwritetime = 3;
  inline bool has_ivwritetime() const;
  inline void clear_ivwritetime();
  static const int kIVwritetimeFieldNumber = 3;
  inline ::google::protobuf::int64 ivwritetime() const;
  inline void set_ivwritetime(::google::protobuf::int64 value);

  // optional int64 iVreadcountl2 = 4;
  inline bool has_ivreadcountl2() const;
  inline void clear_ivreadcountl2();
  static const int kIVreadcountl2FieldNumber = 4;
  inline ::google::protobuf::int64 ivreadcountl2() const;
  inline void set_ivreadcountl2(::google::protobuf::int64 value);

  // optional int64 iVwritecountl2 = 5;
  inline bool has_ivwritecountl2() const;
  inline void clear_ivwritecountl2();
  static const int kIVwritecountl2FieldNumber = 5;
  inline ::google::protobuf::int64 ivwritecountl2() const;
  inline void set_ivwritecountl2(::google::protobuf::int64 value);

  // optional int64 iVreadcountl1 = 6;
  inline bool has_ivreadcountl1() const;
  inline void clear_ivreadcountl1();
  static const int kIVreadcountl1FieldNumber = 6;
  inline ::google::protobuf::int64 ivreadcountl1() const;
  inline void set_ivreadcountl1(::google::protobuf::int64 value);

  // optional int64 iVwritecountl1 = 7;
  inline bool has_ivwritecountl1() const;
  inline void clear_ivwritecountl1();
  static const int kIVwritecountl1FieldNumber = 7;
  inline ::google::protobuf::int64 ivwritecountl1() const;
  inline void set_ivwritecountl1(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoTope)
 private:
  inline void set_has_svtablet();
  inline void clear_has_svtablet();
  inline void set_has_ivreadtime();
  inline void clear_has_ivreadtime();
  inline void set_has_ivwritetime();
  inline void clear_has_ivwritetime();
  inline void set_has_ivreadcountl2();
  inline void clear_has_ivreadcountl2();
  inline void set_has_ivwritecountl2();
  inline void clear_has_ivwritecountl2();
  inline void set_has_ivreadcountl1();
  inline void clear_has_ivreadcountl1();
  inline void set_has_ivwritecountl1();
  inline void clear_has_ivwritecountl1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svtablet_;
  ::google::protobuf::int64 ivreadtime_;
  ::google::protobuf::int64 ivwritetime_;
  ::google::protobuf::int64 ivreadcountl2_;
  ::google::protobuf::int64 ivwritecountl2_;
  ::google::protobuf::int64 ivreadcountl1_;
  ::google::protobuf::int64 ivwritecountl1_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoTope* default_instance_;
};
// -------------------------------------------------------------------

class PrtoTop_ : public ::google::protobuf::Message {
 public:
  PrtoTop_();
  virtual ~PrtoTop_();

  PrtoTop_(const PrtoTop_& from);

  inline PrtoTop_& operator=(const PrtoTop_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoTop_& default_instance();

  void Swap(PrtoTop_* other);

  // implements Message ----------------------------------------------

  PrtoTop_* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoTop_& from);
  void MergeFrom(const PrtoTop_& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 iVtimestamp = 1;
  inline bool has_ivtimestamp() const;
  inline void clear_ivtimestamp();
  static const int kIVtimestampFieldNumber = 1;
  inline ::google::protobuf::int64 ivtimestamp() const;
  inline void set_ivtimestamp(::google::protobuf::int64 value);

  // repeated .com.tomting.orion.PrtoTope cVtopelement = 2;
  inline int cvtopelement_size() const;
  inline void clear_cvtopelement();
  static const int kCVtopelementFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoTope& cvtopelement(int index) const;
  inline ::com::tomting::orion::PrtoTope* mutable_cvtopelement(int index);
  inline ::com::tomting::orion::PrtoTope* add_cvtopelement();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTope >&
      cvtopelement() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTope >*
      mutable_cvtopelement();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoTop_)
 private:
  inline void set_has_ivtimestamp();
  inline void clear_has_ivtimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 ivtimestamp_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTope > cvtopelement_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoTop_* default_instance_;
};
// -------------------------------------------------------------------

class PrtoSrvc : public ::google::protobuf::Message {
 public:
  PrtoSrvc();
  virtual ~PrtoSrvc();

  PrtoSrvc(const PrtoSrvc& from);

  inline PrtoSrvc& operator=(const PrtoSrvc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoSrvc& default_instance();

  void Swap(PrtoSrvc* other);

  // implements Message ----------------------------------------------

  PrtoSrvc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoSrvc& from);
  void MergeFrom(const PrtoSrvc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCservicetype iVservicetype = 1;
  inline bool has_ivservicetype() const;
  inline void clear_ivservicetype();
  static const int kIVservicetypeFieldNumber = 1;
  inline ::com::tomting::orion::iCservicetype ivservicetype() const;
  inline void set_ivservicetype(::com::tomting::orion::iCservicetype value);

  // optional .com.tomting.orion.PrtoL2qr cVquery = 2;
  inline bool has_cvquery() const;
  inline void clear_cvquery();
  static const int kCVqueryFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL2qr& cvquery() const;
  inline ::com::tomting::orion::PrtoL2qr* mutable_cvquery();
  inline ::com::tomting::orion::PrtoL2qr* release_cvquery();
  inline void set_allocated_cvquery(::com::tomting::orion::PrtoL2qr* cvquery);

  // optional .com.tomting.orion.PrtoL2st cVstatement = 3;
  inline bool has_cvstatement() const;
  inline void clear_cvstatement();
  static const int kCVstatementFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2st& cvstatement() const;
  inline ::com::tomting::orion::PrtoL2st* mutable_cvstatement();
  inline ::com::tomting::orion::PrtoL2st* release_cvstatement();
  inline void set_allocated_cvstatement(::com::tomting::orion::PrtoL2st* cvstatement);

  // optional .com.tomting.orion.PrtoL2os cVosql = 4;
  inline bool has_cvosql() const;
  inline void clear_cvosql();
  static const int kCVosqlFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoL2os& cvosql() const;
  inline ::com::tomting::orion::PrtoL2os* mutable_cvosql();
  inline ::com::tomting::orion::PrtoL2os* release_cvosql();
  inline void set_allocated_cvosql(::com::tomting::orion::PrtoL2os* cvosql);

  // optional .com.tomting.orion.PrtoLstm cVstatementL1 = 5;
  inline bool has_cvstatementl1() const;
  inline void clear_cvstatementl1();
  static const int kCVstatementL1FieldNumber = 5;
  inline const ::com::tomting::orion::PrtoLstm& cvstatementl1() const;
  inline ::com::tomting::orion::PrtoLstm* mutable_cvstatementl1();
  inline ::com::tomting::orion::PrtoLstm* release_cvstatementl1();
  inline void set_allocated_cvstatementl1(::com::tomting::orion::PrtoLstm* cvstatementl1);

  // optional .com.tomting.orion.PrtoLqry cVqueryL1 = 6;
  inline bool has_cvqueryl1() const;
  inline void clear_cvqueryl1();
  static const int kCVqueryL1FieldNumber = 6;
  inline const ::com::tomting::orion::PrtoLqry& cvqueryl1() const;
  inline ::com::tomting::orion::PrtoLqry* mutable_cvqueryl1();
  inline ::com::tomting::orion::PrtoLqry* release_cvqueryl1();
  inline void set_allocated_cvqueryl1(::com::tomting::orion::PrtoLqry* cvqueryl1);

  // optional .com.tomting.orion.PrtoLmtb cVdmlL1 = 7;
  inline bool has_cvdmll1() const;
  inline void clear_cvdmll1();
  static const int kCVdmlL1FieldNumber = 7;
  inline const ::com::tomting::orion::PrtoLmtb& cvdmll1() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvdmll1();
  inline ::com::tomting::orion::PrtoLmtb* release_cvdmll1();
  inline void set_allocated_cvdmll1(::com::tomting::orion::PrtoLmtb* cvdmll1);

  // optional .com.tomting.orion.PrtoL2ct cVdmlL2 = 8;
  inline bool has_cvdmll2() const;
  inline void clear_cvdmll2();
  static const int kCVdmlL2FieldNumber = 8;
  inline const ::com::tomting::orion::PrtoL2ct& cvdmll2() const;
  inline ::com::tomting::orion::PrtoL2ct* mutable_cvdmll2();
  inline ::com::tomting::orion::PrtoL2ct* release_cvdmll2();
  inline void set_allocated_cvdmll2(::com::tomting::orion::PrtoL2ct* cvdmll2);

  // optional bool bVoptimizewriteindex = 9;
  inline bool has_bvoptimizewriteindex() const;
  inline void clear_bvoptimizewriteindex();
  static const int kBVoptimizewriteindexFieldNumber = 9;
  inline bool bvoptimizewriteindex() const;
  inline void set_bvoptimizewriteindex(bool value);

  // optional bool bVupdateonlyindex = 10;
  inline bool has_bvupdateonlyindex() const;
  inline void clear_bvupdateonlyindex();
  static const int kBVupdateonlyindexFieldNumber = 10;
  inline bool bvupdateonlyindex() const;
  inline void set_bvupdateonlyindex(bool value);

  // optional bool bVlocalfilter = 11;
  inline bool has_bvlocalfilter() const;
  inline void clear_bvlocalfilter();
  static const int kBVlocalfilterFieldNumber = 11;
  inline bool bvlocalfilter() const;
  inline void set_bvlocalfilter(bool value);

  // optional bool bVenabletimestamp = 12;
  inline bool has_bvenabletimestamp() const;
  inline void clear_bvenabletimestamp();
  static const int kBVenabletimestampFieldNumber = 12;
  inline bool bvenabletimestamp() const;
  inline void set_bvenabletimestamp(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoSrvc)
 private:
  inline void set_has_ivservicetype();
  inline void clear_has_ivservicetype();
  inline void set_has_cvquery();
  inline void clear_has_cvquery();
  inline void set_has_cvstatement();
  inline void clear_has_cvstatement();
  inline void set_has_cvosql();
  inline void clear_has_cvosql();
  inline void set_has_cvstatementl1();
  inline void clear_has_cvstatementl1();
  inline void set_has_cvqueryl1();
  inline void clear_has_cvqueryl1();
  inline void set_has_cvdmll1();
  inline void clear_has_cvdmll1();
  inline void set_has_cvdmll2();
  inline void clear_has_cvdmll2();
  inline void set_has_bvoptimizewriteindex();
  inline void clear_has_bvoptimizewriteindex();
  inline void set_has_bvupdateonlyindex();
  inline void clear_has_bvupdateonlyindex();
  inline void set_has_bvlocalfilter();
  inline void clear_has_bvlocalfilter();
  inline void set_has_bvenabletimestamp();
  inline void clear_has_bvenabletimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoL2qr* cvquery_;
  ::com::tomting::orion::PrtoL2st* cvstatement_;
  ::com::tomting::orion::PrtoL2os* cvosql_;
  ::com::tomting::orion::PrtoLstm* cvstatementl1_;
  ::com::tomting::orion::PrtoLqry* cvqueryl1_;
  ::com::tomting::orion::PrtoLmtb* cvdmll1_;
  ::com::tomting::orion::PrtoL2ct* cvdmll2_;
  int ivservicetype_;
  bool bvoptimizewriteindex_;
  bool bvupdateonlyindex_;
  bool bvlocalfilter_;
  bool bvenabletimestamp_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoSrvc* default_instance_;
};
// -------------------------------------------------------------------

class PrtoSrvr : public ::google::protobuf::Message {
 public:
  PrtoSrvr();
  virtual ~PrtoSrvr();

  PrtoSrvr(const PrtoSrvr& from);

  inline PrtoSrvr& operator=(const PrtoSrvr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoSrvr& default_instance();

  void Swap(PrtoSrvr* other);

  // implements Message ----------------------------------------------

  PrtoSrvr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoSrvr& from);
  void MergeFrom(const PrtoSrvr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bVreturn = 1;
  inline bool has_bvreturn() const;
  inline void clear_bvreturn();
  static const int kBVreturnFieldNumber = 1;
  inline bool bvreturn() const;
  inline void set_bvreturn(bool value);

  // optional .com.tomting.orion.PrtoL2mr cVdmlresult = 2;
  inline bool has_cvdmlresult() const;
  inline void clear_cvdmlresult();
  static const int kCVdmlresultFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL2mr& cvdmlresult() const;
  inline ::com::tomting::orion::PrtoL2mr* mutable_cvdmlresult();
  inline ::com::tomting::orion::PrtoL2mr* release_cvdmlresult();
  inline void set_allocated_cvdmlresult(::com::tomting::orion::PrtoL2mr* cvdmlresult);

  // optional .com.tomting.orion.PrtoL1mr cVsnapshotL1 = 3;
  inline bool has_cvsnapshotl1() const;
  inline void clear_cvsnapshotl1();
  static const int kCVsnapshotL1FieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL1mr& cvsnapshotl1() const;
  inline ::com::tomting::orion::PrtoL1mr* mutable_cvsnapshotl1();
  inline ::com::tomting::orion::PrtoL1mr* release_cvsnapshotl1();
  inline void set_allocated_cvsnapshotl1(::com::tomting::orion::PrtoL1mr* cvsnapshotl1);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoSrvr)
 private:
  inline void set_has_bvreturn();
  inline void clear_has_bvreturn();
  inline void set_has_cvdmlresult();
  inline void clear_has_cvdmlresult();
  inline void set_has_cvsnapshotl1();
  inline void clear_has_cvsnapshotl1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoL2mr* cvdmlresult_;
  ::com::tomting::orion::PrtoL1mr* cvsnapshotl1_;
  bool bvreturn_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoSrvr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoBsrc : public ::google::protobuf::Message {
 public:
  PrtoBsrc();
  virtual ~PrtoBsrc();

  PrtoBsrc(const PrtoBsrc& from);

  inline PrtoBsrc& operator=(const PrtoBsrc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoBsrc& default_instance();

  void Swap(PrtoBsrc* other);

  // implements Message ----------------------------------------------

  PrtoBsrc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoBsrc& from);
  void MergeFrom(const PrtoBsrc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCbulkservicetype iVbulkservicetype = 1;
  inline bool has_ivbulkservicetype() const;
  inline void clear_ivbulkservicetype();
  static const int kIVbulkservicetypeFieldNumber = 1;
  inline ::com::tomting::orion::iCbulkservicetype ivbulkservicetype() const;
  inline void set_ivbulkservicetype(::com::tomting::orion::iCbulkservicetype value);

  // repeated .com.tomting.orion.PrtoSrvc cVbulkproto = 2;
  inline int cvbulkproto_size() const;
  inline void clear_cvbulkproto();
  static const int kCVbulkprotoFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoSrvc& cvbulkproto(int index) const;
  inline ::com::tomting::orion::PrtoSrvc* mutable_cvbulkproto(int index);
  inline ::com::tomting::orion::PrtoSrvc* add_cvbulkproto();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvc >&
      cvbulkproto() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvc >*
      mutable_cvbulkproto();

  // repeated bytes cVbulkstring = 3;
  inline int cvbulkstring_size() const;
  inline void clear_cvbulkstring();
  static const int kCVbulkstringFieldNumber = 3;
  inline const ::std::string& cvbulkstring(int index) const;
  inline ::std::string* mutable_cvbulkstring(int index);
  inline void set_cvbulkstring(int index, const ::std::string& value);
  inline void set_cvbulkstring(int index, const char* value);
  inline void set_cvbulkstring(int index, const void* value, size_t size);
  inline ::std::string* add_cvbulkstring();
  inline void add_cvbulkstring(const ::std::string& value);
  inline void add_cvbulkstring(const char* value);
  inline void add_cvbulkstring(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cvbulkstring() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cvbulkstring();

  // optional .com.tomting.orion.PrtoSrvc cVsingleproto = 4;
  inline bool has_cvsingleproto() const;
  inline void clear_cvsingleproto();
  static const int kCVsingleprotoFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoSrvc& cvsingleproto() const;
  inline ::com::tomting::orion::PrtoSrvc* mutable_cvsingleproto();
  inline ::com::tomting::orion::PrtoSrvc* release_cvsingleproto();
  inline void set_allocated_cvsingleproto(::com::tomting::orion::PrtoSrvc* cvsingleproto);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoBsrc)
 private:
  inline void set_has_ivbulkservicetype();
  inline void clear_has_ivbulkservicetype();
  inline void set_has_cvsingleproto();
  inline void clear_has_cvsingleproto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvc > cvbulkproto_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cvbulkstring_;
  ::com::tomting::orion::PrtoSrvc* cvsingleproto_;
  int ivbulkservicetype_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoBsrc* default_instance_;
};
// -------------------------------------------------------------------

class PrtoBsrr : public ::google::protobuf::Message {
 public:
  PrtoBsrr();
  virtual ~PrtoBsrr();

  PrtoBsrr(const PrtoBsrr& from);

  inline PrtoBsrr& operator=(const PrtoBsrr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoBsrr& default_instance();

  void Swap(PrtoBsrr* other);

  // implements Message ----------------------------------------------

  PrtoBsrr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoBsrr& from);
  void MergeFrom(const PrtoBsrr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.tomting.orion.PrtoSrvr cVbulkproto = 1;
  inline int cvbulkproto_size() const;
  inline void clear_cvbulkproto();
  static const int kCVbulkprotoFieldNumber = 1;
  inline const ::com::tomting::orion::PrtoSrvr& cvbulkproto(int index) const;
  inline ::com::tomting::orion::PrtoSrvr* mutable_cvbulkproto(int index);
  inline ::com::tomting::orion::PrtoSrvr* add_cvbulkproto();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvr >&
      cvbulkproto() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvr >*
      mutable_cvbulkproto();

  // repeated bytes cVbulkstring = 2;
  inline int cvbulkstring_size() const;
  inline void clear_cvbulkstring();
  static const int kCVbulkstringFieldNumber = 2;
  inline const ::std::string& cvbulkstring(int index) const;
  inline ::std::string* mutable_cvbulkstring(int index);
  inline void set_cvbulkstring(int index, const ::std::string& value);
  inline void set_cvbulkstring(int index, const char* value);
  inline void set_cvbulkstring(int index, const void* value, size_t size);
  inline ::std::string* add_cvbulkstring();
  inline void add_cvbulkstring(const ::std::string& value);
  inline void add_cvbulkstring(const char* value);
  inline void add_cvbulkstring(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cvbulkstring() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cvbulkstring();

  // optional .com.tomting.orion.PrtoSrvr cVsingleproto = 3;
  inline bool has_cvsingleproto() const;
  inline void clear_cvsingleproto();
  static const int kCVsingleprotoFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoSrvr& cvsingleproto() const;
  inline ::com::tomting::orion::PrtoSrvr* mutable_cvsingleproto();
  inline ::com::tomting::orion::PrtoSrvr* release_cvsingleproto();
  inline void set_allocated_cvsingleproto(::com::tomting::orion::PrtoSrvr* cvsingleproto);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoBsrr)
 private:
  inline void set_has_cvsingleproto();
  inline void clear_has_cvsingleproto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvr > cvbulkproto_;
  ::google::protobuf::RepeatedPtrField< ::std::string> cvbulkstring_;
  ::com::tomting::orion::PrtoSrvr* cvsingleproto_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoBsrr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIoop : public ::google::protobuf::Message {
 public:
  PrtoIoop();
  virtual ~PrtoIoop();

  PrtoIoop(const PrtoIoop& from);

  inline PrtoIoop& operator=(const PrtoIoop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIoop& default_instance();

  void Swap(PrtoIoop* other);

  // implements Message ----------------------------------------------

  PrtoIoop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIoop& from);
  void MergeFrom(const PrtoIoop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sVlogpath = 1;
  inline bool has_svlogpath() const;
  inline void clear_svlogpath();
  static const int kSVlogpathFieldNumber = 1;
  inline const ::std::string& svlogpath() const;
  inline void set_svlogpath(const ::std::string& value);
  inline void set_svlogpath(const char* value);
  inline void set_svlogpath(const void* value, size_t size);
  inline ::std::string* mutable_svlogpath();
  inline ::std::string* release_svlogpath();
  inline void set_allocated_svlogpath(::std::string* svlogpath);

  // optional bytes sVmasterxml = 2;
  inline bool has_svmasterxml() const;
  inline void clear_svmasterxml();
  static const int kSVmasterxmlFieldNumber = 2;
  inline const ::std::string& svmasterxml() const;
  inline void set_svmasterxml(const ::std::string& value);
  inline void set_svmasterxml(const char* value);
  inline void set_svmasterxml(const void* value, size_t size);
  inline ::std::string* mutable_svmasterxml();
  inline ::std::string* release_svmasterxml();
  inline void set_allocated_svmasterxml(::std::string* svmasterxml);

  // optional bytes sVnodeid = 3;
  inline bool has_svnodeid() const;
  inline void clear_svnodeid();
  static const int kSVnodeidFieldNumber = 3;
  inline const ::std::string& svnodeid() const;
  inline void set_svnodeid(const ::std::string& value);
  inline void set_svnodeid(const char* value);
  inline void set_svnodeid(const void* value, size_t size);
  inline ::std::string* mutable_svnodeid();
  inline ::std::string* release_svnodeid();
  inline void set_allocated_svnodeid(::std::string* svnodeid);

  // optional bytes sVtabletsubpath = 4;
  inline bool has_svtabletsubpath() const;
  inline void clear_svtabletsubpath();
  static const int kSVtabletsubpathFieldNumber = 4;
  inline const ::std::string& svtabletsubpath() const;
  inline void set_svtabletsubpath(const ::std::string& value);
  inline void set_svtabletsubpath(const char* value);
  inline void set_svtabletsubpath(const void* value, size_t size);
  inline ::std::string* mutable_svtabletsubpath();
  inline ::std::string* release_svtabletsubpath();
  inline void set_allocated_svtabletsubpath(::std::string* svtabletsubpath);

  // optional bytes sVredologsubpath = 5;
  inline bool has_svredologsubpath() const;
  inline void clear_svredologsubpath();
  static const int kSVredologsubpathFieldNumber = 5;
  inline const ::std::string& svredologsubpath() const;
  inline void set_svredologsubpath(const ::std::string& value);
  inline void set_svredologsubpath(const char* value);
  inline void set_svredologsubpath(const void* value, size_t size);
  inline ::std::string* mutable_svredologsubpath();
  inline ::std::string* release_svredologsubpath();
  inline void set_allocated_svredologsubpath(::std::string* svredologsubpath);

  // optional bytes sVdatasubpath = 6;
  inline bool has_svdatasubpath() const;
  inline void clear_svdatasubpath();
  static const int kSVdatasubpathFieldNumber = 6;
  inline const ::std::string& svdatasubpath() const;
  inline void set_svdatasubpath(const ::std::string& value);
  inline void set_svdatasubpath(const char* value);
  inline void set_svdatasubpath(const void* value, size_t size);
  inline ::std::string* mutable_svdatasubpath();
  inline ::std::string* release_svdatasubpath();
  inline void set_allocated_svdatasubpath(::std::string* svdatasubpath);

  // optional bytes sVthriftaddress = 7;
  inline bool has_svthriftaddress() const;
  inline void clear_svthriftaddress();
  static const int kSVthriftaddressFieldNumber = 7;
  inline const ::std::string& svthriftaddress() const;
  inline void set_svthriftaddress(const ::std::string& value);
  inline void set_svthriftaddress(const char* value);
  inline void set_svthriftaddress(const void* value, size_t size);
  inline ::std::string* mutable_svthriftaddress();
  inline ::std::string* release_svthriftaddress();
  inline void set_allocated_svthriftaddress(::std::string* svthriftaddress);

  // optional bytes sVthriftgossiperaddress = 8;
  inline bool has_svthriftgossiperaddress() const;
  inline void clear_svthriftgossiperaddress();
  static const int kSVthriftgossiperaddressFieldNumber = 8;
  inline const ::std::string& svthriftgossiperaddress() const;
  inline void set_svthriftgossiperaddress(const ::std::string& value);
  inline void set_svthriftgossiperaddress(const char* value);
  inline void set_svthriftgossiperaddress(const void* value, size_t size);
  inline ::std::string* mutable_svthriftgossiperaddress();
  inline ::std::string* release_svthriftgossiperaddress();
  inline void set_allocated_svthriftgossiperaddress(::std::string* svthriftgossiperaddress);

  // optional int32 iVthriftport = 9;
  inline bool has_ivthriftport() const;
  inline void clear_ivthriftport();
  static const int kIVthriftportFieldNumber = 9;
  inline ::google::protobuf::int32 ivthriftport() const;
  inline void set_ivthriftport(::google::protobuf::int32 value);

  // optional int32 iVthriftgossiperport = 10;
  inline bool has_ivthriftgossiperport() const;
  inline void clear_ivthriftgossiperport();
  static const int kIVthriftgossiperportFieldNumber = 10;
  inline ::google::protobuf::int32 ivthriftgossiperport() const;
  inline void set_ivthriftgossiperport(::google::protobuf::int32 value);

  // optional int32 iVredologdim = 11;
  inline bool has_ivredologdim() const;
  inline void clear_ivredologdim();
  static const int kIVredologdimFieldNumber = 11;
  inline ::google::protobuf::int32 ivredologdim() const;
  inline void set_ivredologdim(::google::protobuf::int32 value);

  // optional int32 iVthriftlisteners = 12;
  inline bool has_ivthriftlisteners() const;
  inline void clear_ivthriftlisteners();
  static const int kIVthriftlistenersFieldNumber = 12;
  inline ::google::protobuf::int32 ivthriftlisteners() const;
  inline void set_ivthriftlisteners(::google::protobuf::int32 value);

  // optional int32 iVmaxcompactionlevel = 13;
  inline bool has_ivmaxcompactionlevel() const;
  inline void clear_ivmaxcompactionlevel();
  static const int kIVmaxcompactionlevelFieldNumber = 13;
  inline ::google::protobuf::int32 ivmaxcompactionlevel() const;
  inline void set_ivmaxcompactionlevel(::google::protobuf::int32 value);

  // optional int32 iVreplicationfactor = 14;
  inline bool has_ivreplicationfactor() const;
  inline void clear_ivreplicationfactor();
  static const int kIVreplicationfactorFieldNumber = 14;
  inline ::google::protobuf::int32 ivreplicationfactor() const;
  inline void set_ivreplicationfactor(::google::protobuf::int32 value);

  // optional bool bVerrorifexists = 15;
  inline bool has_bverrorifexists() const;
  inline void clear_bverrorifexists();
  static const int kBVerrorifexistsFieldNumber = 15;
  inline bool bverrorifexists() const;
  inline void set_bverrorifexists(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIoop)
 private:
  inline void set_has_svlogpath();
  inline void clear_has_svlogpath();
  inline void set_has_svmasterxml();
  inline void clear_has_svmasterxml();
  inline void set_has_svnodeid();
  inline void clear_has_svnodeid();
  inline void set_has_svtabletsubpath();
  inline void clear_has_svtabletsubpath();
  inline void set_has_svredologsubpath();
  inline void clear_has_svredologsubpath();
  inline void set_has_svdatasubpath();
  inline void clear_has_svdatasubpath();
  inline void set_has_svthriftaddress();
  inline void clear_has_svthriftaddress();
  inline void set_has_svthriftgossiperaddress();
  inline void clear_has_svthriftgossiperaddress();
  inline void set_has_ivthriftport();
  inline void clear_has_ivthriftport();
  inline void set_has_ivthriftgossiperport();
  inline void clear_has_ivthriftgossiperport();
  inline void set_has_ivredologdim();
  inline void clear_has_ivredologdim();
  inline void set_has_ivthriftlisteners();
  inline void clear_has_ivthriftlisteners();
  inline void set_has_ivmaxcompactionlevel();
  inline void clear_has_ivmaxcompactionlevel();
  inline void set_has_ivreplicationfactor();
  inline void clear_has_ivreplicationfactor();
  inline void set_has_bverrorifexists();
  inline void clear_has_bverrorifexists();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svlogpath_;
  ::std::string* svmasterxml_;
  ::std::string* svnodeid_;
  ::std::string* svtabletsubpath_;
  ::std::string* svredologsubpath_;
  ::std::string* svdatasubpath_;
  ::std::string* svthriftaddress_;
  ::std::string* svthriftgossiperaddress_;
  ::google::protobuf::int32 ivthriftport_;
  ::google::protobuf::int32 ivthriftgossiperport_;
  ::google::protobuf::int32 ivredologdim_;
  ::google::protobuf::int32 ivthriftlisteners_;
  ::google::protobuf::int32 ivmaxcompactionlevel_;
  ::google::protobuf::int32 ivreplicationfactor_;
  bool bverrorifexists_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoIoop* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIwop : public ::google::protobuf::Message {
 public:
  PrtoIwop();
  virtual ~PrtoIwop();

  PrtoIwop(const PrtoIwop& from);

  inline PrtoIwop& operator=(const PrtoIwop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIwop& default_instance();

  void Swap(PrtoIwop* other);

  // implements Message ----------------------------------------------

  PrtoIwop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIwop& from);
  void MergeFrom(const PrtoIwop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCdbleveltype iVlevel = 1;
  inline bool has_ivlevel() const;
  inline void clear_ivlevel();
  static const int kIVlevelFieldNumber = 1;
  inline ::com::tomting::orion::iCdbleveltype ivlevel() const;
  inline void set_ivlevel(::com::tomting::orion::iCdbleveltype value);

  // optional .com.tomting.orion.PrtoLstm cVstatementL1 = 2;
  inline bool has_cvstatementl1() const;
  inline void clear_cvstatementl1();
  static const int kCVstatementL1FieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLstm& cvstatementl1() const;
  inline ::com::tomting::orion::PrtoLstm* mutable_cvstatementl1();
  inline ::com::tomting::orion::PrtoLstm* release_cvstatementl1();
  inline void set_allocated_cvstatementl1(::com::tomting::orion::PrtoLstm* cvstatementl1);

  // optional .com.tomting.orion.PrtoL2st cVstatementL2 = 3;
  inline bool has_cvstatementl2() const;
  inline void clear_cvstatementl2();
  static const int kCVstatementL2FieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2st& cvstatementl2() const;
  inline ::com::tomting::orion::PrtoL2st* mutable_cvstatementl2();
  inline ::com::tomting::orion::PrtoL2st* release_cvstatementl2();
  inline void set_allocated_cvstatementl2(::com::tomting::orion::PrtoL2st* cvstatementl2);

  // optional bool bVoptimizewriteindex = 4;
  inline bool has_bvoptimizewriteindex() const;
  inline void clear_bvoptimizewriteindex();
  static const int kBVoptimizewriteindexFieldNumber = 4;
  inline bool bvoptimizewriteindex() const;
  inline void set_bvoptimizewriteindex(bool value);

  // optional bool bVupdateonlyindex = 5;
  inline bool has_bvupdateonlyindex() const;
  inline void clear_bvupdateonlyindex();
  static const int kBVupdateonlyindexFieldNumber = 5;
  inline bool bvupdateonlyindex() const;
  inline void set_bvupdateonlyindex(bool value);

  // optional bool bVlocalfilter = 6;
  inline bool has_bvlocalfilter() const;
  inline void clear_bvlocalfilter();
  static const int kBVlocalfilterFieldNumber = 6;
  inline bool bvlocalfilter() const;
  inline void set_bvlocalfilter(bool value);

  // optional bool bVenabletimestamp = 7;
  inline bool has_bvenabletimestamp() const;
  inline void clear_bvenabletimestamp();
  static const int kBVenabletimestampFieldNumber = 7;
  inline bool bvenabletimestamp() const;
  inline void set_bvenabletimestamp(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIwop)
 private:
  inline void set_has_ivlevel();
  inline void clear_has_ivlevel();
  inline void set_has_cvstatementl1();
  inline void clear_has_cvstatementl1();
  inline void set_has_cvstatementl2();
  inline void clear_has_cvstatementl2();
  inline void set_has_bvoptimizewriteindex();
  inline void clear_has_bvoptimizewriteindex();
  inline void set_has_bvupdateonlyindex();
  inline void clear_has_bvupdateonlyindex();
  inline void set_has_bvlocalfilter();
  inline void clear_has_bvlocalfilter();
  inline void set_has_bvenabletimestamp();
  inline void clear_has_bvenabletimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLstm* cvstatementl1_;
  ::com::tomting::orion::PrtoL2st* cvstatementl2_;
  int ivlevel_;
  bool bvoptimizewriteindex_;
  bool bvupdateonlyindex_;
  bool bvlocalfilter_;
  bool bvenabletimestamp_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoIwop* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIrop : public ::google::protobuf::Message {
 public:
  PrtoIrop();
  virtual ~PrtoIrop();

  PrtoIrop(const PrtoIrop& from);

  inline PrtoIrop& operator=(const PrtoIrop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIrop& default_instance();

  void Swap(PrtoIrop* other);

  // implements Message ----------------------------------------------

  PrtoIrop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIrop& from);
  void MergeFrom(const PrtoIrop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCdbleveltype iVlevel = 1;
  inline bool has_ivlevel() const;
  inline void clear_ivlevel();
  static const int kIVlevelFieldNumber = 1;
  inline ::com::tomting::orion::iCdbleveltype ivlevel() const;
  inline void set_ivlevel(::com::tomting::orion::iCdbleveltype value);

  // optional .com.tomting.orion.PrtoLqry cVqueryL1 = 2;
  inline bool has_cvqueryl1() const;
  inline void clear_cvqueryl1();
  static const int kCVqueryL1FieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLqry& cvqueryl1() const;
  inline ::com::tomting::orion::PrtoLqry* mutable_cvqueryl1();
  inline ::com::tomting::orion::PrtoLqry* release_cvqueryl1();
  inline void set_allocated_cvqueryl1(::com::tomting::orion::PrtoLqry* cvqueryl1);

  // optional .com.tomting.orion.PrtoL2qr cVqueryL2 = 3;
  inline bool has_cvqueryl2() const;
  inline void clear_cvqueryl2();
  static const int kCVqueryL2FieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2qr& cvqueryl2() const;
  inline ::com::tomting::orion::PrtoL2qr* mutable_cvqueryl2();
  inline ::com::tomting::orion::PrtoL2qr* release_cvqueryl2();
  inline void set_allocated_cvqueryl2(::com::tomting::orion::PrtoL2qr* cvqueryl2);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIrop)
 private:
  inline void set_has_ivlevel();
  inline void clear_has_ivlevel();
  inline void set_has_cvqueryl1();
  inline void clear_has_cvqueryl1();
  inline void set_has_cvqueryl2();
  inline void clear_has_cvqueryl2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLqry* cvqueryl1_;
  ::com::tomting::orion::PrtoL2qr* cvqueryl2_;
  int ivlevel_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoIrop* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIgop : public ::google::protobuf::Message {
 public:
  PrtoIgop();
  virtual ~PrtoIgop();

  PrtoIgop(const PrtoIgop& from);

  inline PrtoIgop& operator=(const PrtoIgop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIgop& default_instance();

  void Swap(PrtoIgop* other);

  // implements Message ----------------------------------------------

  PrtoIgop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIgop& from);
  void MergeFrom(const PrtoIgop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.iCdbleveltype iVlevel = 1;
  inline bool has_ivlevel() const;
  inline void clear_ivlevel();
  static const int kIVlevelFieldNumber = 1;
  inline ::com::tomting::orion::iCdbleveltype ivlevel() const;
  inline void set_ivlevel(::com::tomting::orion::iCdbleveltype value);

  // optional .com.tomting.orion.PrtoLmtb cVdmlL1 = 2;
  inline bool has_cvdmll1() const;
  inline void clear_cvdmll1();
  static const int kCVdmlL1FieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLmtb& cvdmll1() const;
  inline ::com::tomting::orion::PrtoLmtb* mutable_cvdmll1();
  inline ::com::tomting::orion::PrtoLmtb* release_cvdmll1();
  inline void set_allocated_cvdmll1(::com::tomting::orion::PrtoLmtb* cvdmll1);

  // optional .com.tomting.orion.PrtoL2ct cVdmlL2 = 3;
  inline bool has_cvdmll2() const;
  inline void clear_cvdmll2();
  static const int kCVdmlL2FieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2ct& cvdmll2() const;
  inline ::com::tomting::orion::PrtoL2ct* mutable_cvdmll2();
  inline ::com::tomting::orion::PrtoL2ct* release_cvdmll2();
  inline void set_allocated_cvdmll2(::com::tomting::orion::PrtoL2ct* cvdmll2);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIgop)
 private:
  inline void set_has_ivlevel();
  inline void clear_has_ivlevel();
  inline void set_has_cvdmll1();
  inline void clear_has_cvdmll1();
  inline void set_has_cvdmll2();
  inline void clear_has_cvdmll2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoLmtb* cvdmll1_;
  ::com::tomting::orion::PrtoL2ct* cvdmll2_;
  int ivlevel_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoIgop* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIsop : public ::google::protobuf::Message {
 public:
  PrtoIsop();
  virtual ~PrtoIsop();

  PrtoIsop(const PrtoIsop& from);

  inline PrtoIsop& operator=(const PrtoIsop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIsop& default_instance();

  void Swap(PrtoIsop* other);

  // implements Message ----------------------------------------------

  PrtoIsop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIsop& from);
  void MergeFrom(const PrtoIsop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool bVresult = 1;
  inline bool has_bvresult() const;
  inline void clear_bvresult();
  static const int kBVresultFieldNumber = 1;
  inline bool bvresult() const;
  inline void set_bvresult(bool value);

  // optional .com.tomting.orion.PrtoL1mr cVsnapshotL1 = 2;
  inline bool has_cvsnapshotl1() const;
  inline void clear_cvsnapshotl1();
  static const int kCVsnapshotL1FieldNumber = 2;
  inline const ::com::tomting::orion::PrtoL1mr& cvsnapshotl1() const;
  inline ::com::tomting::orion::PrtoL1mr* mutable_cvsnapshotl1();
  inline ::com::tomting::orion::PrtoL1mr* release_cvsnapshotl1();
  inline void set_allocated_cvsnapshotl1(::com::tomting::orion::PrtoL1mr* cvsnapshotl1);

  // optional .com.tomting.orion.PrtoL2mr cVsnapshotL2 = 3;
  inline bool has_cvsnapshotl2() const;
  inline void clear_cvsnapshotl2();
  static const int kCVsnapshotL2FieldNumber = 3;
  inline const ::com::tomting::orion::PrtoL2mr& cvsnapshotl2() const;
  inline ::com::tomting::orion::PrtoL2mr* mutable_cvsnapshotl2();
  inline ::com::tomting::orion::PrtoL2mr* release_cvsnapshotl2();
  inline void set_allocated_cvsnapshotl2(::com::tomting::orion::PrtoL2mr* cvsnapshotl2);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIsop)
 private:
  inline void set_has_bvresult();
  inline void clear_has_bvresult();
  inline void set_has_cvsnapshotl1();
  inline void clear_has_cvsnapshotl1();
  inline void set_has_cvsnapshotl2();
  inline void clear_has_cvsnapshotl2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoL1mr* cvsnapshotl1_;
  ::com::tomting::orion::PrtoL2mr* cvsnapshotl2_;
  bool bvresult_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoIsop* default_instance_;
};
// -------------------------------------------------------------------

class PrtoIqop : public ::google::protobuf::Message {
 public:
  PrtoIqop();
  virtual ~PrtoIqop();

  PrtoIqop(const PrtoIqop& from);

  inline PrtoIqop& operator=(const PrtoIqop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoIqop& default_instance();

  void Swap(PrtoIqop* other);

  // implements Message ----------------------------------------------

  PrtoIqop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoIqop& from);
  void MergeFrom(const PrtoIqop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .com.tomting.orion.PrtoL2os cVosqlL2 = 1;
  inline bool has_cvosqll2() const;
  inline void clear_cvosqll2();
  static const int kCVosqlL2FieldNumber = 1;
  inline const ::com::tomting::orion::PrtoL2os& cvosqll2() const;
  inline ::com::tomting::orion::PrtoL2os* mutable_cvosqll2();
  inline ::com::tomting::orion::PrtoL2os* release_cvosqll2();
  inline void set_allocated_cvosqll2(::com::tomting::orion::PrtoL2os* cvosqll2);

  // optional bool bVenabletimestamp = 2;
  inline bool has_bvenabletimestamp() const;
  inline void clear_bvenabletimestamp();
  static const int kBVenabletimestampFieldNumber = 2;
  inline bool bvenabletimestamp() const;
  inline void set_bvenabletimestamp(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoIqop)
 private:
  inline void set_has_cvosqll2();
  inline void clear_has_cvosqll2();
  inline void set_has_bvenabletimestamp();
  inline void clear_has_bvenabletimestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::tomting::orion::PrtoL2os* cvosqll2_;
  bool bvenabletimestamp_;
  friend void  protobuf_AddDesc_PrtoAlog_2eproto();
  friend void protobuf_AssignDesc_PrtoAlog_2eproto();
  friend void protobuf_ShutdownFile_PrtoAlog_2eproto();

  void InitAsDefaultInstance();
  static PrtoIqop* default_instance_;
};
// ===================================================================


// ===================================================================

// PrtoSsls

// repeated bytes sVlistindex = 1;
inline int PrtoSsls::svlistindex_size() const {
  return svlistindex_.size();
}
inline void PrtoSsls::clear_svlistindex() {
  svlistindex_.Clear();
}
inline const ::std::string& PrtoSsls::svlistindex(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSsls.sVlistindex)
  return svlistindex_.Get(index);
}
inline ::std::string* PrtoSsls::mutable_svlistindex(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSsls.sVlistindex)
  return svlistindex_.Mutable(index);
}
inline void PrtoSsls::set_svlistindex(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSsls.sVlistindex)
  svlistindex_.Mutable(index)->assign(value);
}
inline void PrtoSsls::set_svlistindex(int index, const char* value) {
  svlistindex_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSsls.sVlistindex)
}
inline void PrtoSsls::set_svlistindex(int index, const void* value, size_t size) {
  svlistindex_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSsls.sVlistindex)
}
inline ::std::string* PrtoSsls::add_svlistindex() {
  return svlistindex_.Add();
}
inline void PrtoSsls::add_svlistindex(const ::std::string& value) {
  svlistindex_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoSsls.sVlistindex)
}
inline void PrtoSsls::add_svlistindex(const char* value) {
  svlistindex_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.tomting.orion.PrtoSsls.sVlistindex)
}
inline void PrtoSsls::add_svlistindex(const void* value, size_t size) {
  svlistindex_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.tomting.orion.PrtoSsls.sVlistindex)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrtoSsls::svlistindex() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoSsls.sVlistindex)
  return svlistindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrtoSsls::mutable_svlistindex() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoSsls.sVlistindex)
  return &svlistindex_;
}

// -------------------------------------------------------------------

// PrtoLstr

// optional int32 iVmemtabledim = 1;
inline bool PrtoLstr::has_ivmemtabledim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLstr::set_has_ivmemtabledim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLstr::clear_has_ivmemtabledim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLstr::clear_ivmemtabledim() {
  ivmemtabledim_ = 0;
  clear_has_ivmemtabledim();
}
inline ::google::protobuf::int32 PrtoLstr::ivmemtabledim() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.iVmemtabledim)
  return ivmemtabledim_;
}
inline void PrtoLstr::set_ivmemtabledim(::google::protobuf::int32 value) {
  set_has_ivmemtabledim();
  ivmemtabledim_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.iVmemtabledim)
}

// optional int32 iVmemtablesize = 2;
inline bool PrtoLstr::has_ivmemtablesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLstr::set_has_ivmemtablesize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLstr::clear_has_ivmemtablesize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLstr::clear_ivmemtablesize() {
  ivmemtablesize_ = 0;
  clear_has_ivmemtablesize();
}
inline ::google::protobuf::int32 PrtoLstr::ivmemtablesize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.iVmemtablesize)
  return ivmemtablesize_;
}
inline void PrtoLstr::set_ivmemtablesize(::google::protobuf::int32 value) {
  set_has_ivmemtablesize();
  ivmemtablesize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.iVmemtablesize)
}

// optional int32 iVmemtablechunk = 8;
inline bool PrtoLstr::has_ivmemtablechunk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoLstr::set_has_ivmemtablechunk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoLstr::clear_has_ivmemtablechunk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoLstr::clear_ivmemtablechunk() {
  ivmemtablechunk_ = 0;
  clear_has_ivmemtablechunk();
}
inline ::google::protobuf::int32 PrtoLstr::ivmemtablechunk() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.iVmemtablechunk)
  return ivmemtablechunk_;
}
inline void PrtoLstr::set_ivmemtablechunk(::google::protobuf::int32 value) {
  set_has_ivmemtablechunk();
  ivmemtablechunk_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.iVmemtablechunk)
}

// optional bool bVmemorytable = 3 [default = false];
inline bool PrtoLstr::has_bvmemorytable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoLstr::set_has_bvmemorytable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoLstr::clear_has_bvmemorytable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoLstr::clear_bvmemorytable() {
  bvmemorytable_ = false;
  clear_has_bvmemorytable();
}
inline bool PrtoLstr::bvmemorytable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.bVmemorytable)
  return bvmemorytable_;
}
inline void PrtoLstr::set_bvmemorytable(bool value) {
  set_has_bvmemorytable();
  bvmemorytable_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.bVmemorytable)
}

// optional bool bVvolatiletable = 11 [default = false];
inline bool PrtoLstr::has_bvvolatiletable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoLstr::set_has_bvvolatiletable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoLstr::clear_has_bvvolatiletable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoLstr::clear_bvvolatiletable() {
  bvvolatiletable_ = false;
  clear_has_bvvolatiletable();
}
inline bool PrtoLstr::bvvolatiletable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.bVvolatiletable)
  return bvvolatiletable_;
}
inline void PrtoLstr::set_bvvolatiletable(bool value) {
  set_has_bvvolatiletable();
  bvvolatiletable_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.bVvolatiletable)
}

// optional bool bVlocalindex = 12 [default = false];
inline bool PrtoLstr::has_bvlocalindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoLstr::set_has_bvlocalindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoLstr::clear_has_bvlocalindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoLstr::clear_bvlocalindex() {
  bvlocalindex_ = false;
  clear_has_bvlocalindex();
}
inline bool PrtoLstr::bvlocalindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.bVlocalindex)
  return bvlocalindex_;
}
inline void PrtoLstr::set_bvlocalindex(bool value) {
  set_has_bvlocalindex();
  bvlocalindex_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.bVlocalindex)
}

// optional bool bVfastkey = 14 [default = false];
inline bool PrtoLstr::has_bvfastkey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoLstr::set_has_bvfastkey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoLstr::clear_has_bvfastkey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoLstr::clear_bvfastkey() {
  bvfastkey_ = false;
  clear_has_bvfastkey();
}
inline bool PrtoLstr::bvfastkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.bVfastkey)
  return bvfastkey_;
}
inline void PrtoLstr::set_bvfastkey(bool value) {
  set_has_bvfastkey();
  bvfastkey_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.bVfastkey)
}

// optional bytes sVshardingfrom = 4;
inline bool PrtoLstr::has_svshardingfrom() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoLstr::set_has_svshardingfrom() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoLstr::clear_has_svshardingfrom() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoLstr::clear_svshardingfrom() {
  if (svshardingfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingfrom_->clear();
  }
  clear_has_svshardingfrom();
}
inline const ::std::string& PrtoLstr::svshardingfrom() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.sVshardingfrom)
  return *svshardingfrom_;
}
inline void PrtoLstr::set_svshardingfrom(const ::std::string& value) {
  set_has_svshardingfrom();
  if (svshardingfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingfrom_ = new ::std::string;
  }
  svshardingfrom_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.sVshardingfrom)
}
inline void PrtoLstr::set_svshardingfrom(const char* value) {
  set_has_svshardingfrom();
  if (svshardingfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingfrom_ = new ::std::string;
  }
  svshardingfrom_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLstr.sVshardingfrom)
}
inline void PrtoLstr::set_svshardingfrom(const void* value, size_t size) {
  set_has_svshardingfrom();
  if (svshardingfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingfrom_ = new ::std::string;
  }
  svshardingfrom_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLstr.sVshardingfrom)
}
inline ::std::string* PrtoLstr::mutable_svshardingfrom() {
  set_has_svshardingfrom();
  if (svshardingfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingfrom_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstr.sVshardingfrom)
  return svshardingfrom_;
}
inline ::std::string* PrtoLstr::release_svshardingfrom() {
  clear_has_svshardingfrom();
  if (svshardingfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svshardingfrom_;
    svshardingfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLstr::set_allocated_svshardingfrom(::std::string* svshardingfrom) {
  if (svshardingfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svshardingfrom_;
  }
  if (svshardingfrom) {
    set_has_svshardingfrom();
    svshardingfrom_ = svshardingfrom;
  } else {
    clear_has_svshardingfrom();
    svshardingfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstr.sVshardingfrom)
}

// optional bytes sVshardingto = 5;
inline bool PrtoLstr::has_svshardingto() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PrtoLstr::set_has_svshardingto() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PrtoLstr::clear_has_svshardingto() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PrtoLstr::clear_svshardingto() {
  if (svshardingto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingto_->clear();
  }
  clear_has_svshardingto();
}
inline const ::std::string& PrtoLstr::svshardingto() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.sVshardingto)
  return *svshardingto_;
}
inline void PrtoLstr::set_svshardingto(const ::std::string& value) {
  set_has_svshardingto();
  if (svshardingto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingto_ = new ::std::string;
  }
  svshardingto_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.sVshardingto)
}
inline void PrtoLstr::set_svshardingto(const char* value) {
  set_has_svshardingto();
  if (svshardingto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingto_ = new ::std::string;
  }
  svshardingto_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLstr.sVshardingto)
}
inline void PrtoLstr::set_svshardingto(const void* value, size_t size) {
  set_has_svshardingto();
  if (svshardingto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingto_ = new ::std::string;
  }
  svshardingto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLstr.sVshardingto)
}
inline ::std::string* PrtoLstr::mutable_svshardingto() {
  set_has_svshardingto();
  if (svshardingto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstr.sVshardingto)
  return svshardingto_;
}
inline ::std::string* PrtoLstr::release_svshardingto() {
  clear_has_svshardingto();
  if (svshardingto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svshardingto_;
    svshardingto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLstr::set_allocated_svshardingto(::std::string* svshardingto) {
  if (svshardingto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svshardingto_;
  }
  if (svshardingto) {
    set_has_svshardingto();
    svshardingto_ = svshardingto;
  } else {
    clear_has_svshardingto();
    svshardingto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstr.sVshardingto)
}

// optional bytes sVshardingindexfrom = 6;
inline bool PrtoLstr::has_svshardingindexfrom() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PrtoLstr::set_has_svshardingindexfrom() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PrtoLstr::clear_has_svshardingindexfrom() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PrtoLstr::clear_svshardingindexfrom() {
  if (svshardingindexfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexfrom_->clear();
  }
  clear_has_svshardingindexfrom();
}
inline const ::std::string& PrtoLstr::svshardingindexfrom() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.sVshardingindexfrom)
  return *svshardingindexfrom_;
}
inline void PrtoLstr::set_svshardingindexfrom(const ::std::string& value) {
  set_has_svshardingindexfrom();
  if (svshardingindexfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexfrom_ = new ::std::string;
  }
  svshardingindexfrom_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.sVshardingindexfrom)
}
inline void PrtoLstr::set_svshardingindexfrom(const char* value) {
  set_has_svshardingindexfrom();
  if (svshardingindexfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexfrom_ = new ::std::string;
  }
  svshardingindexfrom_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLstr.sVshardingindexfrom)
}
inline void PrtoLstr::set_svshardingindexfrom(const void* value, size_t size) {
  set_has_svshardingindexfrom();
  if (svshardingindexfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexfrom_ = new ::std::string;
  }
  svshardingindexfrom_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLstr.sVshardingindexfrom)
}
inline ::std::string* PrtoLstr::mutable_svshardingindexfrom() {
  set_has_svshardingindexfrom();
  if (svshardingindexfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexfrom_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstr.sVshardingindexfrom)
  return svshardingindexfrom_;
}
inline ::std::string* PrtoLstr::release_svshardingindexfrom() {
  clear_has_svshardingindexfrom();
  if (svshardingindexfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svshardingindexfrom_;
    svshardingindexfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLstr::set_allocated_svshardingindexfrom(::std::string* svshardingindexfrom) {
  if (svshardingindexfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svshardingindexfrom_;
  }
  if (svshardingindexfrom) {
    set_has_svshardingindexfrom();
    svshardingindexfrom_ = svshardingindexfrom;
  } else {
    clear_has_svshardingindexfrom();
    svshardingindexfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstr.sVshardingindexfrom)
}

// optional bytes sVshardingindexto = 7;
inline bool PrtoLstr::has_svshardingindexto() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PrtoLstr::set_has_svshardingindexto() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PrtoLstr::clear_has_svshardingindexto() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PrtoLstr::clear_svshardingindexto() {
  if (svshardingindexto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexto_->clear();
  }
  clear_has_svshardingindexto();
}
inline const ::std::string& PrtoLstr::svshardingindexto() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.sVshardingindexto)
  return *svshardingindexto_;
}
inline void PrtoLstr::set_svshardingindexto(const ::std::string& value) {
  set_has_svshardingindexto();
  if (svshardingindexto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexto_ = new ::std::string;
  }
  svshardingindexto_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.sVshardingindexto)
}
inline void PrtoLstr::set_svshardingindexto(const char* value) {
  set_has_svshardingindexto();
  if (svshardingindexto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexto_ = new ::std::string;
  }
  svshardingindexto_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLstr.sVshardingindexto)
}
inline void PrtoLstr::set_svshardingindexto(const void* value, size_t size) {
  set_has_svshardingindexto();
  if (svshardingindexto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexto_ = new ::std::string;
  }
  svshardingindexto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLstr.sVshardingindexto)
}
inline ::std::string* PrtoLstr::mutable_svshardingindexto() {
  set_has_svshardingindexto();
  if (svshardingindexto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svshardingindexto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstr.sVshardingindexto)
  return svshardingindexto_;
}
inline ::std::string* PrtoLstr::release_svshardingindexto() {
  clear_has_svshardingindexto();
  if (svshardingindexto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svshardingindexto_;
    svshardingindexto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLstr::set_allocated_svshardingindexto(::std::string* svshardingindexto) {
  if (svshardingindexto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svshardingindexto_;
  }
  if (svshardingindexto) {
    set_has_svshardingindexto();
    svshardingindexto_ = svshardingindexto;
  } else {
    clear_has_svshardingindexto();
    svshardingindexto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstr.sVshardingindexto)
}

// optional .com.tomting.orion.iCpartitiontype iVpartitiontype = 9;
inline bool PrtoLstr::has_ivpartitiontype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PrtoLstr::set_has_ivpartitiontype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PrtoLstr::clear_has_ivpartitiontype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PrtoLstr::clear_ivpartitiontype() {
  ivpartitiontype_ = 0;
  clear_has_ivpartitiontype();
}
inline ::com::tomting::orion::iCpartitiontype PrtoLstr::ivpartitiontype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.iVpartitiontype)
  return static_cast< ::com::tomting::orion::iCpartitiontype >(ivpartitiontype_);
}
inline void PrtoLstr::set_ivpartitiontype(::com::tomting::orion::iCpartitiontype value) {
  assert(::com::tomting::orion::iCpartitiontype_IsValid(value));
  set_has_ivpartitiontype();
  ivpartitiontype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.iVpartitiontype)
}

// optional bool bVrepair = 10 [default = false];
inline bool PrtoLstr::has_bvrepair() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PrtoLstr::set_has_bvrepair() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PrtoLstr::clear_has_bvrepair() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PrtoLstr::clear_bvrepair() {
  bvrepair_ = false;
  clear_has_bvrepair();
}
inline bool PrtoLstr::bvrepair() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.bVrepair)
  return bvrepair_;
}
inline void PrtoLstr::set_bvrepair(bool value) {
  set_has_bvrepair();
  bvrepair_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.bVrepair)
}

// optional int32 iVreplicationfactor = 13 [default = -1];
inline bool PrtoLstr::has_ivreplicationfactor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PrtoLstr::set_has_ivreplicationfactor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PrtoLstr::clear_has_ivreplicationfactor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PrtoLstr::clear_ivreplicationfactor() {
  ivreplicationfactor_ = -1;
  clear_has_ivreplicationfactor();
}
inline ::google::protobuf::int32 PrtoLstr::ivreplicationfactor() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstr.iVreplicationfactor)
  return ivreplicationfactor_;
}
inline void PrtoLstr::set_ivreplicationfactor(::google::protobuf::int32 value) {
  set_has_ivreplicationfactor();
  ivreplicationfactor_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstr.iVreplicationfactor)
}

// -------------------------------------------------------------------

// PrtoLmtb

// required bytes sVnamespace = 1;
inline bool PrtoLmtb::has_svnamespace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLmtb::set_has_svnamespace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLmtb::clear_has_svnamespace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLmtb::clear_svnamespace() {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_->clear();
  }
  clear_has_svnamespace();
}
inline const ::std::string& PrtoLmtb::svnamespace() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLmtb.sVnamespace)
  return *svnamespace_;
}
inline void PrtoLmtb::set_svnamespace(const ::std::string& value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLmtb.sVnamespace)
}
inline void PrtoLmtb::set_svnamespace(const char* value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLmtb.sVnamespace)
}
inline void PrtoLmtb::set_svnamespace(const void* value, size_t size) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLmtb.sVnamespace)
}
inline ::std::string* PrtoLmtb::mutable_svnamespace() {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLmtb.sVnamespace)
  return svnamespace_;
}
inline ::std::string* PrtoLmtb::release_svnamespace() {
  clear_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnamespace_;
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLmtb::set_allocated_svnamespace(::std::string* svnamespace) {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnamespace_;
  }
  if (svnamespace) {
    set_has_svnamespace();
    svnamespace_ = svnamespace;
  } else {
    clear_has_svnamespace();
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLmtb.sVnamespace)
}

// optional bytes sVtable = 2;
inline bool PrtoLmtb::has_svtable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLmtb::set_has_svtable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLmtb::clear_has_svtable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLmtb::clear_svtable() {
  if (svtable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_->clear();
  }
  clear_has_svtable();
}
inline const ::std::string& PrtoLmtb::svtable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLmtb.sVtable)
  return *svtable_;
}
inline void PrtoLmtb::set_svtable(const ::std::string& value) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLmtb.sVtable)
}
inline void PrtoLmtb::set_svtable(const char* value) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLmtb.sVtable)
}
inline void PrtoLmtb::set_svtable(const void* value, size_t size) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLmtb.sVtable)
}
inline ::std::string* PrtoLmtb::mutable_svtable() {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLmtb.sVtable)
  return svtable_;
}
inline ::std::string* PrtoLmtb::release_svtable() {
  clear_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtable_;
    svtable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLmtb::set_allocated_svtable(::std::string* svtable) {
  if (svtable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtable_;
  }
  if (svtable) {
    set_has_svtable();
    svtable_ = svtable;
  } else {
    clear_has_svtable();
    svtable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLmtb.sVtable)
}

// optional .com.tomting.orion.PrtoLstr cVstorage = 3;
inline bool PrtoLmtb::has_cvstorage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoLmtb::set_has_cvstorage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoLmtb::clear_has_cvstorage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoLmtb::clear_cvstorage() {
  if (cvstorage_ != NULL) cvstorage_->::com::tomting::orion::PrtoLstr::Clear();
  clear_has_cvstorage();
}
inline const ::com::tomting::orion::PrtoLstr& PrtoLmtb::cvstorage() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLmtb.cVstorage)
  return cvstorage_ != NULL ? *cvstorage_ : *default_instance_->cvstorage_;
}
inline ::com::tomting::orion::PrtoLstr* PrtoLmtb::mutable_cvstorage() {
  set_has_cvstorage();
  if (cvstorage_ == NULL) cvstorage_ = new ::com::tomting::orion::PrtoLstr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLmtb.cVstorage)
  return cvstorage_;
}
inline ::com::tomting::orion::PrtoLstr* PrtoLmtb::release_cvstorage() {
  clear_has_cvstorage();
  ::com::tomting::orion::PrtoLstr* temp = cvstorage_;
  cvstorage_ = NULL;
  return temp;
}
inline void PrtoLmtb::set_allocated_cvstorage(::com::tomting::orion::PrtoLstr* cvstorage) {
  delete cvstorage_;
  cvstorage_ = cvstorage;
  if (cvstorage) {
    set_has_cvstorage();
  } else {
    clear_has_cvstorage();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLmtb.cVstorage)
}

// -------------------------------------------------------------------

// PrtoLkey

// required bytes sVmain = 1;
inline bool PrtoLkey::has_svmain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLkey::set_has_svmain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLkey::clear_has_svmain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLkey::clear_svmain() {
  if (svmain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmain_->clear();
  }
  clear_has_svmain();
}
inline const ::std::string& PrtoLkey::svmain() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLkey.sVmain)
  return *svmain_;
}
inline void PrtoLkey::set_svmain(const ::std::string& value) {
  set_has_svmain();
  if (svmain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmain_ = new ::std::string;
  }
  svmain_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLkey.sVmain)
}
inline void PrtoLkey::set_svmain(const char* value) {
  set_has_svmain();
  if (svmain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmain_ = new ::std::string;
  }
  svmain_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLkey.sVmain)
}
inline void PrtoLkey::set_svmain(const void* value, size_t size) {
  set_has_svmain();
  if (svmain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmain_ = new ::std::string;
  }
  svmain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLkey.sVmain)
}
inline ::std::string* PrtoLkey::mutable_svmain() {
  set_has_svmain();
  if (svmain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLkey.sVmain)
  return svmain_;
}
inline ::std::string* PrtoLkey::release_svmain() {
  clear_has_svmain();
  if (svmain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svmain_;
    svmain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLkey::set_allocated_svmain(::std::string* svmain) {
  if (svmain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svmain_;
  }
  if (svmain) {
    set_has_svmain();
    svmain_ = svmain;
  } else {
    clear_has_svmain();
    svmain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLkey.sVmain)
}

// optional bytes sVaccessgroup = 2 [default = ""];
inline bool PrtoLkey::has_svaccessgroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLkey::set_has_svaccessgroup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLkey::clear_has_svaccessgroup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLkey::clear_svaccessgroup() {
  if (svaccessgroup_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaccessgroup_->clear();
  }
  clear_has_svaccessgroup();
}
inline const ::std::string& PrtoLkey::svaccessgroup() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLkey.sVaccessgroup)
  return *svaccessgroup_;
}
inline void PrtoLkey::set_svaccessgroup(const ::std::string& value) {
  set_has_svaccessgroup();
  if (svaccessgroup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaccessgroup_ = new ::std::string;
  }
  svaccessgroup_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLkey.sVaccessgroup)
}
inline void PrtoLkey::set_svaccessgroup(const char* value) {
  set_has_svaccessgroup();
  if (svaccessgroup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaccessgroup_ = new ::std::string;
  }
  svaccessgroup_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLkey.sVaccessgroup)
}
inline void PrtoLkey::set_svaccessgroup(const void* value, size_t size) {
  set_has_svaccessgroup();
  if (svaccessgroup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaccessgroup_ = new ::std::string;
  }
  svaccessgroup_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLkey.sVaccessgroup)
}
inline ::std::string* PrtoLkey::mutable_svaccessgroup() {
  set_has_svaccessgroup();
  if (svaccessgroup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaccessgroup_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLkey.sVaccessgroup)
  return svaccessgroup_;
}
inline ::std::string* PrtoLkey::release_svaccessgroup() {
  clear_has_svaccessgroup();
  if (svaccessgroup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svaccessgroup_;
    svaccessgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLkey::set_allocated_svaccessgroup(::std::string* svaccessgroup) {
  if (svaccessgroup_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svaccessgroup_;
  }
  if (svaccessgroup) {
    set_has_svaccessgroup();
    svaccessgroup_ = svaccessgroup;
  } else {
    clear_has_svaccessgroup();
    svaccessgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLkey.sVaccessgroup)
}

// optional bytes sVqualifier = 3 [default = ""];
inline bool PrtoLkey::has_svqualifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoLkey::set_has_svqualifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoLkey::clear_has_svqualifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoLkey::clear_svqualifier() {
  if (svqualifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svqualifier_->clear();
  }
  clear_has_svqualifier();
}
inline const ::std::string& PrtoLkey::svqualifier() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLkey.sVqualifier)
  return *svqualifier_;
}
inline void PrtoLkey::set_svqualifier(const ::std::string& value) {
  set_has_svqualifier();
  if (svqualifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svqualifier_ = new ::std::string;
  }
  svqualifier_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLkey.sVqualifier)
}
inline void PrtoLkey::set_svqualifier(const char* value) {
  set_has_svqualifier();
  if (svqualifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svqualifier_ = new ::std::string;
  }
  svqualifier_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLkey.sVqualifier)
}
inline void PrtoLkey::set_svqualifier(const void* value, size_t size) {
  set_has_svqualifier();
  if (svqualifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svqualifier_ = new ::std::string;
  }
  svqualifier_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLkey.sVqualifier)
}
inline ::std::string* PrtoLkey::mutable_svqualifier() {
  set_has_svqualifier();
  if (svqualifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svqualifier_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLkey.sVqualifier)
  return svqualifier_;
}
inline ::std::string* PrtoLkey::release_svqualifier() {
  clear_has_svqualifier();
  if (svqualifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svqualifier_;
    svqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLkey::set_allocated_svqualifier(::std::string* svqualifier) {
  if (svqualifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svqualifier_;
  }
  if (svqualifier) {
    set_has_svqualifier();
    svqualifier_ = svqualifier;
  } else {
    clear_has_svqualifier();
    svqualifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLkey.sVqualifier)
}

// optional .com.tomting.orion.iCstatetype iVstate = 4 [default = UPSERT];
inline bool PrtoLkey::has_ivstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoLkey::set_has_ivstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoLkey::clear_has_ivstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoLkey::clear_ivstate() {
  ivstate_ = 0;
  clear_has_ivstate();
}
inline ::com::tomting::orion::iCstatetype PrtoLkey::ivstate() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLkey.iVstate)
  return static_cast< ::com::tomting::orion::iCstatetype >(ivstate_);
}
inline void PrtoLkey::set_ivstate(::com::tomting::orion::iCstatetype value) {
  assert(::com::tomting::orion::iCstatetype_IsValid(value));
  set_has_ivstate();
  ivstate_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLkey.iVstate)
}

// optional int64 iVtimestamp = 5 [default = 0];
inline bool PrtoLkey::has_ivtimestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoLkey::set_has_ivtimestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoLkey::clear_has_ivtimestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoLkey::clear_ivtimestamp() {
  ivtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ivtimestamp();
}
inline ::google::protobuf::int64 PrtoLkey::ivtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLkey.iVtimestamp)
  return ivtimestamp_;
}
inline void PrtoLkey::set_ivtimestamp(::google::protobuf::int64 value) {
  set_has_ivtimestamp();
  ivtimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLkey.iVtimestamp)
}

// -------------------------------------------------------------------

// PrtoLval

// required bytes sVopaquevalue = 1;
inline bool PrtoLval::has_svopaquevalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLval::set_has_svopaquevalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLval::clear_has_svopaquevalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLval::clear_svopaquevalue() {
  if (svopaquevalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_->clear();
  }
  clear_has_svopaquevalue();
}
inline const ::std::string& PrtoLval::svopaquevalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLval.sVopaquevalue)
  return *svopaquevalue_;
}
inline void PrtoLval::set_svopaquevalue(const ::std::string& value) {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  svopaquevalue_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLval.sVopaquevalue)
}
inline void PrtoLval::set_svopaquevalue(const char* value) {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  svopaquevalue_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLval.sVopaquevalue)
}
inline void PrtoLval::set_svopaquevalue(const void* value, size_t size) {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  svopaquevalue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLval.sVopaquevalue)
}
inline ::std::string* PrtoLval::mutable_svopaquevalue() {
  set_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquevalue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLval.sVopaquevalue)
  return svopaquevalue_;
}
inline ::std::string* PrtoLval::release_svopaquevalue() {
  clear_has_svopaquevalue();
  if (svopaquevalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svopaquevalue_;
    svopaquevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLval::set_allocated_svopaquevalue(::std::string* svopaquevalue) {
  if (svopaquevalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svopaquevalue_;
  }
  if (svopaquevalue) {
    set_has_svopaquevalue();
    svopaquevalue_ = svopaquevalue;
  } else {
    clear_has_svopaquevalue();
    svopaquevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLval.sVopaquevalue)
}

// required int64 iVtimestamp = 2;
inline bool PrtoLval::has_ivtimestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLval::set_has_ivtimestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLval::clear_has_ivtimestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLval::clear_ivtimestamp() {
  ivtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ivtimestamp();
}
inline ::google::protobuf::int64 PrtoLval::ivtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLval.iVtimestamp)
  return ivtimestamp_;
}
inline void PrtoLval::set_ivtimestamp(::google::protobuf::int64 value) {
  set_has_ivtimestamp();
  ivtimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLval.iVtimestamp)
}

// -------------------------------------------------------------------

// PrtoLstm

// required .com.tomting.orion.iCopcodetype iVopcode = 1;
inline bool PrtoLstm::has_ivopcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLstm::set_has_ivopcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLstm::clear_has_ivopcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLstm::clear_ivopcode() {
  ivopcode_ = 0;
  clear_has_ivopcode();
}
inline ::com::tomting::orion::iCopcodetype PrtoLstm::ivopcode() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstm.iVopcode)
  return static_cast< ::com::tomting::orion::iCopcodetype >(ivopcode_);
}
inline void PrtoLstm::set_ivopcode(::com::tomting::orion::iCopcodetype value) {
  assert(::com::tomting::orion::iCopcodetype_IsValid(value));
  set_has_ivopcode();
  ivopcode_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLstm.iVopcode)
}

// required .com.tomting.orion.PrtoLmtb cVmutable = 2;
inline bool PrtoLstm::has_cvmutable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLstm::set_has_cvmutable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLstm::clear_has_cvmutable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLstm::clear_cvmutable() {
  if (cvmutable_ != NULL) cvmutable_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvmutable();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoLstm::cvmutable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstm.cVmutable)
  return cvmutable_ != NULL ? *cvmutable_ : *default_instance_->cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoLstm::mutable_cvmutable() {
  set_has_cvmutable();
  if (cvmutable_ == NULL) cvmutable_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstm.cVmutable)
  return cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoLstm::release_cvmutable() {
  clear_has_cvmutable();
  ::com::tomting::orion::PrtoLmtb* temp = cvmutable_;
  cvmutable_ = NULL;
  return temp;
}
inline void PrtoLstm::set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable) {
  delete cvmutable_;
  cvmutable_ = cvmutable;
  if (cvmutable) {
    set_has_cvmutable();
  } else {
    clear_has_cvmutable();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstm.cVmutable)
}

// optional .com.tomting.orion.PrtoLkey cVkey = 4;
inline bool PrtoLstm::has_cvkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoLstm::set_has_cvkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoLstm::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoLstm::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoLstm::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstm.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoLstm::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstm.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoLstm::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoLstm::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstm.cVkey)
}

// optional .com.tomting.orion.PrtoLval cVvalue = 5;
inline bool PrtoLstm::has_cvvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoLstm::set_has_cvvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoLstm::clear_has_cvvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoLstm::clear_cvvalue() {
  if (cvvalue_ != NULL) cvvalue_->::com::tomting::orion::PrtoLval::Clear();
  clear_has_cvvalue();
}
inline const ::com::tomting::orion::PrtoLval& PrtoLstm::cvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLstm.cVvalue)
  return cvvalue_ != NULL ? *cvvalue_ : *default_instance_->cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoLstm::mutable_cvvalue() {
  set_has_cvvalue();
  if (cvvalue_ == NULL) cvvalue_ = new ::com::tomting::orion::PrtoLval;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLstm.cVvalue)
  return cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoLstm::release_cvvalue() {
  clear_has_cvvalue();
  ::com::tomting::orion::PrtoLval* temp = cvvalue_;
  cvvalue_ = NULL;
  return temp;
}
inline void PrtoLstm::set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue) {
  delete cvvalue_;
  cvvalue_ = cvvalue;
  if (cvvalue) {
    set_has_cvvalue();
  } else {
    clear_has_cvvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLstm.cVvalue)
}

// -------------------------------------------------------------------

// PrtoLsts

// repeated .com.tomting.orion.PrtoLstm cVliststatement = 1;
inline int PrtoLsts::cvliststatement_size() const {
  return cvliststatement_.size();
}
inline void PrtoLsts::clear_cvliststatement() {
  cvliststatement_.Clear();
}
inline const ::com::tomting::orion::PrtoLstm& PrtoLsts::cvliststatement(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLsts.cVliststatement)
  return cvliststatement_.Get(index);
}
inline ::com::tomting::orion::PrtoLstm* PrtoLsts::mutable_cvliststatement(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLsts.cVliststatement)
  return cvliststatement_.Mutable(index);
}
inline ::com::tomting::orion::PrtoLstm* PrtoLsts::add_cvliststatement() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoLsts.cVliststatement)
  return cvliststatement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoLstm >&
PrtoLsts::cvliststatement() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoLsts.cVliststatement)
  return cvliststatement_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoLstm >*
PrtoLsts::mutable_cvliststatement() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoLsts.cVliststatement)
  return &cvliststatement_;
}

// -------------------------------------------------------------------

// PrtoLqry

// required .com.tomting.orion.iCquerytype iVquery = 1;
inline bool PrtoLqry::has_ivquery() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLqry::set_has_ivquery() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLqry::clear_has_ivquery() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLqry::clear_ivquery() {
  ivquery_ = 0;
  clear_has_ivquery();
}
inline ::com::tomting::orion::iCquerytype PrtoLqry::ivquery() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLqry.iVquery)
  return static_cast< ::com::tomting::orion::iCquerytype >(ivquery_);
}
inline void PrtoLqry::set_ivquery(::com::tomting::orion::iCquerytype value) {
  assert(::com::tomting::orion::iCquerytype_IsValid(value));
  set_has_ivquery();
  ivquery_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLqry.iVquery)
}

// required .com.tomting.orion.PrtoLmtb cVmutable = 2;
inline bool PrtoLqry::has_cvmutable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLqry::set_has_cvmutable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLqry::clear_has_cvmutable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLqry::clear_cvmutable() {
  if (cvmutable_ != NULL) cvmutable_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvmutable();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoLqry::cvmutable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLqry.cVmutable)
  return cvmutable_ != NULL ? *cvmutable_ : *default_instance_->cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoLqry::mutable_cvmutable() {
  set_has_cvmutable();
  if (cvmutable_ == NULL) cvmutable_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLqry.cVmutable)
  return cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoLqry::release_cvmutable() {
  clear_has_cvmutable();
  ::com::tomting::orion::PrtoLmtb* temp = cvmutable_;
  cvmutable_ = NULL;
  return temp;
}
inline void PrtoLqry::set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable) {
  delete cvmutable_;
  cvmutable_ = cvmutable;
  if (cvmutable) {
    set_has_cvmutable();
  } else {
    clear_has_cvmutable();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLqry.cVmutable)
}

// required .com.tomting.orion.PrtoLkey cVkey = 4;
inline bool PrtoLqry::has_cvkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoLqry::set_has_cvkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoLqry::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoLqry::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoLqry::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLqry.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoLqry::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLqry.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoLqry::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoLqry::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLqry.cVkey)
}

// required bool bVdigest = 5 [default = false];
inline bool PrtoLqry::has_bvdigest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoLqry::set_has_bvdigest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoLqry::clear_has_bvdigest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoLqry::clear_bvdigest() {
  bvdigest_ = false;
  clear_has_bvdigest();
}
inline bool PrtoLqry::bvdigest() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLqry.bVdigest)
  return bvdigest_;
}
inline void PrtoLqry::set_bvdigest(bool value) {
  set_has_bvdigest();
  bvdigest_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLqry.bVdigest)
}

// -------------------------------------------------------------------

// PrtoLlog

// required bytes sVtimestamp = 1;
inline bool PrtoLlog::has_svtimestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoLlog::set_has_svtimestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoLlog::clear_has_svtimestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoLlog::clear_svtimestamp() {
  if (svtimestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtimestamp_->clear();
  }
  clear_has_svtimestamp();
}
inline const ::std::string& PrtoLlog::svtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLlog.sVtimestamp)
  return *svtimestamp_;
}
inline void PrtoLlog::set_svtimestamp(const ::std::string& value) {
  set_has_svtimestamp();
  if (svtimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtimestamp_ = new ::std::string;
  }
  svtimestamp_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoLlog.sVtimestamp)
}
inline void PrtoLlog::set_svtimestamp(const char* value) {
  set_has_svtimestamp();
  if (svtimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtimestamp_ = new ::std::string;
  }
  svtimestamp_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoLlog.sVtimestamp)
}
inline void PrtoLlog::set_svtimestamp(const void* value, size_t size) {
  set_has_svtimestamp();
  if (svtimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtimestamp_ = new ::std::string;
  }
  svtimestamp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoLlog.sVtimestamp)
}
inline ::std::string* PrtoLlog::mutable_svtimestamp() {
  set_has_svtimestamp();
  if (svtimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtimestamp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLlog.sVtimestamp)
  return svtimestamp_;
}
inline ::std::string* PrtoLlog::release_svtimestamp() {
  clear_has_svtimestamp();
  if (svtimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtimestamp_;
    svtimestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoLlog::set_allocated_svtimestamp(::std::string* svtimestamp) {
  if (svtimestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtimestamp_;
  }
  if (svtimestamp) {
    set_has_svtimestamp();
    svtimestamp_ = svtimestamp;
  } else {
    clear_has_svtimestamp();
    svtimestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLlog.sVtimestamp)
}

// required .com.tomting.orion.PrtoLstm cVstatement = 2;
inline bool PrtoLlog::has_cvstatement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoLlog::set_has_cvstatement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoLlog::clear_has_cvstatement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoLlog::clear_cvstatement() {
  if (cvstatement_ != NULL) cvstatement_->::com::tomting::orion::PrtoLstm::Clear();
  clear_has_cvstatement();
}
inline const ::com::tomting::orion::PrtoLstm& PrtoLlog::cvstatement() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoLlog.cVstatement)
  return cvstatement_ != NULL ? *cvstatement_ : *default_instance_->cvstatement_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoLlog::mutable_cvstatement() {
  set_has_cvstatement();
  if (cvstatement_ == NULL) cvstatement_ = new ::com::tomting::orion::PrtoLstm;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoLlog.cVstatement)
  return cvstatement_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoLlog::release_cvstatement() {
  clear_has_cvstatement();
  ::com::tomting::orion::PrtoLstm* temp = cvstatement_;
  cvstatement_ = NULL;
  return temp;
}
inline void PrtoLlog::set_allocated_cvstatement(::com::tomting::orion::PrtoLstm* cvstatement) {
  delete cvstatement_;
  cvstatement_ = cvstatement;
  if (cvstatement) {
    set_has_cvstatement();
  } else {
    clear_has_cvstatement();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoLlog.cVstatement)
}

// -------------------------------------------------------------------

// PrtoL2cv

// optional .com.tomting.orion.iCcolumntype iVtype = 1 [default = STRINGTYPE];
inline bool PrtoL2cv::has_ivtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2cv::set_has_ivtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2cv::clear_has_ivtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2cv::clear_ivtype() {
  ivtype_ = 1;
  clear_has_ivtype();
}
inline ::com::tomting::orion::iCcolumntype PrtoL2cv::ivtype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.iVtype)
  return static_cast< ::com::tomting::orion::iCcolumntype >(ivtype_);
}
inline void PrtoL2cv::set_ivtype(::com::tomting::orion::iCcolumntype value) {
  assert(::com::tomting::orion::iCcolumntype_IsValid(value));
  set_has_ivtype();
  ivtype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.iVtype)
}

// optional bytes sVvalue = 2;
inline bool PrtoL2cv::has_svvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2cv::set_has_svvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2cv::clear_has_svvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2cv::clear_svvalue() {
  if (svvalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svvalue_->clear();
  }
  clear_has_svvalue();
}
inline const ::std::string& PrtoL2cv::svvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.sVvalue)
  return *svvalue_;
}
inline void PrtoL2cv::set_svvalue(const ::std::string& value) {
  set_has_svvalue();
  if (svvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svvalue_ = new ::std::string;
  }
  svvalue_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.sVvalue)
}
inline void PrtoL2cv::set_svvalue(const char* value) {
  set_has_svvalue();
  if (svvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svvalue_ = new ::std::string;
  }
  svvalue_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2cv.sVvalue)
}
inline void PrtoL2cv::set_svvalue(const void* value, size_t size) {
  set_has_svvalue();
  if (svvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svvalue_ = new ::std::string;
  }
  svvalue_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2cv.sVvalue)
}
inline ::std::string* PrtoL2cv::mutable_svvalue() {
  set_has_svvalue();
  if (svvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svvalue_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2cv.sVvalue)
  return svvalue_;
}
inline ::std::string* PrtoL2cv::release_svvalue() {
  clear_has_svvalue();
  if (svvalue_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svvalue_;
    svvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2cv::set_allocated_svvalue(::std::string* svvalue) {
  if (svvalue_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svvalue_;
  }
  if (svvalue) {
    set_has_svvalue();
    svvalue_ = svvalue;
  } else {
    clear_has_svvalue();
    svvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2cv.sVvalue)
}

// repeated bytes sVlistvalue = 3;
inline int PrtoL2cv::svlistvalue_size() const {
  return svlistvalue_.size();
}
inline void PrtoL2cv::clear_svlistvalue() {
  svlistvalue_.Clear();
}
inline const ::std::string& PrtoL2cv::svlistvalue(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.sVlistvalue)
  return svlistvalue_.Get(index);
}
inline ::std::string* PrtoL2cv::mutable_svlistvalue(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2cv.sVlistvalue)
  return svlistvalue_.Mutable(index);
}
inline void PrtoL2cv::set_svlistvalue(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.sVlistvalue)
  svlistvalue_.Mutable(index)->assign(value);
}
inline void PrtoL2cv::set_svlistvalue(int index, const char* value) {
  svlistvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2cv.sVlistvalue)
}
inline void PrtoL2cv::set_svlistvalue(int index, const void* value, size_t size) {
  svlistvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2cv.sVlistvalue)
}
inline ::std::string* PrtoL2cv::add_svlistvalue() {
  return svlistvalue_.Add();
}
inline void PrtoL2cv::add_svlistvalue(const ::std::string& value) {
  svlistvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2cv.sVlistvalue)
}
inline void PrtoL2cv::add_svlistvalue(const char* value) {
  svlistvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.tomting.orion.PrtoL2cv.sVlistvalue)
}
inline void PrtoL2cv::add_svlistvalue(const void* value, size_t size) {
  svlistvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.tomting.orion.PrtoL2cv.sVlistvalue)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrtoL2cv::svlistvalue() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2cv.sVlistvalue)
  return svlistvalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrtoL2cv::mutable_svlistvalue() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2cv.sVlistvalue)
  return &svlistvalue_;
}

// optional int32 iVvalue = 4;
inline bool PrtoL2cv::has_ivvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoL2cv::set_has_ivvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoL2cv::clear_has_ivvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoL2cv::clear_ivvalue() {
  ivvalue_ = 0;
  clear_has_ivvalue();
}
inline ::google::protobuf::int32 PrtoL2cv::ivvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.iVvalue)
  return ivvalue_;
}
inline void PrtoL2cv::set_ivvalue(::google::protobuf::int32 value) {
  set_has_ivvalue();
  ivvalue_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.iVvalue)
}

// repeated int32 iVlistvalue = 5;
inline int PrtoL2cv::ivlistvalue_size() const {
  return ivlistvalue_.size();
}
inline void PrtoL2cv::clear_ivlistvalue() {
  ivlistvalue_.Clear();
}
inline ::google::protobuf::int32 PrtoL2cv::ivlistvalue(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.iVlistvalue)
  return ivlistvalue_.Get(index);
}
inline void PrtoL2cv::set_ivlistvalue(int index, ::google::protobuf::int32 value) {
  ivlistvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.iVlistvalue)
}
inline void PrtoL2cv::add_ivlistvalue(::google::protobuf::int32 value) {
  ivlistvalue_.Add(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2cv.iVlistvalue)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PrtoL2cv::ivlistvalue() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2cv.iVlistvalue)
  return ivlistvalue_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PrtoL2cv::mutable_ivlistvalue() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2cv.iVlistvalue)
  return &ivlistvalue_;
}

// optional double dVvalue = 6;
inline bool PrtoL2cv::has_dvvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoL2cv::set_has_dvvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoL2cv::clear_has_dvvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoL2cv::clear_dvvalue() {
  dvvalue_ = 0;
  clear_has_dvvalue();
}
inline double PrtoL2cv::dvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.dVvalue)
  return dvvalue_;
}
inline void PrtoL2cv::set_dvvalue(double value) {
  set_has_dvvalue();
  dvvalue_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.dVvalue)
}

// repeated double dVlistvalue = 7;
inline int PrtoL2cv::dvlistvalue_size() const {
  return dvlistvalue_.size();
}
inline void PrtoL2cv::clear_dvlistvalue() {
  dvlistvalue_.Clear();
}
inline double PrtoL2cv::dvlistvalue(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.dVlistvalue)
  return dvlistvalue_.Get(index);
}
inline void PrtoL2cv::set_dvlistvalue(int index, double value) {
  dvlistvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.dVlistvalue)
}
inline void PrtoL2cv::add_dvlistvalue(double value) {
  dvlistvalue_.Add(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2cv.dVlistvalue)
}
inline const ::google::protobuf::RepeatedField< double >&
PrtoL2cv::dvlistvalue() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2cv.dVlistvalue)
  return dvlistvalue_;
}
inline ::google::protobuf::RepeatedField< double >*
PrtoL2cv::mutable_dvlistvalue() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2cv.dVlistvalue)
  return &dvlistvalue_;
}

// optional bool bVvalue = 8;
inline bool PrtoL2cv::has_bvvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoL2cv::set_has_bvvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoL2cv::clear_has_bvvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoL2cv::clear_bvvalue() {
  bvvalue_ = false;
  clear_has_bvvalue();
}
inline bool PrtoL2cv::bvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cv.bVvalue)
  return bvvalue_;
}
inline void PrtoL2cv::set_bvvalue(bool value) {
  set_has_bvvalue();
  bvvalue_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cv.bVvalue)
}

// -------------------------------------------------------------------

// PrtoL2cl

// required bytes sVcolumn = 1;
inline bool PrtoL2cl::has_svcolumn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2cl::set_has_svcolumn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2cl::clear_has_svcolumn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2cl::clear_svcolumn() {
  if (svcolumn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_->clear();
  }
  clear_has_svcolumn();
}
inline const ::std::string& PrtoL2cl::svcolumn() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cl.sVcolumn)
  return *svcolumn_;
}
inline void PrtoL2cl::set_svcolumn(const ::std::string& value) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cl.sVcolumn)
}
inline void PrtoL2cl::set_svcolumn(const char* value) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2cl.sVcolumn)
}
inline void PrtoL2cl::set_svcolumn(const void* value, size_t size) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2cl.sVcolumn)
}
inline ::std::string* PrtoL2cl::mutable_svcolumn() {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2cl.sVcolumn)
  return svcolumn_;
}
inline ::std::string* PrtoL2cl::release_svcolumn() {
  clear_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svcolumn_;
    svcolumn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2cl::set_allocated_svcolumn(::std::string* svcolumn) {
  if (svcolumn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svcolumn_;
  }
  if (svcolumn) {
    set_has_svcolumn();
    svcolumn_ = svcolumn;
  } else {
    clear_has_svcolumn();
    svcolumn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2cl.sVcolumn)
}

// optional .com.tomting.orion.iCcolumntype iVtype = 2 [default = STRINGTYPE];
inline bool PrtoL2cl::has_ivtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2cl::set_has_ivtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2cl::clear_has_ivtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2cl::clear_ivtype() {
  ivtype_ = 1;
  clear_has_ivtype();
}
inline ::com::tomting::orion::iCcolumntype PrtoL2cl::ivtype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cl.iVtype)
  return static_cast< ::com::tomting::orion::iCcolumntype >(ivtype_);
}
inline void PrtoL2cl::set_ivtype(::com::tomting::orion::iCcolumntype value) {
  assert(::com::tomting::orion::iCcolumntype_IsValid(value));
  set_has_ivtype();
  ivtype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cl.iVtype)
}

// optional .com.tomting.orion.PrtoL2cv cVvalue = 3;
inline bool PrtoL2cl::has_cvvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoL2cl::set_has_cvvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoL2cl::clear_has_cvvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoL2cl::clear_cvvalue() {
  if (cvvalue_ != NULL) cvvalue_->::com::tomting::orion::PrtoL2cv::Clear();
  clear_has_cvvalue();
}
inline const ::com::tomting::orion::PrtoL2cv& PrtoL2cl::cvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cl.cVvalue)
  return cvvalue_ != NULL ? *cvvalue_ : *default_instance_->cvvalue_;
}
inline ::com::tomting::orion::PrtoL2cv* PrtoL2cl::mutable_cvvalue() {
  set_has_cvvalue();
  if (cvvalue_ == NULL) cvvalue_ = new ::com::tomting::orion::PrtoL2cv;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2cl.cVvalue)
  return cvvalue_;
}
inline ::com::tomting::orion::PrtoL2cv* PrtoL2cl::release_cvvalue() {
  clear_has_cvvalue();
  ::com::tomting::orion::PrtoL2cv* temp = cvvalue_;
  cvvalue_ = NULL;
  return temp;
}
inline void PrtoL2cl::set_allocated_cvvalue(::com::tomting::orion::PrtoL2cv* cvvalue) {
  delete cvvalue_;
  cvvalue_ = cvvalue;
  if (cvvalue) {
    set_has_cvvalue();
  } else {
    clear_has_cvvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2cl.cVvalue)
}

// optional .com.tomting.orion.iCconditiontype iVconditiontype = 4;
inline bool PrtoL2cl::has_ivconditiontype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoL2cl::set_has_ivconditiontype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoL2cl::clear_has_ivconditiontype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoL2cl::clear_ivconditiontype() {
  ivconditiontype_ = 0;
  clear_has_ivconditiontype();
}
inline ::com::tomting::orion::iCconditiontype PrtoL2cl::ivconditiontype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2cl.iVconditiontype)
  return static_cast< ::com::tomting::orion::iCconditiontype >(ivconditiontype_);
}
inline void PrtoL2cl::set_ivconditiontype(::com::tomting::orion::iCconditiontype value) {
  assert(::com::tomting::orion::iCconditiontype_IsValid(value));
  set_has_ivconditiontype();
  ivconditiontype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2cl.iVconditiontype)
}

// -------------------------------------------------------------------

// PrtoL2st

// optional .com.tomting.orion.iCopcodetype iVopcode = 1 [default = MUTATOR];
inline bool PrtoL2st::has_ivopcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2st::set_has_ivopcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2st::clear_has_ivopcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2st::clear_ivopcode() {
  ivopcode_ = 0;
  clear_has_ivopcode();
}
inline ::com::tomting::orion::iCopcodetype PrtoL2st::ivopcode() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2st.iVopcode)
  return static_cast< ::com::tomting::orion::iCopcodetype >(ivopcode_);
}
inline void PrtoL2st::set_ivopcode(::com::tomting::orion::iCopcodetype value) {
  assert(::com::tomting::orion::iCopcodetype_IsValid(value));
  set_has_ivopcode();
  ivopcode_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2st.iVopcode)
}

// required .com.tomting.orion.PrtoLmtb cVmutable = 2;
inline bool PrtoL2st::has_cvmutable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2st::set_has_cvmutable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2st::clear_has_cvmutable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2st::clear_cvmutable() {
  if (cvmutable_ != NULL) cvmutable_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvmutable();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoL2st::cvmutable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2st.cVmutable)
  return cvmutable_ != NULL ? *cvmutable_ : *default_instance_->cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoL2st::mutable_cvmutable() {
  set_has_cvmutable();
  if (cvmutable_ == NULL) cvmutable_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2st.cVmutable)
  return cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoL2st::release_cvmutable() {
  clear_has_cvmutable();
  ::com::tomting::orion::PrtoLmtb* temp = cvmutable_;
  cvmutable_ = NULL;
  return temp;
}
inline void PrtoL2st::set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable) {
  delete cvmutable_;
  cvmutable_ = cvmutable;
  if (cvmutable) {
    set_has_cvmutable();
  } else {
    clear_has_cvmutable();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2st.cVmutable)
}

// required .com.tomting.orion.PrtoLkey cVkey = 3;
inline bool PrtoL2st::has_cvkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoL2st::set_has_cvkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoL2st::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoL2st::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoL2st::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2st.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2st::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2st.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2st::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoL2st::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2st.cVkey)
}

// repeated .com.tomting.orion.PrtoL2cl cVcolumns = 4;
inline int PrtoL2st::cvcolumns_size() const {
  return cvcolumns_.size();
}
inline void PrtoL2st::clear_cvcolumns() {
  cvcolumns_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cl& PrtoL2st::cvcolumns(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2st.cVcolumns)
  return cvcolumns_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2st::mutable_cvcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2st.cVcolumns)
  return cvcolumns_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2st::add_cvcolumns() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2st.cVcolumns)
  return cvcolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
PrtoL2st::cvcolumns() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2st.cVcolumns)
  return cvcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
PrtoL2st::mutable_cvcolumns() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2st.cVcolumns)
  return &cvcolumns_;
}

// optional int64 iVtimestamp = 5 [default = 0];
inline bool PrtoL2st::has_ivtimestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoL2st::set_has_ivtimestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoL2st::clear_has_ivtimestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoL2st::clear_ivtimestamp() {
  ivtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ivtimestamp();
}
inline ::google::protobuf::int64 PrtoL2st::ivtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2st.iVtimestamp)
  return ivtimestamp_;
}
inline void PrtoL2st::set_ivtimestamp(::google::protobuf::int64 value) {
  set_has_ivtimestamp();
  ivtimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2st.iVtimestamp)
}

// -------------------------------------------------------------------

// PrtoL2ag

// required bytes sVname = 1;
inline bool PrtoL2ag::has_svname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2ag::set_has_svname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2ag::clear_has_svname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2ag::clear_svname() {
  if (svname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_->clear();
  }
  clear_has_svname();
}
inline const ::std::string& PrtoL2ag::svname() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ag.sVname)
  return *svname_;
}
inline void PrtoL2ag::set_svname(const ::std::string& value) {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  svname_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ag.sVname)
}
inline void PrtoL2ag::set_svname(const char* value) {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  svname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2ag.sVname)
}
inline void PrtoL2ag::set_svname(const void* value, size_t size) {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  svname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2ag.sVname)
}
inline ::std::string* PrtoL2ag::mutable_svname() {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ag.sVname)
  return svname_;
}
inline ::std::string* PrtoL2ag::release_svname() {
  clear_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svname_;
    svname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2ag::set_allocated_svname(::std::string* svname) {
  if (svname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svname_;
  }
  if (svname) {
    set_has_svname();
    svname_ = svname;
  } else {
    clear_has_svname();
    svname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2ag.sVname)
}

// repeated bytes sVcolumns = 2;
inline int PrtoL2ag::svcolumns_size() const {
  return svcolumns_.size();
}
inline void PrtoL2ag::clear_svcolumns() {
  svcolumns_.Clear();
}
inline const ::std::string& PrtoL2ag::svcolumns(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ag.sVcolumns)
  return svcolumns_.Get(index);
}
inline ::std::string* PrtoL2ag::mutable_svcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ag.sVcolumns)
  return svcolumns_.Mutable(index);
}
inline void PrtoL2ag::set_svcolumns(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ag.sVcolumns)
  svcolumns_.Mutable(index)->assign(value);
}
inline void PrtoL2ag::set_svcolumns(int index, const char* value) {
  svcolumns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2ag.sVcolumns)
}
inline void PrtoL2ag::set_svcolumns(int index, const void* value, size_t size) {
  svcolumns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2ag.sVcolumns)
}
inline ::std::string* PrtoL2ag::add_svcolumns() {
  return svcolumns_.Add();
}
inline void PrtoL2ag::add_svcolumns(const ::std::string& value) {
  svcolumns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ag.sVcolumns)
}
inline void PrtoL2ag::add_svcolumns(const char* value) {
  svcolumns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.tomting.orion.PrtoL2ag.sVcolumns)
}
inline void PrtoL2ag::add_svcolumns(const void* value, size_t size) {
  svcolumns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.tomting.orion.PrtoL2ag.sVcolumns)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrtoL2ag::svcolumns() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ag.sVcolumns)
  return svcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrtoL2ag::mutable_svcolumns() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ag.sVcolumns)
  return &svcolumns_;
}

// -------------------------------------------------------------------

// PrtoL2ix

// required bytes sVindex = 1;
inline bool PrtoL2ix::has_svindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2ix::set_has_svindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2ix::clear_has_svindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2ix::clear_svindex() {
  if (svindex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_->clear();
  }
  clear_has_svindex();
}
inline const ::std::string& PrtoL2ix::svindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ix.sVindex)
  return *svindex_;
}
inline void PrtoL2ix::set_svindex(const ::std::string& value) {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  svindex_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ix.sVindex)
}
inline void PrtoL2ix::set_svindex(const char* value) {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  svindex_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2ix.sVindex)
}
inline void PrtoL2ix::set_svindex(const void* value, size_t size) {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  svindex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2ix.sVindex)
}
inline ::std::string* PrtoL2ix::mutable_svindex() {
  set_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svindex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ix.sVindex)
  return svindex_;
}
inline ::std::string* PrtoL2ix::release_svindex() {
  clear_has_svindex();
  if (svindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svindex_;
    svindex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2ix::set_allocated_svindex(::std::string* svindex) {
  if (svindex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svindex_;
  }
  if (svindex) {
    set_has_svindex();
    svindex_ = svindex;
  } else {
    clear_has_svindex();
    svindex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2ix.sVindex)
}

// repeated .com.tomting.orion.PrtoL2or cVcolumn = 2;
inline int PrtoL2ix::cvcolumn_size() const {
  return cvcolumn_.size();
}
inline void PrtoL2ix::clear_cvcolumn() {
  cvcolumn_.Clear();
}
inline const ::com::tomting::orion::PrtoL2or& PrtoL2ix::cvcolumn(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ix.cVcolumn)
  return cvcolumn_.Get(index);
}
inline ::com::tomting::orion::PrtoL2or* PrtoL2ix::mutable_cvcolumn(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ix.cVcolumn)
  return cvcolumn_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2or* PrtoL2ix::add_cvcolumn() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ix.cVcolumn)
  return cvcolumn_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >&
PrtoL2ix::cvcolumn() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ix.cVcolumn)
  return cvcolumn_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >*
PrtoL2ix::mutable_cvcolumn() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ix.cVcolumn)
  return &cvcolumn_;
}

// -------------------------------------------------------------------

// PrtoL2ct

// required .com.tomting.orion.PrtoLmtb cVmutable = 1;
inline bool PrtoL2ct::has_cvmutable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2ct::set_has_cvmutable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2ct::clear_has_cvmutable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2ct::clear_cvmutable() {
  if (cvmutable_ != NULL) cvmutable_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvmutable();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoL2ct::cvmutable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.cVmutable)
  return cvmutable_ != NULL ? *cvmutable_ : *default_instance_->cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoL2ct::mutable_cvmutable() {
  set_has_cvmutable();
  if (cvmutable_ == NULL) cvmutable_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ct.cVmutable)
  return cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoL2ct::release_cvmutable() {
  clear_has_cvmutable();
  ::com::tomting::orion::PrtoLmtb* temp = cvmutable_;
  cvmutable_ = NULL;
  return temp;
}
inline void PrtoL2ct::set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable) {
  delete cvmutable_;
  cvmutable_ = cvmutable;
  if (cvmutable) {
    set_has_cvmutable();
  } else {
    clear_has_cvmutable();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2ct.cVmutable)
}

// repeated .com.tomting.orion.PrtoL2cl cVcolumns = 2;
inline int PrtoL2ct::cvcolumns_size() const {
  return cvcolumns_.size();
}
inline void PrtoL2ct::clear_cvcolumns() {
  cvcolumns_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cl& PrtoL2ct::cvcolumns(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.cVcolumns)
  return cvcolumns_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2ct::mutable_cvcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ct.cVcolumns)
  return cvcolumns_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2ct::add_cvcolumns() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ct.cVcolumns)
  return cvcolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
PrtoL2ct::cvcolumns() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ct.cVcolumns)
  return cvcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
PrtoL2ct::mutable_cvcolumns() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ct.cVcolumns)
  return &cvcolumns_;
}

// repeated .com.tomting.orion.PrtoL2ag cVaccessgroups = 3;
inline int PrtoL2ct::cvaccessgroups_size() const {
  return cvaccessgroups_.size();
}
inline void PrtoL2ct::clear_cvaccessgroups() {
  cvaccessgroups_.Clear();
}
inline const ::com::tomting::orion::PrtoL2ag& PrtoL2ct::cvaccessgroups(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.cVaccessgroups)
  return cvaccessgroups_.Get(index);
}
inline ::com::tomting::orion::PrtoL2ag* PrtoL2ct::mutable_cvaccessgroups(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ct.cVaccessgroups)
  return cvaccessgroups_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2ag* PrtoL2ct::add_cvaccessgroups() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ct.cVaccessgroups)
  return cvaccessgroups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ag >&
PrtoL2ct::cvaccessgroups() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ct.cVaccessgroups)
  return cvaccessgroups_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ag >*
PrtoL2ct::mutable_cvaccessgroups() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ct.cVaccessgroups)
  return &cvaccessgroups_;
}

// optional int32 iVmemtabledim = 4 [default = 0];
inline bool PrtoL2ct::has_ivmemtabledim() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoL2ct::set_has_ivmemtabledim() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoL2ct::clear_has_ivmemtabledim() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoL2ct::clear_ivmemtabledim() {
  ivmemtabledim_ = 0;
  clear_has_ivmemtabledim();
}
inline ::google::protobuf::int32 PrtoL2ct::ivmemtabledim() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.iVmemtabledim)
  return ivmemtabledim_;
}
inline void PrtoL2ct::set_ivmemtabledim(::google::protobuf::int32 value) {
  set_has_ivmemtabledim();
  ivmemtabledim_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ct.iVmemtabledim)
}

// optional int32 iVreplicationfactor = 5 [default = 1];
inline bool PrtoL2ct::has_ivreplicationfactor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoL2ct::set_has_ivreplicationfactor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoL2ct::clear_has_ivreplicationfactor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoL2ct::clear_ivreplicationfactor() {
  ivreplicationfactor_ = 1;
  clear_has_ivreplicationfactor();
}
inline ::google::protobuf::int32 PrtoL2ct::ivreplicationfactor() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.iVreplicationfactor)
  return ivreplicationfactor_;
}
inline void PrtoL2ct::set_ivreplicationfactor(::google::protobuf::int32 value) {
  set_has_ivreplicationfactor();
  ivreplicationfactor_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ct.iVreplicationfactor)
}

// optional .com.tomting.orion.iCtabletype iVtabletype = 6 [default = VOLATILETABLE];
inline bool PrtoL2ct::has_ivtabletype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoL2ct::set_has_ivtabletype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoL2ct::clear_has_ivtabletype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoL2ct::clear_ivtabletype() {
  ivtabletype_ = 2;
  clear_has_ivtabletype();
}
inline ::com::tomting::orion::iCtabletype PrtoL2ct::ivtabletype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.iVtabletype)
  return static_cast< ::com::tomting::orion::iCtabletype >(ivtabletype_);
}
inline void PrtoL2ct::set_ivtabletype(::com::tomting::orion::iCtabletype value) {
  assert(::com::tomting::orion::iCtabletype_IsValid(value));
  set_has_ivtabletype();
  ivtabletype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ct.iVtabletype)
}

// optional .com.tomting.orion.iCpartitiontype iVpartitiontype = 7 [default = NOPARTITION];
inline bool PrtoL2ct::has_ivpartitiontype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoL2ct::set_has_ivpartitiontype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoL2ct::clear_has_ivpartitiontype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoL2ct::clear_ivpartitiontype() {
  ivpartitiontype_ = 0;
  clear_has_ivpartitiontype();
}
inline ::com::tomting::orion::iCpartitiontype PrtoL2ct::ivpartitiontype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.iVpartitiontype)
  return static_cast< ::com::tomting::orion::iCpartitiontype >(ivpartitiontype_);
}
inline void PrtoL2ct::set_ivpartitiontype(::com::tomting::orion::iCpartitiontype value) {
  assert(::com::tomting::orion::iCpartitiontype_IsValid(value));
  set_has_ivpartitiontype();
  ivpartitiontype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ct.iVpartitiontype)
}

// optional .com.tomting.orion.iCindextype iVindextype = 8 [default = DISTRINDEX];
inline bool PrtoL2ct::has_ivindextype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoL2ct::set_has_ivindextype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoL2ct::clear_has_ivindextype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoL2ct::clear_ivindextype() {
  ivindextype_ = 0;
  clear_has_ivindextype();
}
inline ::com::tomting::orion::iCindextype PrtoL2ct::ivindextype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.iVindextype)
  return static_cast< ::com::tomting::orion::iCindextype >(ivindextype_);
}
inline void PrtoL2ct::set_ivindextype(::com::tomting::orion::iCindextype value) {
  assert(::com::tomting::orion::iCindextype_IsValid(value));
  set_has_ivindextype();
  ivindextype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2ct.iVindextype)
}

// repeated .com.tomting.orion.PrtoL2ix cVindexes = 9;
inline int PrtoL2ct::cvindexes_size() const {
  return cvindexes_.size();
}
inline void PrtoL2ct::clear_cvindexes() {
  cvindexes_.Clear();
}
inline const ::com::tomting::orion::PrtoL2ix& PrtoL2ct::cvindexes(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ct.cVindexes)
  return cvindexes_.Get(index);
}
inline ::com::tomting::orion::PrtoL2ix* PrtoL2ct::mutable_cvindexes(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ct.cVindexes)
  return cvindexes_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2ix* PrtoL2ct::add_cvindexes() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ct.cVindexes)
  return cvindexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ix >&
PrtoL2ct::cvindexes() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ct.cVindexes)
  return cvindexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ix >*
PrtoL2ct::mutable_cvindexes() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ct.cVindexes)
  return &cvindexes_;
}

// -------------------------------------------------------------------

// PrtoL2ao

// repeated .com.tomting.orion.PrtoL2cl cVcolumns = 1;
inline int PrtoL2ao::cvcolumns_size() const {
  return cvcolumns_.size();
}
inline void PrtoL2ao::clear_cvcolumns() {
  cvcolumns_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cl& PrtoL2ao::cvcolumns(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ao.cVcolumns)
  return cvcolumns_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2ao::mutable_cvcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ao.cVcolumns)
  return cvcolumns_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2ao::add_cvcolumns() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ao.cVcolumns)
  return cvcolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
PrtoL2ao::cvcolumns() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ao.cVcolumns)
  return cvcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
PrtoL2ao::mutable_cvcolumns() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ao.cVcolumns)
  return &cvcolumns_;
}

// -------------------------------------------------------------------

// PrtoL2vo

// repeated .com.tomting.orion.PrtoL2ao cVaccessobject = 1;
inline int PrtoL2vo::cvaccessobject_size() const {
  return cvaccessobject_.size();
}
inline void PrtoL2vo::clear_cvaccessobject() {
  cvaccessobject_.Clear();
}
inline const ::com::tomting::orion::PrtoL2ao& PrtoL2vo::cvaccessobject(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2vo.cVaccessobject)
  return cvaccessobject_.Get(index);
}
inline ::com::tomting::orion::PrtoL2ao* PrtoL2vo::mutable_cvaccessobject(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2vo.cVaccessobject)
  return cvaccessobject_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2ao* PrtoL2vo::add_cvaccessobject() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2vo.cVaccessobject)
  return cvaccessobject_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ao >&
PrtoL2vo::cvaccessobject() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2vo.cVaccessobject)
  return cvaccessobject_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ao >*
PrtoL2vo::mutable_cvaccessobject() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2vo.cVaccessobject)
  return &cvaccessobject_;
}

// -------------------------------------------------------------------

// PrtoL2ks

// required .com.tomting.orion.PrtoLkey cVkey = 1;
inline bool PrtoL2ks::has_cvkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2ks::set_has_cvkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2ks::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2ks::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoL2ks::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ks.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2ks::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ks.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2ks::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoL2ks::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2ks.cVkey)
}

// repeated .com.tomting.orion.PrtoL2cl cVcolumns = 2;
inline int PrtoL2ks::cvcolumns_size() const {
  return cvcolumns_.size();
}
inline void PrtoL2ks::clear_cvcolumns() {
  cvcolumns_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cl& PrtoL2ks::cvcolumns(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2ks.cVcolumns)
  return cvcolumns_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2ks::mutable_cvcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2ks.cVcolumns)
  return cvcolumns_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2ks::add_cvcolumns() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2ks.cVcolumns)
  return cvcolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
PrtoL2ks::cvcolumns() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2ks.cVcolumns)
  return cvcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
PrtoL2ks::mutable_cvcolumns() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2ks.cVcolumns)
  return &cvcolumns_;
}

// -------------------------------------------------------------------

// PrtoL2or

// required bytes sVcolumn = 1;
inline bool PrtoL2or::has_svcolumn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2or::set_has_svcolumn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2or::clear_has_svcolumn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2or::clear_svcolumn() {
  if (svcolumn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_->clear();
  }
  clear_has_svcolumn();
}
inline const ::std::string& PrtoL2or::svcolumn() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2or.sVcolumn)
  return *svcolumn_;
}
inline void PrtoL2or::set_svcolumn(const ::std::string& value) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2or.sVcolumn)
}
inline void PrtoL2or::set_svcolumn(const char* value) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2or.sVcolumn)
}
inline void PrtoL2or::set_svcolumn(const void* value, size_t size) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2or.sVcolumn)
}
inline ::std::string* PrtoL2or::mutable_svcolumn() {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2or.sVcolumn)
  return svcolumn_;
}
inline ::std::string* PrtoL2or::release_svcolumn() {
  clear_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svcolumn_;
    svcolumn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2or::set_allocated_svcolumn(::std::string* svcolumn) {
  if (svcolumn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svcolumn_;
  }
  if (svcolumn) {
    set_has_svcolumn();
    svcolumn_ = svcolumn;
  } else {
    clear_has_svcolumn();
    svcolumn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2or.sVcolumn)
}

// required .com.tomting.orion.iCordertype iVordertype = 2;
inline bool PrtoL2or::has_ivordertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2or::set_has_ivordertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2or::clear_has_ivordertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2or::clear_ivordertype() {
  ivordertype_ = 0;
  clear_has_ivordertype();
}
inline ::com::tomting::orion::iCordertype PrtoL2or::ivordertype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2or.iVordertype)
  return static_cast< ::com::tomting::orion::iCordertype >(ivordertype_);
}
inline void PrtoL2or::set_ivordertype(::com::tomting::orion::iCordertype value) {
  assert(::com::tomting::orion::iCordertype_IsValid(value));
  set_has_ivordertype();
  ivordertype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2or.iVordertype)
}

// -------------------------------------------------------------------

// PrtoL2wh

// repeated .com.tomting.orion.PrtoL2cl cVcondition = 1;
inline int PrtoL2wh::cvcondition_size() const {
  return cvcondition_.size();
}
inline void PrtoL2wh::clear_cvcondition() {
  cvcondition_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cl& PrtoL2wh::cvcondition(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2wh.cVcondition)
  return cvcondition_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2wh::mutable_cvcondition(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2wh.cVcondition)
  return cvcondition_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2wh::add_cvcondition() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2wh.cVcondition)
  return cvcondition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
PrtoL2wh::cvcondition() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2wh.cVcondition)
  return cvcondition_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
PrtoL2wh::mutable_cvcondition() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2wh.cVcondition)
  return &cvcondition_;
}

// repeated .com.tomting.orion.PrtoL2or cVorderby = 2;
inline int PrtoL2wh::cvorderby_size() const {
  return cvorderby_.size();
}
inline void PrtoL2wh::clear_cvorderby() {
  cvorderby_.Clear();
}
inline const ::com::tomting::orion::PrtoL2or& PrtoL2wh::cvorderby(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2wh.cVorderby)
  return cvorderby_.Get(index);
}
inline ::com::tomting::orion::PrtoL2or* PrtoL2wh::mutable_cvorderby(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2wh.cVorderby)
  return cvorderby_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2or* PrtoL2wh::add_cvorderby() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2wh.cVorderby)
  return cvorderby_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >&
PrtoL2wh::cvorderby() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2wh.cVorderby)
  return cvorderby_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2or >*
PrtoL2wh::mutable_cvorderby() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2wh.cVorderby)
  return &cvorderby_;
}

// -------------------------------------------------------------------

// PrtoL2qr

// repeated .com.tomting.orion.PrtoL2cl cVselect = 1;
inline int PrtoL2qr::cvselect_size() const {
  return cvselect_.size();
}
inline void PrtoL2qr::clear_cvselect() {
  cvselect_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cl& PrtoL2qr::cvselect(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.cVselect)
  return cvselect_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2qr::mutable_cvselect(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2qr.cVselect)
  return cvselect_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cl* PrtoL2qr::add_cvselect() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2qr.cVselect)
  return cvselect_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >&
PrtoL2qr::cvselect() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2qr.cVselect)
  return cvselect_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cl >*
PrtoL2qr::mutable_cvselect() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2qr.cVselect)
  return &cvselect_;
}

// required .com.tomting.orion.PrtoLmtb cVmutable = 2;
inline bool PrtoL2qr::has_cvmutable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2qr::set_has_cvmutable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2qr::clear_has_cvmutable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2qr::clear_cvmutable() {
  if (cvmutable_ != NULL) cvmutable_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvmutable();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoL2qr::cvmutable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.cVmutable)
  return cvmutable_ != NULL ? *cvmutable_ : *default_instance_->cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoL2qr::mutable_cvmutable() {
  set_has_cvmutable();
  if (cvmutable_ == NULL) cvmutable_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2qr.cVmutable)
  return cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoL2qr::release_cvmutable() {
  clear_has_cvmutable();
  ::com::tomting::orion::PrtoLmtb* temp = cvmutable_;
  cvmutable_ = NULL;
  return temp;
}
inline void PrtoL2qr::set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable) {
  delete cvmutable_;
  cvmutable_ = cvmutable;
  if (cvmutable) {
    set_has_cvmutable();
  } else {
    clear_has_cvmutable();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2qr.cVmutable)
}

// optional .com.tomting.orion.iCquerytype iVquery = 3;
inline bool PrtoL2qr::has_ivquery() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoL2qr::set_has_ivquery() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoL2qr::clear_has_ivquery() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoL2qr::clear_ivquery() {
  ivquery_ = 0;
  clear_has_ivquery();
}
inline ::com::tomting::orion::iCquerytype PrtoL2qr::ivquery() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.iVquery)
  return static_cast< ::com::tomting::orion::iCquerytype >(ivquery_);
}
inline void PrtoL2qr::set_ivquery(::com::tomting::orion::iCquerytype value) {
  assert(::com::tomting::orion::iCquerytype_IsValid(value));
  set_has_ivquery();
  ivquery_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2qr.iVquery)
}

// optional .com.tomting.orion.PrtoLkey cVkey_start = 4;
inline bool PrtoL2qr::has_cvkey_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoL2qr::set_has_cvkey_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoL2qr::clear_has_cvkey_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoL2qr::clear_cvkey_start() {
  if (cvkey_start_ != NULL) cvkey_start_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey_start();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoL2qr::cvkey_start() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.cVkey_start)
  return cvkey_start_ != NULL ? *cvkey_start_ : *default_instance_->cvkey_start_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2qr::mutable_cvkey_start() {
  set_has_cvkey_start();
  if (cvkey_start_ == NULL) cvkey_start_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2qr.cVkey_start)
  return cvkey_start_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2qr::release_cvkey_start() {
  clear_has_cvkey_start();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_start_;
  cvkey_start_ = NULL;
  return temp;
}
inline void PrtoL2qr::set_allocated_cvkey_start(::com::tomting::orion::PrtoLkey* cvkey_start) {
  delete cvkey_start_;
  cvkey_start_ = cvkey_start;
  if (cvkey_start) {
    set_has_cvkey_start();
  } else {
    clear_has_cvkey_start();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2qr.cVkey_start)
}

// optional .com.tomting.orion.PrtoLkey cVkey_end = 5;
inline bool PrtoL2qr::has_cvkey_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoL2qr::set_has_cvkey_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoL2qr::clear_has_cvkey_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoL2qr::clear_cvkey_end() {
  if (cvkey_end_ != NULL) cvkey_end_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey_end();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoL2qr::cvkey_end() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.cVkey_end)
  return cvkey_end_ != NULL ? *cvkey_end_ : *default_instance_->cvkey_end_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2qr::mutable_cvkey_end() {
  set_has_cvkey_end();
  if (cvkey_end_ == NULL) cvkey_end_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2qr.cVkey_end)
  return cvkey_end_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL2qr::release_cvkey_end() {
  clear_has_cvkey_end();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_end_;
  cvkey_end_ = NULL;
  return temp;
}
inline void PrtoL2qr::set_allocated_cvkey_end(::com::tomting::orion::PrtoLkey* cvkey_end) {
  delete cvkey_end_;
  cvkey_end_ = cvkey_end;
  if (cvkey_end) {
    set_has_cvkey_end();
  } else {
    clear_has_cvkey_end();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2qr.cVkey_end)
}

// optional .com.tomting.orion.PrtoL2wh cVwhere = 6;
inline bool PrtoL2qr::has_cvwhere() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoL2qr::set_has_cvwhere() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoL2qr::clear_has_cvwhere() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoL2qr::clear_cvwhere() {
  if (cvwhere_ != NULL) cvwhere_->::com::tomting::orion::PrtoL2wh::Clear();
  clear_has_cvwhere();
}
inline const ::com::tomting::orion::PrtoL2wh& PrtoL2qr::cvwhere() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.cVwhere)
  return cvwhere_ != NULL ? *cvwhere_ : *default_instance_->cvwhere_;
}
inline ::com::tomting::orion::PrtoL2wh* PrtoL2qr::mutable_cvwhere() {
  set_has_cvwhere();
  if (cvwhere_ == NULL) cvwhere_ = new ::com::tomting::orion::PrtoL2wh;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2qr.cVwhere)
  return cvwhere_;
}
inline ::com::tomting::orion::PrtoL2wh* PrtoL2qr::release_cvwhere() {
  clear_has_cvwhere();
  ::com::tomting::orion::PrtoL2wh* temp = cvwhere_;
  cvwhere_ = NULL;
  return temp;
}
inline void PrtoL2qr::set_allocated_cvwhere(::com::tomting::orion::PrtoL2wh* cvwhere) {
  delete cvwhere_;
  cvwhere_ = cvwhere;
  if (cvwhere) {
    set_has_cvwhere();
  } else {
    clear_has_cvwhere();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2qr.cVwhere)
}

// optional int32 iVcount = 7 [default = 100];
inline bool PrtoL2qr::has_ivcount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoL2qr::set_has_ivcount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoL2qr::clear_has_ivcount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoL2qr::clear_ivcount() {
  ivcount_ = 100;
  clear_has_ivcount();
}
inline ::google::protobuf::int32 PrtoL2qr::ivcount() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.iVcount)
  return ivcount_;
}
inline void PrtoL2qr::set_ivcount(::google::protobuf::int32 value) {
  set_has_ivcount();
  ivcount_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2qr.iVcount)
}

// optional bool bVonlysecondary = 8 [default = false];
inline bool PrtoL2qr::has_bvonlysecondary() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoL2qr::set_has_bvonlysecondary() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoL2qr::clear_has_bvonlysecondary() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoL2qr::clear_bvonlysecondary() {
  bvonlysecondary_ = false;
  clear_has_bvonlysecondary();
}
inline bool PrtoL2qr::bvonlysecondary() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.bVonlysecondary)
  return bvonlysecondary_;
}
inline void PrtoL2qr::set_bvonlysecondary(bool value) {
  set_has_bvonlysecondary();
  bvonlysecondary_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2qr.bVonlysecondary)
}

// optional bool bVdisableteleport = 9 [default = false];
inline bool PrtoL2qr::has_bvdisableteleport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PrtoL2qr::set_has_bvdisableteleport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PrtoL2qr::clear_has_bvdisableteleport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PrtoL2qr::clear_bvdisableteleport() {
  bvdisableteleport_ = false;
  clear_has_bvdisableteleport();
}
inline bool PrtoL2qr::bvdisableteleport() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.bVdisableteleport)
  return bvdisableteleport_;
}
inline void PrtoL2qr::set_bvdisableteleport(bool value) {
  set_has_bvdisableteleport();
  bvdisableteleport_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2qr.bVdisableteleport)
}

// optional bool bVfulltablescan = 10 [default = false];
inline bool PrtoL2qr::has_bvfulltablescan() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PrtoL2qr::set_has_bvfulltablescan() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PrtoL2qr::clear_has_bvfulltablescan() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PrtoL2qr::clear_bvfulltablescan() {
  bvfulltablescan_ = false;
  clear_has_bvfulltablescan();
}
inline bool PrtoL2qr::bvfulltablescan() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2qr.bVfulltablescan)
  return bvfulltablescan_;
}
inline void PrtoL2qr::set_bvfulltablescan(bool value) {
  set_has_bvfulltablescan();
  bvfulltablescan_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2qr.bVfulltablescan)
}

// -------------------------------------------------------------------

// PrtoL2os

// required bytes sVnamespace = 1;
inline bool PrtoL2os::has_svnamespace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL2os::set_has_svnamespace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL2os::clear_has_svnamespace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL2os::clear_svnamespace() {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_->clear();
  }
  clear_has_svnamespace();
}
inline const ::std::string& PrtoL2os::svnamespace() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.sVnamespace)
  return *svnamespace_;
}
inline void PrtoL2os::set_svnamespace(const ::std::string& value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2os.sVnamespace)
}
inline void PrtoL2os::set_svnamespace(const char* value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2os.sVnamespace)
}
inline void PrtoL2os::set_svnamespace(const void* value, size_t size) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2os.sVnamespace)
}
inline ::std::string* PrtoL2os::mutable_svnamespace() {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2os.sVnamespace)
  return svnamespace_;
}
inline ::std::string* PrtoL2os::release_svnamespace() {
  clear_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnamespace_;
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2os::set_allocated_svnamespace(::std::string* svnamespace) {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnamespace_;
  }
  if (svnamespace) {
    set_has_svnamespace();
    svnamespace_ = svnamespace;
  } else {
    clear_has_svnamespace();
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2os.sVnamespace)
}

// required bytes sVosqlstring = 2;
inline bool PrtoL2os::has_svosqlstring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2os::set_has_svosqlstring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2os::clear_has_svosqlstring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2os::clear_svosqlstring() {
  if (svosqlstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svosqlstring_->clear();
  }
  clear_has_svosqlstring();
}
inline const ::std::string& PrtoL2os::svosqlstring() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.sVosqlstring)
  return *svosqlstring_;
}
inline void PrtoL2os::set_svosqlstring(const ::std::string& value) {
  set_has_svosqlstring();
  if (svosqlstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svosqlstring_ = new ::std::string;
  }
  svosqlstring_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2os.sVosqlstring)
}
inline void PrtoL2os::set_svosqlstring(const char* value) {
  set_has_svosqlstring();
  if (svosqlstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svosqlstring_ = new ::std::string;
  }
  svosqlstring_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2os.sVosqlstring)
}
inline void PrtoL2os::set_svosqlstring(const void* value, size_t size) {
  set_has_svosqlstring();
  if (svosqlstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svosqlstring_ = new ::std::string;
  }
  svosqlstring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2os.sVosqlstring)
}
inline ::std::string* PrtoL2os::mutable_svosqlstring() {
  set_has_svosqlstring();
  if (svosqlstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svosqlstring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2os.sVosqlstring)
  return svosqlstring_;
}
inline ::std::string* PrtoL2os::release_svosqlstring() {
  clear_has_svosqlstring();
  if (svosqlstring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svosqlstring_;
    svosqlstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2os::set_allocated_svosqlstring(::std::string* svosqlstring) {
  if (svosqlstring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svosqlstring_;
  }
  if (svosqlstring) {
    set_has_svosqlstring();
    svosqlstring_ = svosqlstring;
  } else {
    clear_has_svosqlstring();
    svosqlstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2os.sVosqlstring)
}

// repeated .com.tomting.orion.PrtoL2cv cVinputbindings = 3;
inline int PrtoL2os::cvinputbindings_size() const {
  return cvinputbindings_.size();
}
inline void PrtoL2os::clear_cvinputbindings() {
  cvinputbindings_.Clear();
}
inline const ::com::tomting::orion::PrtoL2cv& PrtoL2os::cvinputbindings(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.cVinputbindings)
  return cvinputbindings_.Get(index);
}
inline ::com::tomting::orion::PrtoL2cv* PrtoL2os::mutable_cvinputbindings(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2os.cVinputbindings)
  return cvinputbindings_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2cv* PrtoL2os::add_cvinputbindings() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2os.cVinputbindings)
  return cvinputbindings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cv >&
PrtoL2os::cvinputbindings() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2os.cVinputbindings)
  return cvinputbindings_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2cv >*
PrtoL2os::mutable_cvinputbindings() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2os.cVinputbindings)
  return &cvinputbindings_;
}

// optional bool bVonlysecondary = 4 [default = false];
inline bool PrtoL2os::has_bvonlysecondary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoL2os::set_has_bvonlysecondary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoL2os::clear_has_bvonlysecondary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoL2os::clear_bvonlysecondary() {
  bvonlysecondary_ = false;
  clear_has_bvonlysecondary();
}
inline bool PrtoL2os::bvonlysecondary() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.bVonlysecondary)
  return bvonlysecondary_;
}
inline void PrtoL2os::set_bvonlysecondary(bool value) {
  set_has_bvonlysecondary();
  bvonlysecondary_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2os.bVonlysecondary)
}

// optional bool bVdisableteleport = 5 [default = false];
inline bool PrtoL2os::has_bvdisableteleport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoL2os::set_has_bvdisableteleport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoL2os::clear_has_bvdisableteleport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoL2os::clear_bvdisableteleport() {
  bvdisableteleport_ = false;
  clear_has_bvdisableteleport();
}
inline bool PrtoL2os::bvdisableteleport() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.bVdisableteleport)
  return bvdisableteleport_;
}
inline void PrtoL2os::set_bvdisableteleport(bool value) {
  set_has_bvdisableteleport();
  bvdisableteleport_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2os.bVdisableteleport)
}

// optional int64 iVtimestamp = 6 [default = 0];
inline bool PrtoL2os::has_ivtimestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoL2os::set_has_ivtimestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoL2os::clear_has_ivtimestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoL2os::clear_ivtimestamp() {
  ivtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ivtimestamp();
}
inline ::google::protobuf::int64 PrtoL2os::ivtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.iVtimestamp)
  return ivtimestamp_;
}
inline void PrtoL2os::set_ivtimestamp(::google::protobuf::int64 value) {
  set_has_ivtimestamp();
  ivtimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2os.iVtimestamp)
}

// optional bool bVfulltablescan = 7 [default = false];
inline bool PrtoL2os::has_bvfulltablescan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoL2os::set_has_bvfulltablescan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoL2os::clear_has_bvfulltablescan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoL2os::clear_bvfulltablescan() {
  bvfulltablescan_ = false;
  clear_has_bvfulltablescan();
}
inline bool PrtoL2os::bvfulltablescan() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2os.bVfulltablescan)
  return bvfulltablescan_;
}
inline void PrtoL2os::set_bvfulltablescan(bool value) {
  set_has_bvfulltablescan();
  bvfulltablescan_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2os.bVfulltablescan)
}

// -------------------------------------------------------------------

// PrtoL1mr

// optional .com.tomting.orion.PrtoLkey cVkey = 1;
inline bool PrtoL1mr::has_cvkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoL1mr::set_has_cvkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoL1mr::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoL1mr::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoL1mr::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL1mr.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL1mr::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL1mr.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoL1mr::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoL1mr::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL1mr.cVkey)
}

// optional .com.tomting.orion.PrtoLval cVvalue = 2;
inline bool PrtoL1mr::has_cvvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL1mr::set_has_cvvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL1mr::clear_has_cvvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL1mr::clear_cvvalue() {
  if (cvvalue_ != NULL) cvvalue_->::com::tomting::orion::PrtoLval::Clear();
  clear_has_cvvalue();
}
inline const ::com::tomting::orion::PrtoLval& PrtoL1mr::cvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL1mr.cVvalue)
  return cvvalue_ != NULL ? *cvvalue_ : *default_instance_->cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoL1mr::mutable_cvvalue() {
  set_has_cvvalue();
  if (cvvalue_ == NULL) cvvalue_ = new ::com::tomting::orion::PrtoLval;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL1mr.cVvalue)
  return cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoL1mr::release_cvvalue() {
  clear_has_cvvalue();
  ::com::tomting::orion::PrtoLval* temp = cvvalue_;
  cvvalue_ = NULL;
  return temp;
}
inline void PrtoL1mr::set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue) {
  delete cvvalue_;
  cvvalue_ = cvvalue;
  if (cvvalue) {
    set_has_cvvalue();
  } else {
    clear_has_cvvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL1mr.cVvalue)
}

// -------------------------------------------------------------------

// PrtoL2mr

// repeated .com.tomting.orion.PrtoL2ks cVkeyslice = 1;
inline int PrtoL2mr::cvkeyslice_size() const {
  return cvkeyslice_.size();
}
inline void PrtoL2mr::clear_cvkeyslice() {
  cvkeyslice_.Clear();
}
inline const ::com::tomting::orion::PrtoL2ks& PrtoL2mr::cvkeyslice(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2mr.cVkeyslice)
  return cvkeyslice_.Get(index);
}
inline ::com::tomting::orion::PrtoL2ks* PrtoL2mr::mutable_cvkeyslice(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2mr.cVkeyslice)
  return cvkeyslice_.Mutable(index);
}
inline ::com::tomting::orion::PrtoL2ks* PrtoL2mr::add_cvkeyslice() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2mr.cVkeyslice)
  return cvkeyslice_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ks >&
PrtoL2mr::cvkeyslice() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2mr.cVkeyslice)
  return cvkeyslice_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoL2ks >*
PrtoL2mr::mutable_cvkeyslice() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2mr.cVkeyslice)
  return &cvkeyslice_;
}

// -------------------------------------------------------------------

// PrtoL2iv

// repeated int32 iVkeydelimiters = 1;
inline int PrtoL2iv::ivkeydelimiters_size() const {
  return ivkeydelimiters_.size();
}
inline void PrtoL2iv::clear_ivkeydelimiters() {
  ivkeydelimiters_.Clear();
}
inline ::google::protobuf::int32 PrtoL2iv::ivkeydelimiters(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2iv.iVkeydelimiters)
  return ivkeydelimiters_.Get(index);
}
inline void PrtoL2iv::set_ivkeydelimiters(int index, ::google::protobuf::int32 value) {
  ivkeydelimiters_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2iv.iVkeydelimiters)
}
inline void PrtoL2iv::add_ivkeydelimiters(::google::protobuf::int32 value) {
  ivkeydelimiters_.Add(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoL2iv.iVkeydelimiters)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PrtoL2iv::ivkeydelimiters() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoL2iv.iVkeydelimiters)
  return ivkeydelimiters_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PrtoL2iv::mutable_ivkeydelimiters() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoL2iv.iVkeydelimiters)
  return &ivkeydelimiters_;
}

// required bytes sVoriginalkey = 2;
inline bool PrtoL2iv::has_svoriginalkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoL2iv::set_has_svoriginalkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoL2iv::clear_has_svoriginalkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoL2iv::clear_svoriginalkey() {
  if (svoriginalkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svoriginalkey_->clear();
  }
  clear_has_svoriginalkey();
}
inline const ::std::string& PrtoL2iv::svoriginalkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoL2iv.sVoriginalkey)
  return *svoriginalkey_;
}
inline void PrtoL2iv::set_svoriginalkey(const ::std::string& value) {
  set_has_svoriginalkey();
  if (svoriginalkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svoriginalkey_ = new ::std::string;
  }
  svoriginalkey_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoL2iv.sVoriginalkey)
}
inline void PrtoL2iv::set_svoriginalkey(const char* value) {
  set_has_svoriginalkey();
  if (svoriginalkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svoriginalkey_ = new ::std::string;
  }
  svoriginalkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoL2iv.sVoriginalkey)
}
inline void PrtoL2iv::set_svoriginalkey(const void* value, size_t size) {
  set_has_svoriginalkey();
  if (svoriginalkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svoriginalkey_ = new ::std::string;
  }
  svoriginalkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoL2iv.sVoriginalkey)
}
inline ::std::string* PrtoL2iv::mutable_svoriginalkey() {
  set_has_svoriginalkey();
  if (svoriginalkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svoriginalkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoL2iv.sVoriginalkey)
  return svoriginalkey_;
}
inline ::std::string* PrtoL2iv::release_svoriginalkey() {
  clear_has_svoriginalkey();
  if (svoriginalkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svoriginalkey_;
    svoriginalkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoL2iv::set_allocated_svoriginalkey(::std::string* svoriginalkey) {
  if (svoriginalkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svoriginalkey_;
  }
  if (svoriginalkey) {
    set_has_svoriginalkey();
    svoriginalkey_ = svoriginalkey;
  } else {
    clear_has_svoriginalkey();
    svoriginalkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoL2iv.sVoriginalkey)
}

// -------------------------------------------------------------------

// PrtoGoel

// required bytes sVtoken = 1;
inline bool PrtoGoel::has_svtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoGoel::set_has_svtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoGoel::clear_has_svtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoGoel::clear_svtoken() {
  if (svtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtoken_->clear();
  }
  clear_has_svtoken();
}
inline const ::std::string& PrtoGoel::svtoken() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.sVtoken)
  return *svtoken_;
}
inline void PrtoGoel::set_svtoken(const ::std::string& value) {
  set_has_svtoken();
  if (svtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtoken_ = new ::std::string;
  }
  svtoken_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.sVtoken)
}
inline void PrtoGoel::set_svtoken(const char* value) {
  set_has_svtoken();
  if (svtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtoken_ = new ::std::string;
  }
  svtoken_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoGoel.sVtoken)
}
inline void PrtoGoel::set_svtoken(const void* value, size_t size) {
  set_has_svtoken();
  if (svtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtoken_ = new ::std::string;
  }
  svtoken_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoGoel.sVtoken)
}
inline ::std::string* PrtoGoel::mutable_svtoken() {
  set_has_svtoken();
  if (svtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtoken_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoel.sVtoken)
  return svtoken_;
}
inline ::std::string* PrtoGoel::release_svtoken() {
  clear_has_svtoken();
  if (svtoken_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtoken_;
    svtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoGoel::set_allocated_svtoken(::std::string* svtoken) {
  if (svtoken_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtoken_;
  }
  if (svtoken) {
    set_has_svtoken();
    svtoken_ = svtoken;
  } else {
    clear_has_svtoken();
    svtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGoel.sVtoken)
}

// required bytes sVnodeid = 2;
inline bool PrtoGoel::has_svnodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoGoel::set_has_svnodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoGoel::clear_has_svnodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoGoel::clear_svnodeid() {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_->clear();
  }
  clear_has_svnodeid();
}
inline const ::std::string& PrtoGoel::svnodeid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.sVnodeid)
  return *svnodeid_;
}
inline void PrtoGoel::set_svnodeid(const ::std::string& value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.sVnodeid)
}
inline void PrtoGoel::set_svnodeid(const char* value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoGoel.sVnodeid)
}
inline void PrtoGoel::set_svnodeid(const void* value, size_t size) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoGoel.sVnodeid)
}
inline ::std::string* PrtoGoel::mutable_svnodeid() {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoel.sVnodeid)
  return svnodeid_;
}
inline ::std::string* PrtoGoel::release_svnodeid() {
  clear_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnodeid_;
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoGoel::set_allocated_svnodeid(::std::string* svnodeid) {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnodeid_;
  }
  if (svnodeid) {
    set_has_svnodeid();
    svnodeid_ = svnodeid;
  } else {
    clear_has_svnodeid();
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGoel.sVnodeid)
}

// required bytes sVdatacenterid = 3;
inline bool PrtoGoel::has_svdatacenterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoGoel::set_has_svdatacenterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoGoel::clear_has_svdatacenterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoGoel::clear_svdatacenterid() {
  if (svdatacenterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatacenterid_->clear();
  }
  clear_has_svdatacenterid();
}
inline const ::std::string& PrtoGoel::svdatacenterid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.sVdatacenterid)
  return *svdatacenterid_;
}
inline void PrtoGoel::set_svdatacenterid(const ::std::string& value) {
  set_has_svdatacenterid();
  if (svdatacenterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatacenterid_ = new ::std::string;
  }
  svdatacenterid_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.sVdatacenterid)
}
inline void PrtoGoel::set_svdatacenterid(const char* value) {
  set_has_svdatacenterid();
  if (svdatacenterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatacenterid_ = new ::std::string;
  }
  svdatacenterid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoGoel.sVdatacenterid)
}
inline void PrtoGoel::set_svdatacenterid(const void* value, size_t size) {
  set_has_svdatacenterid();
  if (svdatacenterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatacenterid_ = new ::std::string;
  }
  svdatacenterid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoGoel.sVdatacenterid)
}
inline ::std::string* PrtoGoel::mutable_svdatacenterid() {
  set_has_svdatacenterid();
  if (svdatacenterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatacenterid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoel.sVdatacenterid)
  return svdatacenterid_;
}
inline ::std::string* PrtoGoel::release_svdatacenterid() {
  clear_has_svdatacenterid();
  if (svdatacenterid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svdatacenterid_;
    svdatacenterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoGoel::set_allocated_svdatacenterid(::std::string* svdatacenterid) {
  if (svdatacenterid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svdatacenterid_;
  }
  if (svdatacenterid) {
    set_has_svdatacenterid();
    svdatacenterid_ = svdatacenterid;
  } else {
    clear_has_svdatacenterid();
    svdatacenterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGoel.sVdatacenterid)
}

// optional double dVphiaccrual = 4;
inline bool PrtoGoel::has_dvphiaccrual() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoGoel::set_has_dvphiaccrual() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoGoel::clear_has_dvphiaccrual() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoGoel::clear_dvphiaccrual() {
  dvphiaccrual_ = 0;
  clear_has_dvphiaccrual();
}
inline double PrtoGoel::dvphiaccrual() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.dVphiaccrual)
  return dvphiaccrual_;
}
inline void PrtoGoel::set_dvphiaccrual(double value) {
  set_has_dvphiaccrual();
  dvphiaccrual_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.dVphiaccrual)
}

// optional bytes sVaddress = 5;
inline bool PrtoGoel::has_svaddress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoGoel::set_has_svaddress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoGoel::clear_has_svaddress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoGoel::clear_svaddress() {
  if (svaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaddress_->clear();
  }
  clear_has_svaddress();
}
inline const ::std::string& PrtoGoel::svaddress() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.sVaddress)
  return *svaddress_;
}
inline void PrtoGoel::set_svaddress(const ::std::string& value) {
  set_has_svaddress();
  if (svaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaddress_ = new ::std::string;
  }
  svaddress_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.sVaddress)
}
inline void PrtoGoel::set_svaddress(const char* value) {
  set_has_svaddress();
  if (svaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaddress_ = new ::std::string;
  }
  svaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoGoel.sVaddress)
}
inline void PrtoGoel::set_svaddress(const void* value, size_t size) {
  set_has_svaddress();
  if (svaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaddress_ = new ::std::string;
  }
  svaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoGoel.sVaddress)
}
inline ::std::string* PrtoGoel::mutable_svaddress() {
  set_has_svaddress();
  if (svaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoel.sVaddress)
  return svaddress_;
}
inline ::std::string* PrtoGoel::release_svaddress() {
  clear_has_svaddress();
  if (svaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svaddress_;
    svaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoGoel::set_allocated_svaddress(::std::string* svaddress) {
  if (svaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svaddress_;
  }
  if (svaddress) {
    set_has_svaddress();
    svaddress_ = svaddress;
  } else {
    clear_has_svaddress();
    svaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGoel.sVaddress)
}

// optional int32 iVport = 6;
inline bool PrtoGoel::has_ivport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoGoel::set_has_ivport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoGoel::clear_has_ivport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoGoel::clear_ivport() {
  ivport_ = 0;
  clear_has_ivport();
}
inline ::google::protobuf::int32 PrtoGoel::ivport() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.iVport)
  return ivport_;
}
inline void PrtoGoel::set_ivport(::google::protobuf::int32 value) {
  set_has_ivport();
  ivport_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.iVport)
}

// optional bytes sVreader = 7;
inline bool PrtoGoel::has_svreader() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoGoel::set_has_svreader() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoGoel::clear_has_svreader() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoGoel::clear_svreader() {
  if (svreader_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svreader_->clear();
  }
  clear_has_svreader();
}
inline const ::std::string& PrtoGoel::svreader() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.sVreader)
  return *svreader_;
}
inline void PrtoGoel::set_svreader(const ::std::string& value) {
  set_has_svreader();
  if (svreader_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svreader_ = new ::std::string;
  }
  svreader_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.sVreader)
}
inline void PrtoGoel::set_svreader(const char* value) {
  set_has_svreader();
  if (svreader_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svreader_ = new ::std::string;
  }
  svreader_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoGoel.sVreader)
}
inline void PrtoGoel::set_svreader(const void* value, size_t size) {
  set_has_svreader();
  if (svreader_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svreader_ = new ::std::string;
  }
  svreader_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoGoel.sVreader)
}
inline ::std::string* PrtoGoel::mutable_svreader() {
  set_has_svreader();
  if (svreader_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svreader_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoel.sVreader)
  return svreader_;
}
inline ::std::string* PrtoGoel::release_svreader() {
  clear_has_svreader();
  if (svreader_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svreader_;
    svreader_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoGoel::set_allocated_svreader(::std::string* svreader) {
  if (svreader_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svreader_;
  }
  if (svreader) {
    set_has_svreader();
    svreader_ = svreader;
  } else {
    clear_has_svreader();
    svreader_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGoel.sVreader)
}

// optional bytes sVwriter = 8;
inline bool PrtoGoel::has_svwriter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoGoel::set_has_svwriter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoGoel::clear_has_svwriter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoGoel::clear_svwriter() {
  if (svwriter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svwriter_->clear();
  }
  clear_has_svwriter();
}
inline const ::std::string& PrtoGoel::svwriter() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.sVwriter)
  return *svwriter_;
}
inline void PrtoGoel::set_svwriter(const ::std::string& value) {
  set_has_svwriter();
  if (svwriter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svwriter_ = new ::std::string;
  }
  svwriter_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.sVwriter)
}
inline void PrtoGoel::set_svwriter(const char* value) {
  set_has_svwriter();
  if (svwriter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svwriter_ = new ::std::string;
  }
  svwriter_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoGoel.sVwriter)
}
inline void PrtoGoel::set_svwriter(const void* value, size_t size) {
  set_has_svwriter();
  if (svwriter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svwriter_ = new ::std::string;
  }
  svwriter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoGoel.sVwriter)
}
inline ::std::string* PrtoGoel::mutable_svwriter() {
  set_has_svwriter();
  if (svwriter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svwriter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoel.sVwriter)
  return svwriter_;
}
inline ::std::string* PrtoGoel::release_svwriter() {
  clear_has_svwriter();
  if (svwriter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svwriter_;
    svwriter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoGoel::set_allocated_svwriter(::std::string* svwriter) {
  if (svwriter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svwriter_;
  }
  if (svwriter) {
    set_has_svwriter();
    svwriter_ = svwriter;
  } else {
    clear_has_svwriter();
    svwriter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGoel.sVwriter)
}

// optional .com.tomting.orion.iCstategossipnode iVstate = 9;
inline bool PrtoGoel::has_ivstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PrtoGoel::set_has_ivstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PrtoGoel::clear_has_ivstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PrtoGoel::clear_ivstate() {
  ivstate_ = 0;
  clear_has_ivstate();
}
inline ::com::tomting::orion::iCstategossipnode PrtoGoel::ivstate() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.iVstate)
  return static_cast< ::com::tomting::orion::iCstategossipnode >(ivstate_);
}
inline void PrtoGoel::set_ivstate(::com::tomting::orion::iCstategossipnode value) {
  assert(::com::tomting::orion::iCstategossipnode_IsValid(value));
  set_has_ivstate();
  ivstate_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.iVstate)
}

// optional int64 iVtimestamp = 10;
inline bool PrtoGoel::has_ivtimestamp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PrtoGoel::set_has_ivtimestamp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PrtoGoel::clear_has_ivtimestamp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PrtoGoel::clear_ivtimestamp() {
  ivtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ivtimestamp();
}
inline ::google::protobuf::int64 PrtoGoel::ivtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.iVtimestamp)
  return ivtimestamp_;
}
inline void PrtoGoel::set_ivtimestamp(::google::protobuf::int64 value) {
  set_has_ivtimestamp();
  ivtimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.iVtimestamp)
}

// optional int64 iVsize = 11;
inline bool PrtoGoel::has_ivsize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PrtoGoel::set_has_ivsize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PrtoGoel::clear_has_ivsize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PrtoGoel::clear_ivsize() {
  ivsize_ = GOOGLE_LONGLONG(0);
  clear_has_ivsize();
}
inline ::google::protobuf::int64 PrtoGoel::ivsize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoel.iVsize)
  return ivsize_;
}
inline void PrtoGoel::set_ivsize(::google::protobuf::int64 value) {
  set_has_ivsize();
  ivsize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoGoel.iVsize)
}

// -------------------------------------------------------------------

// PrtoGoss

// repeated .com.tomting.orion.PrtoGoel cVgossipelement = 1;
inline int PrtoGoss::cvgossipelement_size() const {
  return cvgossipelement_.size();
}
inline void PrtoGoss::clear_cvgossipelement() {
  cvgossipelement_.Clear();
}
inline const ::com::tomting::orion::PrtoGoel& PrtoGoss::cvgossipelement(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGoss.cVgossipelement)
  return cvgossipelement_.Get(index);
}
inline ::com::tomting::orion::PrtoGoel* PrtoGoss::mutable_cvgossipelement(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGoss.cVgossipelement)
  return cvgossipelement_.Mutable(index);
}
inline ::com::tomting::orion::PrtoGoel* PrtoGoss::add_cvgossipelement() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoGoss.cVgossipelement)
  return cvgossipelement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >&
PrtoGoss::cvgossipelement() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoGoss.cVgossipelement)
  return cvgossipelement_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >*
PrtoGoss::mutable_cvgossipelement() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoGoss.cVgossipelement)
  return &cvgossipelement_;
}

// -------------------------------------------------------------------

// PrtoGosr

// required .com.tomting.orion.PrtoGoel cVgossipelement = 1;
inline bool PrtoGosr::has_cvgossipelement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoGosr::set_has_cvgossipelement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoGosr::clear_has_cvgossipelement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoGosr::clear_cvgossipelement() {
  if (cvgossipelement_ != NULL) cvgossipelement_->::com::tomting::orion::PrtoGoel::Clear();
  clear_has_cvgossipelement();
}
inline const ::com::tomting::orion::PrtoGoel& PrtoGosr::cvgossipelement() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoGosr.cVgossipelement)
  return cvgossipelement_ != NULL ? *cvgossipelement_ : *default_instance_->cvgossipelement_;
}
inline ::com::tomting::orion::PrtoGoel* PrtoGosr::mutable_cvgossipelement() {
  set_has_cvgossipelement();
  if (cvgossipelement_ == NULL) cvgossipelement_ = new ::com::tomting::orion::PrtoGoel;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoGosr.cVgossipelement)
  return cvgossipelement_;
}
inline ::com::tomting::orion::PrtoGoel* PrtoGosr::release_cvgossipelement() {
  clear_has_cvgossipelement();
  ::com::tomting::orion::PrtoGoel* temp = cvgossipelement_;
  cvgossipelement_ = NULL;
  return temp;
}
inline void PrtoGosr::set_allocated_cvgossipelement(::com::tomting::orion::PrtoGoel* cvgossipelement) {
  delete cvgossipelement_;
  cvgossipelement_ = cvgossipelement;
  if (cvgossipelement) {
    set_has_cvgossipelement();
  } else {
    clear_has_cvgossipelement();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoGosr.cVgossipelement)
}

// -------------------------------------------------------------------

// PrtoHiha

// required bytes sVnode = 1;
inline bool PrtoHiha::has_svnode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoHiha::set_has_svnode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoHiha::clear_has_svnode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoHiha::clear_svnode() {
  if (svnode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnode_->clear();
  }
  clear_has_svnode();
}
inline const ::std::string& PrtoHiha::svnode() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoHiha.sVnode)
  return *svnode_;
}
inline void PrtoHiha::set_svnode(const ::std::string& value) {
  set_has_svnode();
  if (svnode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnode_ = new ::std::string;
  }
  svnode_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoHiha.sVnode)
}
inline void PrtoHiha::set_svnode(const char* value) {
  set_has_svnode();
  if (svnode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnode_ = new ::std::string;
  }
  svnode_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoHiha.sVnode)
}
inline void PrtoHiha::set_svnode(const void* value, size_t size) {
  set_has_svnode();
  if (svnode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnode_ = new ::std::string;
  }
  svnode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoHiha.sVnode)
}
inline ::std::string* PrtoHiha::mutable_svnode() {
  set_has_svnode();
  if (svnode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoHiha.sVnode)
  return svnode_;
}
inline ::std::string* PrtoHiha::release_svnode() {
  clear_has_svnode();
  if (svnode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnode_;
    svnode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoHiha::set_allocated_svnode(::std::string* svnode) {
  if (svnode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnode_;
  }
  if (svnode) {
    set_has_svnode();
    svnode_ = svnode;
  } else {
    clear_has_svnode();
    svnode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoHiha.sVnode)
}

// required .com.tomting.orion.PrtoLsts cVstatements = 2;
inline bool PrtoHiha::has_cvstatements() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoHiha::set_has_cvstatements() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoHiha::clear_has_cvstatements() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoHiha::clear_cvstatements() {
  if (cvstatements_ != NULL) cvstatements_->::com::tomting::orion::PrtoLsts::Clear();
  clear_has_cvstatements();
}
inline const ::com::tomting::orion::PrtoLsts& PrtoHiha::cvstatements() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoHiha.cVstatements)
  return cvstatements_ != NULL ? *cvstatements_ : *default_instance_->cvstatements_;
}
inline ::com::tomting::orion::PrtoLsts* PrtoHiha::mutable_cvstatements() {
  set_has_cvstatements();
  if (cvstatements_ == NULL) cvstatements_ = new ::com::tomting::orion::PrtoLsts;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoHiha.cVstatements)
  return cvstatements_;
}
inline ::com::tomting::orion::PrtoLsts* PrtoHiha::release_cvstatements() {
  clear_has_cvstatements();
  ::com::tomting::orion::PrtoLsts* temp = cvstatements_;
  cvstatements_ = NULL;
  return temp;
}
inline void PrtoHiha::set_allocated_cvstatements(::com::tomting::orion::PrtoLsts* cvstatements) {
  delete cvstatements_;
  cvstatements_ = cvstatements;
  if (cvstatements) {
    set_has_cvstatements();
  } else {
    clear_has_cvstatements();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoHiha.cVstatements)
}

// -------------------------------------------------------------------

// PrtoPtel

// required bytes sVnodeid = 1;
inline bool PrtoPtel::has_svnodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoPtel::set_has_svnodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoPtel::clear_has_svnodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoPtel::clear_svnodeid() {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_->clear();
  }
  clear_has_svnodeid();
}
inline const ::std::string& PrtoPtel::svnodeid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoPtel.sVnodeid)
  return *svnodeid_;
}
inline void PrtoPtel::set_svnodeid(const ::std::string& value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoPtel.sVnodeid)
}
inline void PrtoPtel::set_svnodeid(const char* value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoPtel.sVnodeid)
}
inline void PrtoPtel::set_svnodeid(const void* value, size_t size) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoPtel.sVnodeid)
}
inline ::std::string* PrtoPtel::mutable_svnodeid() {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoPtel.sVnodeid)
  return svnodeid_;
}
inline ::std::string* PrtoPtel::release_svnodeid() {
  clear_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnodeid_;
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoPtel::set_allocated_svnodeid(::std::string* svnodeid) {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnodeid_;
  }
  if (svnodeid) {
    set_has_svnodeid();
    svnodeid_ = svnodeid;
  } else {
    clear_has_svnodeid();
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoPtel.sVnodeid)
}

// required bytes sVbound = 2;
inline bool PrtoPtel::has_svbound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoPtel::set_has_svbound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoPtel::clear_has_svbound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoPtel::clear_svbound() {
  if (svbound_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svbound_->clear();
  }
  clear_has_svbound();
}
inline const ::std::string& PrtoPtel::svbound() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoPtel.sVbound)
  return *svbound_;
}
inline void PrtoPtel::set_svbound(const ::std::string& value) {
  set_has_svbound();
  if (svbound_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svbound_ = new ::std::string;
  }
  svbound_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoPtel.sVbound)
}
inline void PrtoPtel::set_svbound(const char* value) {
  set_has_svbound();
  if (svbound_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svbound_ = new ::std::string;
  }
  svbound_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoPtel.sVbound)
}
inline void PrtoPtel::set_svbound(const void* value, size_t size) {
  set_has_svbound();
  if (svbound_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svbound_ = new ::std::string;
  }
  svbound_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoPtel.sVbound)
}
inline ::std::string* PrtoPtel::mutable_svbound() {
  set_has_svbound();
  if (svbound_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svbound_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoPtel.sVbound)
  return svbound_;
}
inline ::std::string* PrtoPtel::release_svbound() {
  clear_has_svbound();
  if (svbound_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svbound_;
    svbound_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoPtel::set_allocated_svbound(::std::string* svbound) {
  if (svbound_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svbound_;
  }
  if (svbound) {
    set_has_svbound();
    svbound_ = svbound;
  } else {
    clear_has_svbound();
    svbound_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoPtel.sVbound)
}

// -------------------------------------------------------------------

// PrtoStel

// required int64 iVcount = 1;
inline bool PrtoStel::has_ivcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoStel::set_has_ivcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoStel::clear_has_ivcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoStel::clear_ivcount() {
  ivcount_ = GOOGLE_LONGLONG(0);
  clear_has_ivcount();
}
inline ::google::protobuf::int64 PrtoStel::ivcount() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStel.iVcount)
  return ivcount_;
}
inline void PrtoStel::set_ivcount(::google::protobuf::int64 value) {
  set_has_ivcount();
  ivcount_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStel.iVcount)
}

// required int32 iVmeandelay = 2;
inline bool PrtoStel::has_ivmeandelay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoStel::set_has_ivmeandelay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoStel::clear_has_ivmeandelay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoStel::clear_ivmeandelay() {
  ivmeandelay_ = 0;
  clear_has_ivmeandelay();
}
inline ::google::protobuf::int32 PrtoStel::ivmeandelay() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStel.iVmeandelay)
  return ivmeandelay_;
}
inline void PrtoStel::set_ivmeandelay(::google::protobuf::int32 value) {
  set_has_ivmeandelay();
  ivmeandelay_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStel.iVmeandelay)
}

// required int32 iVworstdelay = 3;
inline bool PrtoStel::has_ivworstdelay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoStel::set_has_ivworstdelay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoStel::clear_has_ivworstdelay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoStel::clear_ivworstdelay() {
  ivworstdelay_ = 0;
  clear_has_ivworstdelay();
}
inline ::google::protobuf::int32 PrtoStel::ivworstdelay() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStel.iVworstdelay)
  return ivworstdelay_;
}
inline void PrtoStel::set_ivworstdelay(::google::protobuf::int32 value) {
  set_has_ivworstdelay();
  ivworstdelay_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStel.iVworstdelay)
}

// required int64 iVsize = 4;
inline bool PrtoStel::has_ivsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoStel::set_has_ivsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoStel::clear_has_ivsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoStel::clear_ivsize() {
  ivsize_ = GOOGLE_LONGLONG(0);
  clear_has_ivsize();
}
inline ::google::protobuf::int64 PrtoStel::ivsize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStel.iVsize)
  return ivsize_;
}
inline void PrtoStel::set_ivsize(::google::protobuf::int64 value) {
  set_has_ivsize();
  ivsize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStel.iVsize)
}

// optional int64 iVelapsed = 5;
inline bool PrtoStel::has_ivelapsed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoStel::set_has_ivelapsed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoStel::clear_has_ivelapsed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoStel::clear_ivelapsed() {
  ivelapsed_ = GOOGLE_LONGLONG(0);
  clear_has_ivelapsed();
}
inline ::google::protobuf::int64 PrtoStel::ivelapsed() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoStel.iVelapsed)
  return ivelapsed_;
}
inline void PrtoStel::set_ivelapsed(::google::protobuf::int64 value) {
  set_has_ivelapsed();
  ivelapsed_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoStel.iVelapsed)
}

// -------------------------------------------------------------------

// PrtoTlel

// required .com.tomting.orion.iCtablettype iVtablettype = 1;
inline bool PrtoTlel::has_ivtablettype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoTlel::set_has_ivtablettype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoTlel::clear_has_ivtablettype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoTlel::clear_ivtablettype() {
  ivtablettype_ = 0;
  clear_has_ivtablettype();
}
inline ::com::tomting::orion::iCtablettype PrtoTlel::ivtablettype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVtablettype)
  return static_cast< ::com::tomting::orion::iCtablettype >(ivtablettype_);
}
inline void PrtoTlel::set_ivtablettype(::com::tomting::orion::iCtablettype value) {
  assert(::com::tomting::orion::iCtablettype_IsValid(value));
  set_has_ivtablettype();
  ivtablettype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVtablettype)
}

// required bytes sVname = 2;
inline bool PrtoTlel::has_svname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoTlel::set_has_svname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoTlel::clear_has_svname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoTlel::clear_svname() {
  if (svname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_->clear();
  }
  clear_has_svname();
}
inline const ::std::string& PrtoTlel::svname() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.sVname)
  return *svname_;
}
inline void PrtoTlel::set_svname(const ::std::string& value) {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  svname_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.sVname)
}
inline void PrtoTlel::set_svname(const char* value) {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  svname_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTlel.sVname)
}
inline void PrtoTlel::set_svname(const void* value, size_t size) {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  svname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTlel.sVname)
}
inline ::std::string* PrtoTlel::mutable_svname() {
  set_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTlel.sVname)
  return svname_;
}
inline ::std::string* PrtoTlel::release_svname() {
  clear_has_svname();
  if (svname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svname_;
    svname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTlel::set_allocated_svname(::std::string* svname) {
  if (svname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svname_;
  }
  if (svname) {
    set_has_svname();
    svname_ = svname;
  } else {
    clear_has_svname();
    svname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTlel.sVname)
}

// required bool bVvalid = 3;
inline bool PrtoTlel::has_bvvalid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoTlel::set_has_bvvalid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoTlel::clear_has_bvvalid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoTlel::clear_bvvalid() {
  bvvalid_ = false;
  clear_has_bvvalid();
}
inline bool PrtoTlel::bvvalid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.bVvalid)
  return bvvalid_;
}
inline void PrtoTlel::set_bvvalid(bool value) {
  set_has_bvvalid();
  bvvalid_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.bVvalid)
}

// required bool bVneedcompaction = 4;
inline bool PrtoTlel::has_bvneedcompaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoTlel::set_has_bvneedcompaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoTlel::clear_has_bvneedcompaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoTlel::clear_bvneedcompaction() {
  bvneedcompaction_ = false;
  clear_has_bvneedcompaction();
}
inline bool PrtoTlel::bvneedcompaction() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.bVneedcompaction)
  return bvneedcompaction_;
}
inline void PrtoTlel::set_bvneedcompaction(bool value) {
  set_has_bvneedcompaction();
  bvneedcompaction_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.bVneedcompaction)
}

// required bool bVvalidasmemorytable = 5;
inline bool PrtoTlel::has_bvvalidasmemorytable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoTlel::set_has_bvvalidasmemorytable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoTlel::clear_has_bvvalidasmemorytable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoTlel::clear_bvvalidasmemorytable() {
  bvvalidasmemorytable_ = false;
  clear_has_bvvalidasmemorytable();
}
inline bool PrtoTlel::bvvalidasmemorytable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.bVvalidasmemorytable)
  return bvvalidasmemorytable_;
}
inline void PrtoTlel::set_bvvalidasmemorytable(bool value) {
  set_has_bvvalidasmemorytable();
  bvvalidasmemorytable_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.bVvalidasmemorytable)
}

// required int32 iVcompactionlevel = 6;
inline bool PrtoTlel::has_ivcompactionlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoTlel::set_has_ivcompactionlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoTlel::clear_has_ivcompactionlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoTlel::clear_ivcompactionlevel() {
  ivcompactionlevel_ = 0;
  clear_has_ivcompactionlevel();
}
inline ::google::protobuf::int32 PrtoTlel::ivcompactionlevel() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVcompactionlevel)
  return ivcompactionlevel_;
}
inline void PrtoTlel::set_ivcompactionlevel(::google::protobuf::int32 value) {
  set_has_ivcompactionlevel();
  ivcompactionlevel_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVcompactionlevel)
}

// required bytes sVmemorytable = 7;
inline bool PrtoTlel::has_svmemorytable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoTlel::set_has_svmemorytable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoTlel::clear_has_svmemorytable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoTlel::clear_svmemorytable() {
  if (svmemorytable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmemorytable_->clear();
  }
  clear_has_svmemorytable();
}
inline const ::std::string& PrtoTlel::svmemorytable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.sVmemorytable)
  return *svmemorytable_;
}
inline void PrtoTlel::set_svmemorytable(const ::std::string& value) {
  set_has_svmemorytable();
  if (svmemorytable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmemorytable_ = new ::std::string;
  }
  svmemorytable_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.sVmemorytable)
}
inline void PrtoTlel::set_svmemorytable(const char* value) {
  set_has_svmemorytable();
  if (svmemorytable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmemorytable_ = new ::std::string;
  }
  svmemorytable_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTlel.sVmemorytable)
}
inline void PrtoTlel::set_svmemorytable(const void* value, size_t size) {
  set_has_svmemorytable();
  if (svmemorytable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmemorytable_ = new ::std::string;
  }
  svmemorytable_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTlel.sVmemorytable)
}
inline ::std::string* PrtoTlel::mutable_svmemorytable() {
  set_has_svmemorytable();
  if (svmemorytable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmemorytable_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTlel.sVmemorytable)
  return svmemorytable_;
}
inline ::std::string* PrtoTlel::release_svmemorytable() {
  clear_has_svmemorytable();
  if (svmemorytable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svmemorytable_;
    svmemorytable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTlel::set_allocated_svmemorytable(::std::string* svmemorytable) {
  if (svmemorytable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svmemorytable_;
  }
  if (svmemorytable) {
    set_has_svmemorytable();
    svmemorytable_ = svmemorytable;
  } else {
    clear_has_svmemorytable();
    svmemorytable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTlel.sVmemorytable)
}

// required int64 iVres = 8;
inline bool PrtoTlel::has_ivres() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoTlel::set_has_ivres() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoTlel::clear_has_ivres() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoTlel::clear_ivres() {
  ivres_ = GOOGLE_LONGLONG(0);
  clear_has_ivres();
}
inline ::google::protobuf::int64 PrtoTlel::ivres() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVres)
  return ivres_;
}
inline void PrtoTlel::set_ivres(::google::protobuf::int64 value) {
  set_has_ivres();
  ivres_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVres)
}

// required int64 iVmapped = 9;
inline bool PrtoTlel::has_ivmapped() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PrtoTlel::set_has_ivmapped() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PrtoTlel::clear_has_ivmapped() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PrtoTlel::clear_ivmapped() {
  ivmapped_ = GOOGLE_LONGLONG(0);
  clear_has_ivmapped();
}
inline ::google::protobuf::int64 PrtoTlel::ivmapped() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVmapped)
  return ivmapped_;
}
inline void PrtoTlel::set_ivmapped(::google::protobuf::int64 value) {
  set_has_ivmapped();
  ivmapped_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVmapped)
}

// required int64 iVsize = 10;
inline bool PrtoTlel::has_ivsize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PrtoTlel::set_has_ivsize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PrtoTlel::clear_has_ivsize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PrtoTlel::clear_ivsize() {
  ivsize_ = GOOGLE_LONGLONG(0);
  clear_has_ivsize();
}
inline ::google::protobuf::int64 PrtoTlel::ivsize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVsize)
  return ivsize_;
}
inline void PrtoTlel::set_ivsize(::google::protobuf::int64 value) {
  set_has_ivsize();
  ivsize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVsize)
}

// required int64 iVcount = 11;
inline bool PrtoTlel::has_ivcount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PrtoTlel::set_has_ivcount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PrtoTlel::clear_has_ivcount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PrtoTlel::clear_ivcount() {
  ivcount_ = GOOGLE_LONGLONG(0);
  clear_has_ivcount();
}
inline ::google::protobuf::int64 PrtoTlel::ivcount() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVcount)
  return ivcount_;
}
inline void PrtoTlel::set_ivcount(::google::protobuf::int64 value) {
  set_has_ivcount();
  ivcount_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVcount)
}

// required bytes sVredotimestamp = 12;
inline bool PrtoTlel::has_svredotimestamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PrtoTlel::set_has_svredotimestamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PrtoTlel::clear_has_svredotimestamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PrtoTlel::clear_svredotimestamp() {
  if (svredotimestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_->clear();
  }
  clear_has_svredotimestamp();
}
inline const ::std::string& PrtoTlel::svredotimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.sVredotimestamp)
  return *svredotimestamp_;
}
inline void PrtoTlel::set_svredotimestamp(const ::std::string& value) {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  svredotimestamp_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.sVredotimestamp)
}
inline void PrtoTlel::set_svredotimestamp(const char* value) {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  svredotimestamp_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTlel.sVredotimestamp)
}
inline void PrtoTlel::set_svredotimestamp(const void* value, size_t size) {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  svredotimestamp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTlel.sVredotimestamp)
}
inline ::std::string* PrtoTlel::mutable_svredotimestamp() {
  set_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredotimestamp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTlel.sVredotimestamp)
  return svredotimestamp_;
}
inline ::std::string* PrtoTlel::release_svredotimestamp() {
  clear_has_svredotimestamp();
  if (svredotimestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svredotimestamp_;
    svredotimestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTlel::set_allocated_svredotimestamp(::std::string* svredotimestamp) {
  if (svredotimestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svredotimestamp_;
  }
  if (svredotimestamp) {
    set_has_svredotimestamp();
    svredotimestamp_ = svredotimestamp;
  } else {
    clear_has_svredotimestamp();
    svredotimestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTlel.sVredotimestamp)
}

// required int32 iVsstabletype = 13;
inline bool PrtoTlel::has_ivsstabletype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PrtoTlel::set_has_ivsstabletype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PrtoTlel::clear_has_ivsstabletype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PrtoTlel::clear_ivsstabletype() {
  ivsstabletype_ = 0;
  clear_has_ivsstabletype();
}
inline ::google::protobuf::int32 PrtoTlel::ivsstabletype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTlel.iVsstabletype)
  return ivsstabletype_;
}
inline void PrtoTlel::set_ivsstabletype(::google::protobuf::int32 value) {
  set_has_ivsstabletype();
  ivsstabletype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTlel.iVsstabletype)
}

// -------------------------------------------------------------------

// PrtoTabl

// required bytes sVxml = 1;
inline bool PrtoTabl::has_svxml() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoTabl::set_has_svxml() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoTabl::clear_has_svxml() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoTabl::clear_svxml() {
  if (svxml_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svxml_->clear();
  }
  clear_has_svxml();
}
inline const ::std::string& PrtoTabl::svxml() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.sVxml)
  return *svxml_;
}
inline void PrtoTabl::set_svxml(const ::std::string& value) {
  set_has_svxml();
  if (svxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svxml_ = new ::std::string;
  }
  svxml_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTabl.sVxml)
}
inline void PrtoTabl::set_svxml(const char* value) {
  set_has_svxml();
  if (svxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svxml_ = new ::std::string;
  }
  svxml_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTabl.sVxml)
}
inline void PrtoTabl::set_svxml(const void* value, size_t size) {
  set_has_svxml();
  if (svxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svxml_ = new ::std::string;
  }
  svxml_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTabl.sVxml)
}
inline ::std::string* PrtoTabl::mutable_svxml() {
  set_has_svxml();
  if (svxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svxml_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.sVxml)
  return svxml_;
}
inline ::std::string* PrtoTabl::release_svxml() {
  clear_has_svxml();
  if (svxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svxml_;
    svxml_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTabl::set_allocated_svxml(::std::string* svxml) {
  if (svxml_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svxml_;
  }
  if (svxml) {
    set_has_svxml();
    svxml_ = svxml;
  } else {
    clear_has_svxml();
    svxml_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTabl.sVxml)
}

// repeated .com.tomting.orion.PrtoPtel cVpartitionedelements = 2;
inline int PrtoTabl::cvpartitionedelements_size() const {
  return cvpartitionedelements_.size();
}
inline void PrtoTabl::clear_cvpartitionedelements() {
  cvpartitionedelements_.Clear();
}
inline const ::com::tomting::orion::PrtoPtel& PrtoTabl::cvpartitionedelements(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.cVpartitionedelements)
  return cvpartitionedelements_.Get(index);
}
inline ::com::tomting::orion::PrtoPtel* PrtoTabl::mutable_cvpartitionedelements(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.cVpartitionedelements)
  return cvpartitionedelements_.Mutable(index);
}
inline ::com::tomting::orion::PrtoPtel* PrtoTabl::add_cvpartitionedelements() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoTabl.cVpartitionedelements)
  return cvpartitionedelements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >&
PrtoTabl::cvpartitionedelements() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoTabl.cVpartitionedelements)
  return cvpartitionedelements_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >*
PrtoTabl::mutable_cvpartitionedelements() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoTabl.cVpartitionedelements)
  return &cvpartitionedelements_;
}

// repeated .com.tomting.orion.PrtoPtel cVpartitionedindexelements = 3;
inline int PrtoTabl::cvpartitionedindexelements_size() const {
  return cvpartitionedindexelements_.size();
}
inline void PrtoTabl::clear_cvpartitionedindexelements() {
  cvpartitionedindexelements_.Clear();
}
inline const ::com::tomting::orion::PrtoPtel& PrtoTabl::cvpartitionedindexelements(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.cVpartitionedindexelements)
  return cvpartitionedindexelements_.Get(index);
}
inline ::com::tomting::orion::PrtoPtel* PrtoTabl::mutable_cvpartitionedindexelements(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.cVpartitionedindexelements)
  return cvpartitionedindexelements_.Mutable(index);
}
inline ::com::tomting::orion::PrtoPtel* PrtoTabl::add_cvpartitionedindexelements() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoTabl.cVpartitionedindexelements)
  return cvpartitionedindexelements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >&
PrtoTabl::cvpartitionedindexelements() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoTabl.cVpartitionedindexelements)
  return cvpartitionedindexelements_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoPtel >*
PrtoTabl::mutable_cvpartitionedindexelements() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoTabl.cVpartitionedindexelements)
  return &cvpartitionedindexelements_;
}

// repeated .com.tomting.orion.PrtoTlel cVtabletelement = 4;
inline int PrtoTabl::cvtabletelement_size() const {
  return cvtabletelement_.size();
}
inline void PrtoTabl::clear_cvtabletelement() {
  cvtabletelement_.Clear();
}
inline const ::com::tomting::orion::PrtoTlel& PrtoTabl::cvtabletelement(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.cVtabletelement)
  return cvtabletelement_.Get(index);
}
inline ::com::tomting::orion::PrtoTlel* PrtoTabl::mutable_cvtabletelement(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.cVtabletelement)
  return cvtabletelement_.Mutable(index);
}
inline ::com::tomting::orion::PrtoTlel* PrtoTabl::add_cvtabletelement() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoTabl.cVtabletelement)
  return cvtabletelement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >&
PrtoTabl::cvtabletelement() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoTabl.cVtabletelement)
  return cvtabletelement_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >*
PrtoTabl::mutable_cvtabletelement() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoTabl.cVtabletelement)
  return &cvtabletelement_;
}

// repeated .com.tomting.orion.PrtoTlel cVindextabletelement = 5;
inline int PrtoTabl::cvindextabletelement_size() const {
  return cvindextabletelement_.size();
}
inline void PrtoTabl::clear_cvindextabletelement() {
  cvindextabletelement_.Clear();
}
inline const ::com::tomting::orion::PrtoTlel& PrtoTabl::cvindextabletelement(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.cVindextabletelement)
  return cvindextabletelement_.Get(index);
}
inline ::com::tomting::orion::PrtoTlel* PrtoTabl::mutable_cvindextabletelement(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.cVindextabletelement)
  return cvindextabletelement_.Mutable(index);
}
inline ::com::tomting::orion::PrtoTlel* PrtoTabl::add_cvindextabletelement() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoTabl.cVindextabletelement)
  return cvindextabletelement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >&
PrtoTabl::cvindextabletelement() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoTabl.cVindextabletelement)
  return cvindextabletelement_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTlel >*
PrtoTabl::mutable_cvindextabletelement() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoTabl.cVindextabletelement)
  return &cvindextabletelement_;
}

// optional bytes sVjoincustompartition = 6;
inline bool PrtoTabl::has_svjoincustompartition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoTabl::set_has_svjoincustompartition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoTabl::clear_has_svjoincustompartition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoTabl::clear_svjoincustompartition() {
  if (svjoincustompartition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartition_->clear();
  }
  clear_has_svjoincustompartition();
}
inline const ::std::string& PrtoTabl::svjoincustompartition() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.sVjoincustompartition)
  return *svjoincustompartition_;
}
inline void PrtoTabl::set_svjoincustompartition(const ::std::string& value) {
  set_has_svjoincustompartition();
  if (svjoincustompartition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartition_ = new ::std::string;
  }
  svjoincustompartition_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTabl.sVjoincustompartition)
}
inline void PrtoTabl::set_svjoincustompartition(const char* value) {
  set_has_svjoincustompartition();
  if (svjoincustompartition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartition_ = new ::std::string;
  }
  svjoincustompartition_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTabl.sVjoincustompartition)
}
inline void PrtoTabl::set_svjoincustompartition(const void* value, size_t size) {
  set_has_svjoincustompartition();
  if (svjoincustompartition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartition_ = new ::std::string;
  }
  svjoincustompartition_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTabl.sVjoincustompartition)
}
inline ::std::string* PrtoTabl::mutable_svjoincustompartition() {
  set_has_svjoincustompartition();
  if (svjoincustompartition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartition_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.sVjoincustompartition)
  return svjoincustompartition_;
}
inline ::std::string* PrtoTabl::release_svjoincustompartition() {
  clear_has_svjoincustompartition();
  if (svjoincustompartition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svjoincustompartition_;
    svjoincustompartition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTabl::set_allocated_svjoincustompartition(::std::string* svjoincustompartition) {
  if (svjoincustompartition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svjoincustompartition_;
  }
  if (svjoincustompartition) {
    set_has_svjoincustompartition();
    svjoincustompartition_ = svjoincustompartition;
  } else {
    clear_has_svjoincustompartition();
    svjoincustompartition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTabl.sVjoincustompartition)
}

// optional bytes sVjoincustompartitionindex = 7;
inline bool PrtoTabl::has_svjoincustompartitionindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoTabl::set_has_svjoincustompartitionindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoTabl::clear_has_svjoincustompartitionindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoTabl::clear_svjoincustompartitionindex() {
  if (svjoincustompartitionindex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartitionindex_->clear();
  }
  clear_has_svjoincustompartitionindex();
}
inline const ::std::string& PrtoTabl::svjoincustompartitionindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.sVjoincustompartitionindex)
  return *svjoincustompartitionindex_;
}
inline void PrtoTabl::set_svjoincustompartitionindex(const ::std::string& value) {
  set_has_svjoincustompartitionindex();
  if (svjoincustompartitionindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartitionindex_ = new ::std::string;
  }
  svjoincustompartitionindex_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTabl.sVjoincustompartitionindex)
}
inline void PrtoTabl::set_svjoincustompartitionindex(const char* value) {
  set_has_svjoincustompartitionindex();
  if (svjoincustompartitionindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartitionindex_ = new ::std::string;
  }
  svjoincustompartitionindex_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTabl.sVjoincustompartitionindex)
}
inline void PrtoTabl::set_svjoincustompartitionindex(const void* value, size_t size) {
  set_has_svjoincustompartitionindex();
  if (svjoincustompartitionindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartitionindex_ = new ::std::string;
  }
  svjoincustompartitionindex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTabl.sVjoincustompartitionindex)
}
inline ::std::string* PrtoTabl::mutable_svjoincustompartitionindex() {
  set_has_svjoincustompartitionindex();
  if (svjoincustompartitionindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svjoincustompartitionindex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.sVjoincustompartitionindex)
  return svjoincustompartitionindex_;
}
inline ::std::string* PrtoTabl::release_svjoincustompartitionindex() {
  clear_has_svjoincustompartitionindex();
  if (svjoincustompartitionindex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svjoincustompartitionindex_;
    svjoincustompartitionindex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTabl::set_allocated_svjoincustompartitionindex(::std::string* svjoincustompartitionindex) {
  if (svjoincustompartitionindex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svjoincustompartitionindex_;
  }
  if (svjoincustompartitionindex) {
    set_has_svjoincustompartitionindex();
    svjoincustompartitionindex_ = svjoincustompartitionindex;
  } else {
    clear_has_svjoincustompartitionindex();
    svjoincustompartitionindex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTabl.sVjoincustompartitionindex)
}

// optional bytes sVpartitiontype = 8;
inline bool PrtoTabl::has_svpartitiontype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoTabl::set_has_svpartitiontype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoTabl::clear_has_svpartitiontype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoTabl::clear_svpartitiontype() {
  if (svpartitiontype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svpartitiontype_->clear();
  }
  clear_has_svpartitiontype();
}
inline const ::std::string& PrtoTabl::svpartitiontype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTabl.sVpartitiontype)
  return *svpartitiontype_;
}
inline void PrtoTabl::set_svpartitiontype(const ::std::string& value) {
  set_has_svpartitiontype();
  if (svpartitiontype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svpartitiontype_ = new ::std::string;
  }
  svpartitiontype_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTabl.sVpartitiontype)
}
inline void PrtoTabl::set_svpartitiontype(const char* value) {
  set_has_svpartitiontype();
  if (svpartitiontype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svpartitiontype_ = new ::std::string;
  }
  svpartitiontype_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTabl.sVpartitiontype)
}
inline void PrtoTabl::set_svpartitiontype(const void* value, size_t size) {
  set_has_svpartitiontype();
  if (svpartitiontype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svpartitiontype_ = new ::std::string;
  }
  svpartitiontype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTabl.sVpartitiontype)
}
inline ::std::string* PrtoTabl::mutable_svpartitiontype() {
  set_has_svpartitiontype();
  if (svpartitiontype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svpartitiontype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTabl.sVpartitiontype)
  return svpartitiontype_;
}
inline ::std::string* PrtoTabl::release_svpartitiontype() {
  clear_has_svpartitiontype();
  if (svpartitiontype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svpartitiontype_;
    svpartitiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTabl::set_allocated_svpartitiontype(::std::string* svpartitiontype) {
  if (svpartitiontype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svpartitiontype_;
  }
  if (svpartitiontype) {
    set_has_svpartitiontype();
    svpartitiontype_ = svpartitiontype;
  } else {
    clear_has_svpartitiontype();
    svpartitiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTabl.sVpartitiontype)
}

// -------------------------------------------------------------------

// PrtoAenp

// required bytes sVopaquedata = 1;
inline bool PrtoAenp::has_svopaquedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoAenp::set_has_svopaquedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoAenp::clear_has_svopaquedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoAenp::clear_svopaquedata() {
  if (svopaquedata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquedata_->clear();
  }
  clear_has_svopaquedata();
}
inline const ::std::string& PrtoAenp::svopaquedata() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoAenp.sVopaquedata)
  return *svopaquedata_;
}
inline void PrtoAenp::set_svopaquedata(const ::std::string& value) {
  set_has_svopaquedata();
  if (svopaquedata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquedata_ = new ::std::string;
  }
  svopaquedata_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoAenp.sVopaquedata)
}
inline void PrtoAenp::set_svopaquedata(const char* value) {
  set_has_svopaquedata();
  if (svopaquedata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquedata_ = new ::std::string;
  }
  svopaquedata_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoAenp.sVopaquedata)
}
inline void PrtoAenp::set_svopaquedata(const void* value, size_t size) {
  set_has_svopaquedata();
  if (svopaquedata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquedata_ = new ::std::string;
  }
  svopaquedata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoAenp.sVopaquedata)
}
inline ::std::string* PrtoAenp::mutable_svopaquedata() {
  set_has_svopaquedata();
  if (svopaquedata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svopaquedata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoAenp.sVopaquedata)
  return svopaquedata_;
}
inline ::std::string* PrtoAenp::release_svopaquedata() {
  clear_has_svopaquedata();
  if (svopaquedata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svopaquedata_;
    svopaquedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoAenp::set_allocated_svopaquedata(::std::string* svopaquedata) {
  if (svopaquedata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svopaquedata_;
  }
  if (svopaquedata) {
    set_has_svopaquedata();
    svopaquedata_ = svopaquedata;
  } else {
    clear_has_svopaquedata();
    svopaquedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoAenp.sVopaquedata)
}

// optional bytes sVnodeid = 2;
inline bool PrtoAenp::has_svnodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoAenp::set_has_svnodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoAenp::clear_has_svnodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoAenp::clear_svnodeid() {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_->clear();
  }
  clear_has_svnodeid();
}
inline const ::std::string& PrtoAenp::svnodeid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoAenp.sVnodeid)
  return *svnodeid_;
}
inline void PrtoAenp::set_svnodeid(const ::std::string& value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoAenp.sVnodeid)
}
inline void PrtoAenp::set_svnodeid(const char* value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoAenp.sVnodeid)
}
inline void PrtoAenp::set_svnodeid(const void* value, size_t size) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoAenp.sVnodeid)
}
inline ::std::string* PrtoAenp::mutable_svnodeid() {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoAenp.sVnodeid)
  return svnodeid_;
}
inline ::std::string* PrtoAenp::release_svnodeid() {
  clear_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnodeid_;
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoAenp::set_allocated_svnodeid(::std::string* svnodeid) {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnodeid_;
  }
  if (svnodeid) {
    set_has_svnodeid();
    svnodeid_ = svnodeid;
  } else {
    clear_has_svnodeid();
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoAenp.sVnodeid)
}

// optional .com.tomting.orion.PrtoLmtb cVmutable = 3;
inline bool PrtoAenp::has_cvmutable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoAenp::set_has_cvmutable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoAenp::clear_has_cvmutable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoAenp::clear_cvmutable() {
  if (cvmutable_ != NULL) cvmutable_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvmutable();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoAenp::cvmutable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoAenp.cVmutable)
  return cvmutable_ != NULL ? *cvmutable_ : *default_instance_->cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoAenp::mutable_cvmutable() {
  set_has_cvmutable();
  if (cvmutable_ == NULL) cvmutable_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoAenp.cVmutable)
  return cvmutable_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoAenp::release_cvmutable() {
  clear_has_cvmutable();
  ::com::tomting::orion::PrtoLmtb* temp = cvmutable_;
  cvmutable_ = NULL;
  return temp;
}
inline void PrtoAenp::set_allocated_cvmutable(::com::tomting::orion::PrtoLmtb* cvmutable) {
  delete cvmutable_;
  cvmutable_ = cvmutable;
  if (cvmutable) {
    set_has_cvmutable();
  } else {
    clear_has_cvmutable();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoAenp.cVmutable)
}

// optional bytes sVkeystart = 4;
inline bool PrtoAenp::has_svkeystart() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoAenp::set_has_svkeystart() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoAenp::clear_has_svkeystart() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoAenp::clear_svkeystart() {
  if (svkeystart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkeystart_->clear();
  }
  clear_has_svkeystart();
}
inline const ::std::string& PrtoAenp::svkeystart() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoAenp.sVkeystart)
  return *svkeystart_;
}
inline void PrtoAenp::set_svkeystart(const ::std::string& value) {
  set_has_svkeystart();
  if (svkeystart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkeystart_ = new ::std::string;
  }
  svkeystart_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoAenp.sVkeystart)
}
inline void PrtoAenp::set_svkeystart(const char* value) {
  set_has_svkeystart();
  if (svkeystart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkeystart_ = new ::std::string;
  }
  svkeystart_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoAenp.sVkeystart)
}
inline void PrtoAenp::set_svkeystart(const void* value, size_t size) {
  set_has_svkeystart();
  if (svkeystart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkeystart_ = new ::std::string;
  }
  svkeystart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoAenp.sVkeystart)
}
inline ::std::string* PrtoAenp::mutable_svkeystart() {
  set_has_svkeystart();
  if (svkeystart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svkeystart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoAenp.sVkeystart)
  return svkeystart_;
}
inline ::std::string* PrtoAenp::release_svkeystart() {
  clear_has_svkeystart();
  if (svkeystart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svkeystart_;
    svkeystart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoAenp::set_allocated_svkeystart(::std::string* svkeystart) {
  if (svkeystart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svkeystart_;
  }
  if (svkeystart) {
    set_has_svkeystart();
    svkeystart_ = svkeystart;
  } else {
    clear_has_svkeystart();
    svkeystart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoAenp.sVkeystart)
}

// optional int32 iVlimitsize = 5;
inline bool PrtoAenp::has_ivlimitsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoAenp::set_has_ivlimitsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoAenp::clear_has_ivlimitsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoAenp::clear_ivlimitsize() {
  ivlimitsize_ = 0;
  clear_has_ivlimitsize();
}
inline ::google::protobuf::int32 PrtoAenp::ivlimitsize() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoAenp.iVlimitsize)
  return ivlimitsize_;
}
inline void PrtoAenp::set_ivlimitsize(::google::protobuf::int32 value) {
  set_has_ivlimitsize();
  ivlimitsize_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoAenp.iVlimitsize)
}

// -------------------------------------------------------------------

// PrtoTope

// required bytes sVtablet = 1;
inline bool PrtoTope::has_svtablet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoTope::set_has_svtablet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoTope::clear_has_svtablet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoTope::clear_svtablet() {
  if (svtablet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtablet_->clear();
  }
  clear_has_svtablet();
}
inline const ::std::string& PrtoTope::svtablet() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.sVtablet)
  return *svtablet_;
}
inline void PrtoTope::set_svtablet(const ::std::string& value) {
  set_has_svtablet();
  if (svtablet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtablet_ = new ::std::string;
  }
  svtablet_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.sVtablet)
}
inline void PrtoTope::set_svtablet(const char* value) {
  set_has_svtablet();
  if (svtablet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtablet_ = new ::std::string;
  }
  svtablet_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoTope.sVtablet)
}
inline void PrtoTope::set_svtablet(const void* value, size_t size) {
  set_has_svtablet();
  if (svtablet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtablet_ = new ::std::string;
  }
  svtablet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoTope.sVtablet)
}
inline ::std::string* PrtoTope::mutable_svtablet() {
  set_has_svtablet();
  if (svtablet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtablet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTope.sVtablet)
  return svtablet_;
}
inline ::std::string* PrtoTope::release_svtablet() {
  clear_has_svtablet();
  if (svtablet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtablet_;
    svtablet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoTope::set_allocated_svtablet(::std::string* svtablet) {
  if (svtablet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtablet_;
  }
  if (svtablet) {
    set_has_svtablet();
    svtablet_ = svtablet;
  } else {
    clear_has_svtablet();
    svtablet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoTope.sVtablet)
}

// optional int64 iVreadtime = 2;
inline bool PrtoTope::has_ivreadtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoTope::set_has_ivreadtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoTope::clear_has_ivreadtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoTope::clear_ivreadtime() {
  ivreadtime_ = GOOGLE_LONGLONG(0);
  clear_has_ivreadtime();
}
inline ::google::protobuf::int64 PrtoTope::ivreadtime() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.iVreadtime)
  return ivreadtime_;
}
inline void PrtoTope::set_ivreadtime(::google::protobuf::int64 value) {
  set_has_ivreadtime();
  ivreadtime_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.iVreadtime)
}

// optional int64 iVwritetime = 3;
inline bool PrtoTope::has_ivwritetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoTope::set_has_ivwritetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoTope::clear_has_ivwritetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoTope::clear_ivwritetime() {
  ivwritetime_ = GOOGLE_LONGLONG(0);
  clear_has_ivwritetime();
}
inline ::google::protobuf::int64 PrtoTope::ivwritetime() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.iVwritetime)
  return ivwritetime_;
}
inline void PrtoTope::set_ivwritetime(::google::protobuf::int64 value) {
  set_has_ivwritetime();
  ivwritetime_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.iVwritetime)
}

// optional int64 iVreadcountl2 = 4;
inline bool PrtoTope::has_ivreadcountl2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoTope::set_has_ivreadcountl2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoTope::clear_has_ivreadcountl2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoTope::clear_ivreadcountl2() {
  ivreadcountl2_ = GOOGLE_LONGLONG(0);
  clear_has_ivreadcountl2();
}
inline ::google::protobuf::int64 PrtoTope::ivreadcountl2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.iVreadcountl2)
  return ivreadcountl2_;
}
inline void PrtoTope::set_ivreadcountl2(::google::protobuf::int64 value) {
  set_has_ivreadcountl2();
  ivreadcountl2_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.iVreadcountl2)
}

// optional int64 iVwritecountl2 = 5;
inline bool PrtoTope::has_ivwritecountl2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoTope::set_has_ivwritecountl2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoTope::clear_has_ivwritecountl2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoTope::clear_ivwritecountl2() {
  ivwritecountl2_ = GOOGLE_LONGLONG(0);
  clear_has_ivwritecountl2();
}
inline ::google::protobuf::int64 PrtoTope::ivwritecountl2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.iVwritecountl2)
  return ivwritecountl2_;
}
inline void PrtoTope::set_ivwritecountl2(::google::protobuf::int64 value) {
  set_has_ivwritecountl2();
  ivwritecountl2_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.iVwritecountl2)
}

// optional int64 iVreadcountl1 = 6;
inline bool PrtoTope::has_ivreadcountl1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoTope::set_has_ivreadcountl1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoTope::clear_has_ivreadcountl1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoTope::clear_ivreadcountl1() {
  ivreadcountl1_ = GOOGLE_LONGLONG(0);
  clear_has_ivreadcountl1();
}
inline ::google::protobuf::int64 PrtoTope::ivreadcountl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.iVreadcountl1)
  return ivreadcountl1_;
}
inline void PrtoTope::set_ivreadcountl1(::google::protobuf::int64 value) {
  set_has_ivreadcountl1();
  ivreadcountl1_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.iVreadcountl1)
}

// optional int64 iVwritecountl1 = 7;
inline bool PrtoTope::has_ivwritecountl1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoTope::set_has_ivwritecountl1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoTope::clear_has_ivwritecountl1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoTope::clear_ivwritecountl1() {
  ivwritecountl1_ = GOOGLE_LONGLONG(0);
  clear_has_ivwritecountl1();
}
inline ::google::protobuf::int64 PrtoTope::ivwritecountl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTope.iVwritecountl1)
  return ivwritecountl1_;
}
inline void PrtoTope::set_ivwritecountl1(::google::protobuf::int64 value) {
  set_has_ivwritecountl1();
  ivwritecountl1_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTope.iVwritecountl1)
}

// -------------------------------------------------------------------

// PrtoTop_

// optional int64 iVtimestamp = 1;
inline bool PrtoTop_::has_ivtimestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoTop_::set_has_ivtimestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoTop_::clear_has_ivtimestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoTop_::clear_ivtimestamp() {
  ivtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ivtimestamp();
}
inline ::google::protobuf::int64 PrtoTop_::ivtimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTop_.iVtimestamp)
  return ivtimestamp_;
}
inline void PrtoTop_::set_ivtimestamp(::google::protobuf::int64 value) {
  set_has_ivtimestamp();
  ivtimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoTop_.iVtimestamp)
}

// repeated .com.tomting.orion.PrtoTope cVtopelement = 2;
inline int PrtoTop_::cvtopelement_size() const {
  return cvtopelement_.size();
}
inline void PrtoTop_::clear_cvtopelement() {
  cvtopelement_.Clear();
}
inline const ::com::tomting::orion::PrtoTope& PrtoTop_::cvtopelement(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoTop_.cVtopelement)
  return cvtopelement_.Get(index);
}
inline ::com::tomting::orion::PrtoTope* PrtoTop_::mutable_cvtopelement(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoTop_.cVtopelement)
  return cvtopelement_.Mutable(index);
}
inline ::com::tomting::orion::PrtoTope* PrtoTop_::add_cvtopelement() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoTop_.cVtopelement)
  return cvtopelement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTope >&
PrtoTop_::cvtopelement() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoTop_.cVtopelement)
  return cvtopelement_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoTope >*
PrtoTop_::mutable_cvtopelement() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoTop_.cVtopelement)
  return &cvtopelement_;
}

// -------------------------------------------------------------------

// PrtoSrvc

// required .com.tomting.orion.iCservicetype iVservicetype = 1;
inline bool PrtoSrvc::has_ivservicetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoSrvc::set_has_ivservicetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoSrvc::clear_has_ivservicetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoSrvc::clear_ivservicetype() {
  ivservicetype_ = 0;
  clear_has_ivservicetype();
}
inline ::com::tomting::orion::iCservicetype PrtoSrvc::ivservicetype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.iVservicetype)
  return static_cast< ::com::tomting::orion::iCservicetype >(ivservicetype_);
}
inline void PrtoSrvc::set_ivservicetype(::com::tomting::orion::iCservicetype value) {
  assert(::com::tomting::orion::iCservicetype_IsValid(value));
  set_has_ivservicetype();
  ivservicetype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSrvc.iVservicetype)
}

// optional .com.tomting.orion.PrtoL2qr cVquery = 2;
inline bool PrtoSrvc::has_cvquery() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoSrvc::set_has_cvquery() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoSrvc::clear_has_cvquery() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoSrvc::clear_cvquery() {
  if (cvquery_ != NULL) cvquery_->::com::tomting::orion::PrtoL2qr::Clear();
  clear_has_cvquery();
}
inline const ::com::tomting::orion::PrtoL2qr& PrtoSrvc::cvquery() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVquery)
  return cvquery_ != NULL ? *cvquery_ : *default_instance_->cvquery_;
}
inline ::com::tomting::orion::PrtoL2qr* PrtoSrvc::mutable_cvquery() {
  set_has_cvquery();
  if (cvquery_ == NULL) cvquery_ = new ::com::tomting::orion::PrtoL2qr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVquery)
  return cvquery_;
}
inline ::com::tomting::orion::PrtoL2qr* PrtoSrvc::release_cvquery() {
  clear_has_cvquery();
  ::com::tomting::orion::PrtoL2qr* temp = cvquery_;
  cvquery_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvquery(::com::tomting::orion::PrtoL2qr* cvquery) {
  delete cvquery_;
  cvquery_ = cvquery;
  if (cvquery) {
    set_has_cvquery();
  } else {
    clear_has_cvquery();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVquery)
}

// optional .com.tomting.orion.PrtoL2st cVstatement = 3;
inline bool PrtoSrvc::has_cvstatement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoSrvc::set_has_cvstatement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoSrvc::clear_has_cvstatement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoSrvc::clear_cvstatement() {
  if (cvstatement_ != NULL) cvstatement_->::com::tomting::orion::PrtoL2st::Clear();
  clear_has_cvstatement();
}
inline const ::com::tomting::orion::PrtoL2st& PrtoSrvc::cvstatement() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVstatement)
  return cvstatement_ != NULL ? *cvstatement_ : *default_instance_->cvstatement_;
}
inline ::com::tomting::orion::PrtoL2st* PrtoSrvc::mutable_cvstatement() {
  set_has_cvstatement();
  if (cvstatement_ == NULL) cvstatement_ = new ::com::tomting::orion::PrtoL2st;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVstatement)
  return cvstatement_;
}
inline ::com::tomting::orion::PrtoL2st* PrtoSrvc::release_cvstatement() {
  clear_has_cvstatement();
  ::com::tomting::orion::PrtoL2st* temp = cvstatement_;
  cvstatement_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvstatement(::com::tomting::orion::PrtoL2st* cvstatement) {
  delete cvstatement_;
  cvstatement_ = cvstatement;
  if (cvstatement) {
    set_has_cvstatement();
  } else {
    clear_has_cvstatement();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVstatement)
}

// optional .com.tomting.orion.PrtoL2os cVosql = 4;
inline bool PrtoSrvc::has_cvosql() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoSrvc::set_has_cvosql() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoSrvc::clear_has_cvosql() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoSrvc::clear_cvosql() {
  if (cvosql_ != NULL) cvosql_->::com::tomting::orion::PrtoL2os::Clear();
  clear_has_cvosql();
}
inline const ::com::tomting::orion::PrtoL2os& PrtoSrvc::cvosql() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVosql)
  return cvosql_ != NULL ? *cvosql_ : *default_instance_->cvosql_;
}
inline ::com::tomting::orion::PrtoL2os* PrtoSrvc::mutable_cvosql() {
  set_has_cvosql();
  if (cvosql_ == NULL) cvosql_ = new ::com::tomting::orion::PrtoL2os;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVosql)
  return cvosql_;
}
inline ::com::tomting::orion::PrtoL2os* PrtoSrvc::release_cvosql() {
  clear_has_cvosql();
  ::com::tomting::orion::PrtoL2os* temp = cvosql_;
  cvosql_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvosql(::com::tomting::orion::PrtoL2os* cvosql) {
  delete cvosql_;
  cvosql_ = cvosql;
  if (cvosql) {
    set_has_cvosql();
  } else {
    clear_has_cvosql();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVosql)
}

// optional .com.tomting.orion.PrtoLstm cVstatementL1 = 5;
inline bool PrtoSrvc::has_cvstatementl1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoSrvc::set_has_cvstatementl1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoSrvc::clear_has_cvstatementl1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoSrvc::clear_cvstatementl1() {
  if (cvstatementl1_ != NULL) cvstatementl1_->::com::tomting::orion::PrtoLstm::Clear();
  clear_has_cvstatementl1();
}
inline const ::com::tomting::orion::PrtoLstm& PrtoSrvc::cvstatementl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVstatementL1)
  return cvstatementl1_ != NULL ? *cvstatementl1_ : *default_instance_->cvstatementl1_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoSrvc::mutable_cvstatementl1() {
  set_has_cvstatementl1();
  if (cvstatementl1_ == NULL) cvstatementl1_ = new ::com::tomting::orion::PrtoLstm;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVstatementL1)
  return cvstatementl1_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoSrvc::release_cvstatementl1() {
  clear_has_cvstatementl1();
  ::com::tomting::orion::PrtoLstm* temp = cvstatementl1_;
  cvstatementl1_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvstatementl1(::com::tomting::orion::PrtoLstm* cvstatementl1) {
  delete cvstatementl1_;
  cvstatementl1_ = cvstatementl1;
  if (cvstatementl1) {
    set_has_cvstatementl1();
  } else {
    clear_has_cvstatementl1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVstatementL1)
}

// optional .com.tomting.orion.PrtoLqry cVqueryL1 = 6;
inline bool PrtoSrvc::has_cvqueryl1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoSrvc::set_has_cvqueryl1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoSrvc::clear_has_cvqueryl1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoSrvc::clear_cvqueryl1() {
  if (cvqueryl1_ != NULL) cvqueryl1_->::com::tomting::orion::PrtoLqry::Clear();
  clear_has_cvqueryl1();
}
inline const ::com::tomting::orion::PrtoLqry& PrtoSrvc::cvqueryl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVqueryL1)
  return cvqueryl1_ != NULL ? *cvqueryl1_ : *default_instance_->cvqueryl1_;
}
inline ::com::tomting::orion::PrtoLqry* PrtoSrvc::mutable_cvqueryl1() {
  set_has_cvqueryl1();
  if (cvqueryl1_ == NULL) cvqueryl1_ = new ::com::tomting::orion::PrtoLqry;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVqueryL1)
  return cvqueryl1_;
}
inline ::com::tomting::orion::PrtoLqry* PrtoSrvc::release_cvqueryl1() {
  clear_has_cvqueryl1();
  ::com::tomting::orion::PrtoLqry* temp = cvqueryl1_;
  cvqueryl1_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvqueryl1(::com::tomting::orion::PrtoLqry* cvqueryl1) {
  delete cvqueryl1_;
  cvqueryl1_ = cvqueryl1;
  if (cvqueryl1) {
    set_has_cvqueryl1();
  } else {
    clear_has_cvqueryl1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVqueryL1)
}

// optional .com.tomting.orion.PrtoLmtb cVdmlL1 = 7;
inline bool PrtoSrvc::has_cvdmll1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoSrvc::set_has_cvdmll1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoSrvc::clear_has_cvdmll1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoSrvc::clear_cvdmll1() {
  if (cvdmll1_ != NULL) cvdmll1_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvdmll1();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoSrvc::cvdmll1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVdmlL1)
  return cvdmll1_ != NULL ? *cvdmll1_ : *default_instance_->cvdmll1_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoSrvc::mutable_cvdmll1() {
  set_has_cvdmll1();
  if (cvdmll1_ == NULL) cvdmll1_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVdmlL1)
  return cvdmll1_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoSrvc::release_cvdmll1() {
  clear_has_cvdmll1();
  ::com::tomting::orion::PrtoLmtb* temp = cvdmll1_;
  cvdmll1_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvdmll1(::com::tomting::orion::PrtoLmtb* cvdmll1) {
  delete cvdmll1_;
  cvdmll1_ = cvdmll1;
  if (cvdmll1) {
    set_has_cvdmll1();
  } else {
    clear_has_cvdmll1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVdmlL1)
}

// optional .com.tomting.orion.PrtoL2ct cVdmlL2 = 8;
inline bool PrtoSrvc::has_cvdmll2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoSrvc::set_has_cvdmll2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoSrvc::clear_has_cvdmll2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoSrvc::clear_cvdmll2() {
  if (cvdmll2_ != NULL) cvdmll2_->::com::tomting::orion::PrtoL2ct::Clear();
  clear_has_cvdmll2();
}
inline const ::com::tomting::orion::PrtoL2ct& PrtoSrvc::cvdmll2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.cVdmlL2)
  return cvdmll2_ != NULL ? *cvdmll2_ : *default_instance_->cvdmll2_;
}
inline ::com::tomting::orion::PrtoL2ct* PrtoSrvc::mutable_cvdmll2() {
  set_has_cvdmll2();
  if (cvdmll2_ == NULL) cvdmll2_ = new ::com::tomting::orion::PrtoL2ct;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvc.cVdmlL2)
  return cvdmll2_;
}
inline ::com::tomting::orion::PrtoL2ct* PrtoSrvc::release_cvdmll2() {
  clear_has_cvdmll2();
  ::com::tomting::orion::PrtoL2ct* temp = cvdmll2_;
  cvdmll2_ = NULL;
  return temp;
}
inline void PrtoSrvc::set_allocated_cvdmll2(::com::tomting::orion::PrtoL2ct* cvdmll2) {
  delete cvdmll2_;
  cvdmll2_ = cvdmll2;
  if (cvdmll2) {
    set_has_cvdmll2();
  } else {
    clear_has_cvdmll2();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvc.cVdmlL2)
}

// optional bool bVoptimizewriteindex = 9;
inline bool PrtoSrvc::has_bvoptimizewriteindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PrtoSrvc::set_has_bvoptimizewriteindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PrtoSrvc::clear_has_bvoptimizewriteindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PrtoSrvc::clear_bvoptimizewriteindex() {
  bvoptimizewriteindex_ = false;
  clear_has_bvoptimizewriteindex();
}
inline bool PrtoSrvc::bvoptimizewriteindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.bVoptimizewriteindex)
  return bvoptimizewriteindex_;
}
inline void PrtoSrvc::set_bvoptimizewriteindex(bool value) {
  set_has_bvoptimizewriteindex();
  bvoptimizewriteindex_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSrvc.bVoptimizewriteindex)
}

// optional bool bVupdateonlyindex = 10;
inline bool PrtoSrvc::has_bvupdateonlyindex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PrtoSrvc::set_has_bvupdateonlyindex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PrtoSrvc::clear_has_bvupdateonlyindex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PrtoSrvc::clear_bvupdateonlyindex() {
  bvupdateonlyindex_ = false;
  clear_has_bvupdateonlyindex();
}
inline bool PrtoSrvc::bvupdateonlyindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.bVupdateonlyindex)
  return bvupdateonlyindex_;
}
inline void PrtoSrvc::set_bvupdateonlyindex(bool value) {
  set_has_bvupdateonlyindex();
  bvupdateonlyindex_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSrvc.bVupdateonlyindex)
}

// optional bool bVlocalfilter = 11;
inline bool PrtoSrvc::has_bvlocalfilter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PrtoSrvc::set_has_bvlocalfilter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PrtoSrvc::clear_has_bvlocalfilter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PrtoSrvc::clear_bvlocalfilter() {
  bvlocalfilter_ = false;
  clear_has_bvlocalfilter();
}
inline bool PrtoSrvc::bvlocalfilter() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.bVlocalfilter)
  return bvlocalfilter_;
}
inline void PrtoSrvc::set_bvlocalfilter(bool value) {
  set_has_bvlocalfilter();
  bvlocalfilter_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSrvc.bVlocalfilter)
}

// optional bool bVenabletimestamp = 12;
inline bool PrtoSrvc::has_bvenabletimestamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PrtoSrvc::set_has_bvenabletimestamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PrtoSrvc::clear_has_bvenabletimestamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PrtoSrvc::clear_bvenabletimestamp() {
  bvenabletimestamp_ = false;
  clear_has_bvenabletimestamp();
}
inline bool PrtoSrvc::bvenabletimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvc.bVenabletimestamp)
  return bvenabletimestamp_;
}
inline void PrtoSrvc::set_bvenabletimestamp(bool value) {
  set_has_bvenabletimestamp();
  bvenabletimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSrvc.bVenabletimestamp)
}

// -------------------------------------------------------------------

// PrtoSrvr

// optional bool bVreturn = 1;
inline bool PrtoSrvr::has_bvreturn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoSrvr::set_has_bvreturn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoSrvr::clear_has_bvreturn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoSrvr::clear_bvreturn() {
  bvreturn_ = false;
  clear_has_bvreturn();
}
inline bool PrtoSrvr::bvreturn() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvr.bVreturn)
  return bvreturn_;
}
inline void PrtoSrvr::set_bvreturn(bool value) {
  set_has_bvreturn();
  bvreturn_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSrvr.bVreturn)
}

// optional .com.tomting.orion.PrtoL2mr cVdmlresult = 2;
inline bool PrtoSrvr::has_cvdmlresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoSrvr::set_has_cvdmlresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoSrvr::clear_has_cvdmlresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoSrvr::clear_cvdmlresult() {
  if (cvdmlresult_ != NULL) cvdmlresult_->::com::tomting::orion::PrtoL2mr::Clear();
  clear_has_cvdmlresult();
}
inline const ::com::tomting::orion::PrtoL2mr& PrtoSrvr::cvdmlresult() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvr.cVdmlresult)
  return cvdmlresult_ != NULL ? *cvdmlresult_ : *default_instance_->cvdmlresult_;
}
inline ::com::tomting::orion::PrtoL2mr* PrtoSrvr::mutable_cvdmlresult() {
  set_has_cvdmlresult();
  if (cvdmlresult_ == NULL) cvdmlresult_ = new ::com::tomting::orion::PrtoL2mr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvr.cVdmlresult)
  return cvdmlresult_;
}
inline ::com::tomting::orion::PrtoL2mr* PrtoSrvr::release_cvdmlresult() {
  clear_has_cvdmlresult();
  ::com::tomting::orion::PrtoL2mr* temp = cvdmlresult_;
  cvdmlresult_ = NULL;
  return temp;
}
inline void PrtoSrvr::set_allocated_cvdmlresult(::com::tomting::orion::PrtoL2mr* cvdmlresult) {
  delete cvdmlresult_;
  cvdmlresult_ = cvdmlresult;
  if (cvdmlresult) {
    set_has_cvdmlresult();
  } else {
    clear_has_cvdmlresult();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvr.cVdmlresult)
}

// optional .com.tomting.orion.PrtoL1mr cVsnapshotL1 = 3;
inline bool PrtoSrvr::has_cvsnapshotl1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoSrvr::set_has_cvsnapshotl1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoSrvr::clear_has_cvsnapshotl1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoSrvr::clear_cvsnapshotl1() {
  if (cvsnapshotl1_ != NULL) cvsnapshotl1_->::com::tomting::orion::PrtoL1mr::Clear();
  clear_has_cvsnapshotl1();
}
inline const ::com::tomting::orion::PrtoL1mr& PrtoSrvr::cvsnapshotl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSrvr.cVsnapshotL1)
  return cvsnapshotl1_ != NULL ? *cvsnapshotl1_ : *default_instance_->cvsnapshotl1_;
}
inline ::com::tomting::orion::PrtoL1mr* PrtoSrvr::mutable_cvsnapshotl1() {
  set_has_cvsnapshotl1();
  if (cvsnapshotl1_ == NULL) cvsnapshotl1_ = new ::com::tomting::orion::PrtoL1mr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSrvr.cVsnapshotL1)
  return cvsnapshotl1_;
}
inline ::com::tomting::orion::PrtoL1mr* PrtoSrvr::release_cvsnapshotl1() {
  clear_has_cvsnapshotl1();
  ::com::tomting::orion::PrtoL1mr* temp = cvsnapshotl1_;
  cvsnapshotl1_ = NULL;
  return temp;
}
inline void PrtoSrvr::set_allocated_cvsnapshotl1(::com::tomting::orion::PrtoL1mr* cvsnapshotl1) {
  delete cvsnapshotl1_;
  cvsnapshotl1_ = cvsnapshotl1;
  if (cvsnapshotl1) {
    set_has_cvsnapshotl1();
  } else {
    clear_has_cvsnapshotl1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSrvr.cVsnapshotL1)
}

// -------------------------------------------------------------------

// PrtoBsrc

// required .com.tomting.orion.iCbulkservicetype iVbulkservicetype = 1;
inline bool PrtoBsrc::has_ivbulkservicetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoBsrc::set_has_ivbulkservicetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoBsrc::clear_has_ivbulkservicetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoBsrc::clear_ivbulkservicetype() {
  ivbulkservicetype_ = 0;
  clear_has_ivbulkservicetype();
}
inline ::com::tomting::orion::iCbulkservicetype PrtoBsrc::ivbulkservicetype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrc.iVbulkservicetype)
  return static_cast< ::com::tomting::orion::iCbulkservicetype >(ivbulkservicetype_);
}
inline void PrtoBsrc::set_ivbulkservicetype(::com::tomting::orion::iCbulkservicetype value) {
  assert(::com::tomting::orion::iCbulkservicetype_IsValid(value));
  set_has_ivbulkservicetype();
  ivbulkservicetype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoBsrc.iVbulkservicetype)
}

// repeated .com.tomting.orion.PrtoSrvc cVbulkproto = 2;
inline int PrtoBsrc::cvbulkproto_size() const {
  return cvbulkproto_.size();
}
inline void PrtoBsrc::clear_cvbulkproto() {
  cvbulkproto_.Clear();
}
inline const ::com::tomting::orion::PrtoSrvc& PrtoBsrc::cvbulkproto(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrc.cVbulkproto)
  return cvbulkproto_.Get(index);
}
inline ::com::tomting::orion::PrtoSrvc* PrtoBsrc::mutable_cvbulkproto(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoBsrc.cVbulkproto)
  return cvbulkproto_.Mutable(index);
}
inline ::com::tomting::orion::PrtoSrvc* PrtoBsrc::add_cvbulkproto() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoBsrc.cVbulkproto)
  return cvbulkproto_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvc >&
PrtoBsrc::cvbulkproto() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoBsrc.cVbulkproto)
  return cvbulkproto_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvc >*
PrtoBsrc::mutable_cvbulkproto() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoBsrc.cVbulkproto)
  return &cvbulkproto_;
}

// repeated bytes cVbulkstring = 3;
inline int PrtoBsrc::cvbulkstring_size() const {
  return cvbulkstring_.size();
}
inline void PrtoBsrc::clear_cvbulkstring() {
  cvbulkstring_.Clear();
}
inline const ::std::string& PrtoBsrc::cvbulkstring(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrc.cVbulkstring)
  return cvbulkstring_.Get(index);
}
inline ::std::string* PrtoBsrc::mutable_cvbulkstring(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoBsrc.cVbulkstring)
  return cvbulkstring_.Mutable(index);
}
inline void PrtoBsrc::set_cvbulkstring(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoBsrc.cVbulkstring)
  cvbulkstring_.Mutable(index)->assign(value);
}
inline void PrtoBsrc::set_cvbulkstring(int index, const char* value) {
  cvbulkstring_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoBsrc.cVbulkstring)
}
inline void PrtoBsrc::set_cvbulkstring(int index, const void* value, size_t size) {
  cvbulkstring_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoBsrc.cVbulkstring)
}
inline ::std::string* PrtoBsrc::add_cvbulkstring() {
  return cvbulkstring_.Add();
}
inline void PrtoBsrc::add_cvbulkstring(const ::std::string& value) {
  cvbulkstring_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoBsrc.cVbulkstring)
}
inline void PrtoBsrc::add_cvbulkstring(const char* value) {
  cvbulkstring_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.tomting.orion.PrtoBsrc.cVbulkstring)
}
inline void PrtoBsrc::add_cvbulkstring(const void* value, size_t size) {
  cvbulkstring_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.tomting.orion.PrtoBsrc.cVbulkstring)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrtoBsrc::cvbulkstring() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoBsrc.cVbulkstring)
  return cvbulkstring_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrtoBsrc::mutable_cvbulkstring() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoBsrc.cVbulkstring)
  return &cvbulkstring_;
}

// optional .com.tomting.orion.PrtoSrvc cVsingleproto = 4;
inline bool PrtoBsrc::has_cvsingleproto() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoBsrc::set_has_cvsingleproto() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoBsrc::clear_has_cvsingleproto() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoBsrc::clear_cvsingleproto() {
  if (cvsingleproto_ != NULL) cvsingleproto_->::com::tomting::orion::PrtoSrvc::Clear();
  clear_has_cvsingleproto();
}
inline const ::com::tomting::orion::PrtoSrvc& PrtoBsrc::cvsingleproto() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrc.cVsingleproto)
  return cvsingleproto_ != NULL ? *cvsingleproto_ : *default_instance_->cvsingleproto_;
}
inline ::com::tomting::orion::PrtoSrvc* PrtoBsrc::mutable_cvsingleproto() {
  set_has_cvsingleproto();
  if (cvsingleproto_ == NULL) cvsingleproto_ = new ::com::tomting::orion::PrtoSrvc;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoBsrc.cVsingleproto)
  return cvsingleproto_;
}
inline ::com::tomting::orion::PrtoSrvc* PrtoBsrc::release_cvsingleproto() {
  clear_has_cvsingleproto();
  ::com::tomting::orion::PrtoSrvc* temp = cvsingleproto_;
  cvsingleproto_ = NULL;
  return temp;
}
inline void PrtoBsrc::set_allocated_cvsingleproto(::com::tomting::orion::PrtoSrvc* cvsingleproto) {
  delete cvsingleproto_;
  cvsingleproto_ = cvsingleproto;
  if (cvsingleproto) {
    set_has_cvsingleproto();
  } else {
    clear_has_cvsingleproto();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoBsrc.cVsingleproto)
}

// -------------------------------------------------------------------

// PrtoBsrr

// repeated .com.tomting.orion.PrtoSrvr cVbulkproto = 1;
inline int PrtoBsrr::cvbulkproto_size() const {
  return cvbulkproto_.size();
}
inline void PrtoBsrr::clear_cvbulkproto() {
  cvbulkproto_.Clear();
}
inline const ::com::tomting::orion::PrtoSrvr& PrtoBsrr::cvbulkproto(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrr.cVbulkproto)
  return cvbulkproto_.Get(index);
}
inline ::com::tomting::orion::PrtoSrvr* PrtoBsrr::mutable_cvbulkproto(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoBsrr.cVbulkproto)
  return cvbulkproto_.Mutable(index);
}
inline ::com::tomting::orion::PrtoSrvr* PrtoBsrr::add_cvbulkproto() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoBsrr.cVbulkproto)
  return cvbulkproto_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvr >&
PrtoBsrr::cvbulkproto() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoBsrr.cVbulkproto)
  return cvbulkproto_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoSrvr >*
PrtoBsrr::mutable_cvbulkproto() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoBsrr.cVbulkproto)
  return &cvbulkproto_;
}

// repeated bytes cVbulkstring = 2;
inline int PrtoBsrr::cvbulkstring_size() const {
  return cvbulkstring_.size();
}
inline void PrtoBsrr::clear_cvbulkstring() {
  cvbulkstring_.Clear();
}
inline const ::std::string& PrtoBsrr::cvbulkstring(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrr.cVbulkstring)
  return cvbulkstring_.Get(index);
}
inline ::std::string* PrtoBsrr::mutable_cvbulkstring(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoBsrr.cVbulkstring)
  return cvbulkstring_.Mutable(index);
}
inline void PrtoBsrr::set_cvbulkstring(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoBsrr.cVbulkstring)
  cvbulkstring_.Mutable(index)->assign(value);
}
inline void PrtoBsrr::set_cvbulkstring(int index, const char* value) {
  cvbulkstring_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoBsrr.cVbulkstring)
}
inline void PrtoBsrr::set_cvbulkstring(int index, const void* value, size_t size) {
  cvbulkstring_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoBsrr.cVbulkstring)
}
inline ::std::string* PrtoBsrr::add_cvbulkstring() {
  return cvbulkstring_.Add();
}
inline void PrtoBsrr::add_cvbulkstring(const ::std::string& value) {
  cvbulkstring_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoBsrr.cVbulkstring)
}
inline void PrtoBsrr::add_cvbulkstring(const char* value) {
  cvbulkstring_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.tomting.orion.PrtoBsrr.cVbulkstring)
}
inline void PrtoBsrr::add_cvbulkstring(const void* value, size_t size) {
  cvbulkstring_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.tomting.orion.PrtoBsrr.cVbulkstring)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrtoBsrr::cvbulkstring() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoBsrr.cVbulkstring)
  return cvbulkstring_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrtoBsrr::mutable_cvbulkstring() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoBsrr.cVbulkstring)
  return &cvbulkstring_;
}

// optional .com.tomting.orion.PrtoSrvr cVsingleproto = 3;
inline bool PrtoBsrr::has_cvsingleproto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoBsrr::set_has_cvsingleproto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoBsrr::clear_has_cvsingleproto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoBsrr::clear_cvsingleproto() {
  if (cvsingleproto_ != NULL) cvsingleproto_->::com::tomting::orion::PrtoSrvr::Clear();
  clear_has_cvsingleproto();
}
inline const ::com::tomting::orion::PrtoSrvr& PrtoBsrr::cvsingleproto() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoBsrr.cVsingleproto)
  return cvsingleproto_ != NULL ? *cvsingleproto_ : *default_instance_->cvsingleproto_;
}
inline ::com::tomting::orion::PrtoSrvr* PrtoBsrr::mutable_cvsingleproto() {
  set_has_cvsingleproto();
  if (cvsingleproto_ == NULL) cvsingleproto_ = new ::com::tomting::orion::PrtoSrvr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoBsrr.cVsingleproto)
  return cvsingleproto_;
}
inline ::com::tomting::orion::PrtoSrvr* PrtoBsrr::release_cvsingleproto() {
  clear_has_cvsingleproto();
  ::com::tomting::orion::PrtoSrvr* temp = cvsingleproto_;
  cvsingleproto_ = NULL;
  return temp;
}
inline void PrtoBsrr::set_allocated_cvsingleproto(::com::tomting::orion::PrtoSrvr* cvsingleproto) {
  delete cvsingleproto_;
  cvsingleproto_ = cvsingleproto;
  if (cvsingleproto) {
    set_has_cvsingleproto();
  } else {
    clear_has_cvsingleproto();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoBsrr.cVsingleproto)
}

// -------------------------------------------------------------------

// PrtoIoop

// optional bytes sVlogpath = 1;
inline bool PrtoIoop::has_svlogpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoIoop::set_has_svlogpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoIoop::clear_has_svlogpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoIoop::clear_svlogpath() {
  if (svlogpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svlogpath_->clear();
  }
  clear_has_svlogpath();
}
inline const ::std::string& PrtoIoop::svlogpath() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVlogpath)
  return *svlogpath_;
}
inline void PrtoIoop::set_svlogpath(const ::std::string& value) {
  set_has_svlogpath();
  if (svlogpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svlogpath_ = new ::std::string;
  }
  svlogpath_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVlogpath)
}
inline void PrtoIoop::set_svlogpath(const char* value) {
  set_has_svlogpath();
  if (svlogpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svlogpath_ = new ::std::string;
  }
  svlogpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVlogpath)
}
inline void PrtoIoop::set_svlogpath(const void* value, size_t size) {
  set_has_svlogpath();
  if (svlogpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svlogpath_ = new ::std::string;
  }
  svlogpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVlogpath)
}
inline ::std::string* PrtoIoop::mutable_svlogpath() {
  set_has_svlogpath();
  if (svlogpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svlogpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVlogpath)
  return svlogpath_;
}
inline ::std::string* PrtoIoop::release_svlogpath() {
  clear_has_svlogpath();
  if (svlogpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svlogpath_;
    svlogpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svlogpath(::std::string* svlogpath) {
  if (svlogpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svlogpath_;
  }
  if (svlogpath) {
    set_has_svlogpath();
    svlogpath_ = svlogpath;
  } else {
    clear_has_svlogpath();
    svlogpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVlogpath)
}

// optional bytes sVmasterxml = 2;
inline bool PrtoIoop::has_svmasterxml() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoIoop::set_has_svmasterxml() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoIoop::clear_has_svmasterxml() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoIoop::clear_svmasterxml() {
  if (svmasterxml_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmasterxml_->clear();
  }
  clear_has_svmasterxml();
}
inline const ::std::string& PrtoIoop::svmasterxml() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVmasterxml)
  return *svmasterxml_;
}
inline void PrtoIoop::set_svmasterxml(const ::std::string& value) {
  set_has_svmasterxml();
  if (svmasterxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmasterxml_ = new ::std::string;
  }
  svmasterxml_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVmasterxml)
}
inline void PrtoIoop::set_svmasterxml(const char* value) {
  set_has_svmasterxml();
  if (svmasterxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmasterxml_ = new ::std::string;
  }
  svmasterxml_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVmasterxml)
}
inline void PrtoIoop::set_svmasterxml(const void* value, size_t size) {
  set_has_svmasterxml();
  if (svmasterxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmasterxml_ = new ::std::string;
  }
  svmasterxml_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVmasterxml)
}
inline ::std::string* PrtoIoop::mutable_svmasterxml() {
  set_has_svmasterxml();
  if (svmasterxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmasterxml_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVmasterxml)
  return svmasterxml_;
}
inline ::std::string* PrtoIoop::release_svmasterxml() {
  clear_has_svmasterxml();
  if (svmasterxml_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svmasterxml_;
    svmasterxml_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svmasterxml(::std::string* svmasterxml) {
  if (svmasterxml_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svmasterxml_;
  }
  if (svmasterxml) {
    set_has_svmasterxml();
    svmasterxml_ = svmasterxml;
  } else {
    clear_has_svmasterxml();
    svmasterxml_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVmasterxml)
}

// optional bytes sVnodeid = 3;
inline bool PrtoIoop::has_svnodeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoIoop::set_has_svnodeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoIoop::clear_has_svnodeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoIoop::clear_svnodeid() {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_->clear();
  }
  clear_has_svnodeid();
}
inline const ::std::string& PrtoIoop::svnodeid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVnodeid)
  return *svnodeid_;
}
inline void PrtoIoop::set_svnodeid(const ::std::string& value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVnodeid)
}
inline void PrtoIoop::set_svnodeid(const char* value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVnodeid)
}
inline void PrtoIoop::set_svnodeid(const void* value, size_t size) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVnodeid)
}
inline ::std::string* PrtoIoop::mutable_svnodeid() {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVnodeid)
  return svnodeid_;
}
inline ::std::string* PrtoIoop::release_svnodeid() {
  clear_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnodeid_;
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svnodeid(::std::string* svnodeid) {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnodeid_;
  }
  if (svnodeid) {
    set_has_svnodeid();
    svnodeid_ = svnodeid;
  } else {
    clear_has_svnodeid();
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVnodeid)
}

// optional bytes sVtabletsubpath = 4;
inline bool PrtoIoop::has_svtabletsubpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoIoop::set_has_svtabletsubpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoIoop::clear_has_svtabletsubpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoIoop::clear_svtabletsubpath() {
  if (svtabletsubpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtabletsubpath_->clear();
  }
  clear_has_svtabletsubpath();
}
inline const ::std::string& PrtoIoop::svtabletsubpath() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVtabletsubpath)
  return *svtabletsubpath_;
}
inline void PrtoIoop::set_svtabletsubpath(const ::std::string& value) {
  set_has_svtabletsubpath();
  if (svtabletsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtabletsubpath_ = new ::std::string;
  }
  svtabletsubpath_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVtabletsubpath)
}
inline void PrtoIoop::set_svtabletsubpath(const char* value) {
  set_has_svtabletsubpath();
  if (svtabletsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtabletsubpath_ = new ::std::string;
  }
  svtabletsubpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVtabletsubpath)
}
inline void PrtoIoop::set_svtabletsubpath(const void* value, size_t size) {
  set_has_svtabletsubpath();
  if (svtabletsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtabletsubpath_ = new ::std::string;
  }
  svtabletsubpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVtabletsubpath)
}
inline ::std::string* PrtoIoop::mutable_svtabletsubpath() {
  set_has_svtabletsubpath();
  if (svtabletsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtabletsubpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVtabletsubpath)
  return svtabletsubpath_;
}
inline ::std::string* PrtoIoop::release_svtabletsubpath() {
  clear_has_svtabletsubpath();
  if (svtabletsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtabletsubpath_;
    svtabletsubpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svtabletsubpath(::std::string* svtabletsubpath) {
  if (svtabletsubpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtabletsubpath_;
  }
  if (svtabletsubpath) {
    set_has_svtabletsubpath();
    svtabletsubpath_ = svtabletsubpath;
  } else {
    clear_has_svtabletsubpath();
    svtabletsubpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVtabletsubpath)
}

// optional bytes sVredologsubpath = 5;
inline bool PrtoIoop::has_svredologsubpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoIoop::set_has_svredologsubpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoIoop::clear_has_svredologsubpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoIoop::clear_svredologsubpath() {
  if (svredologsubpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredologsubpath_->clear();
  }
  clear_has_svredologsubpath();
}
inline const ::std::string& PrtoIoop::svredologsubpath() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVredologsubpath)
  return *svredologsubpath_;
}
inline void PrtoIoop::set_svredologsubpath(const ::std::string& value) {
  set_has_svredologsubpath();
  if (svredologsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredologsubpath_ = new ::std::string;
  }
  svredologsubpath_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVredologsubpath)
}
inline void PrtoIoop::set_svredologsubpath(const char* value) {
  set_has_svredologsubpath();
  if (svredologsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredologsubpath_ = new ::std::string;
  }
  svredologsubpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVredologsubpath)
}
inline void PrtoIoop::set_svredologsubpath(const void* value, size_t size) {
  set_has_svredologsubpath();
  if (svredologsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredologsubpath_ = new ::std::string;
  }
  svredologsubpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVredologsubpath)
}
inline ::std::string* PrtoIoop::mutable_svredologsubpath() {
  set_has_svredologsubpath();
  if (svredologsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svredologsubpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVredologsubpath)
  return svredologsubpath_;
}
inline ::std::string* PrtoIoop::release_svredologsubpath() {
  clear_has_svredologsubpath();
  if (svredologsubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svredologsubpath_;
    svredologsubpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svredologsubpath(::std::string* svredologsubpath) {
  if (svredologsubpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svredologsubpath_;
  }
  if (svredologsubpath) {
    set_has_svredologsubpath();
    svredologsubpath_ = svredologsubpath;
  } else {
    clear_has_svredologsubpath();
    svredologsubpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVredologsubpath)
}

// optional bytes sVdatasubpath = 6;
inline bool PrtoIoop::has_svdatasubpath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoIoop::set_has_svdatasubpath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoIoop::clear_has_svdatasubpath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoIoop::clear_svdatasubpath() {
  if (svdatasubpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatasubpath_->clear();
  }
  clear_has_svdatasubpath();
}
inline const ::std::string& PrtoIoop::svdatasubpath() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVdatasubpath)
  return *svdatasubpath_;
}
inline void PrtoIoop::set_svdatasubpath(const ::std::string& value) {
  set_has_svdatasubpath();
  if (svdatasubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatasubpath_ = new ::std::string;
  }
  svdatasubpath_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVdatasubpath)
}
inline void PrtoIoop::set_svdatasubpath(const char* value) {
  set_has_svdatasubpath();
  if (svdatasubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatasubpath_ = new ::std::string;
  }
  svdatasubpath_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVdatasubpath)
}
inline void PrtoIoop::set_svdatasubpath(const void* value, size_t size) {
  set_has_svdatasubpath();
  if (svdatasubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatasubpath_ = new ::std::string;
  }
  svdatasubpath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVdatasubpath)
}
inline ::std::string* PrtoIoop::mutable_svdatasubpath() {
  set_has_svdatasubpath();
  if (svdatasubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svdatasubpath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVdatasubpath)
  return svdatasubpath_;
}
inline ::std::string* PrtoIoop::release_svdatasubpath() {
  clear_has_svdatasubpath();
  if (svdatasubpath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svdatasubpath_;
    svdatasubpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svdatasubpath(::std::string* svdatasubpath) {
  if (svdatasubpath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svdatasubpath_;
  }
  if (svdatasubpath) {
    set_has_svdatasubpath();
    svdatasubpath_ = svdatasubpath;
  } else {
    clear_has_svdatasubpath();
    svdatasubpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVdatasubpath)
}

// optional bytes sVthriftaddress = 7;
inline bool PrtoIoop::has_svthriftaddress() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoIoop::set_has_svthriftaddress() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoIoop::clear_has_svthriftaddress() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoIoop::clear_svthriftaddress() {
  if (svthriftaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftaddress_->clear();
  }
  clear_has_svthriftaddress();
}
inline const ::std::string& PrtoIoop::svthriftaddress() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVthriftaddress)
  return *svthriftaddress_;
}
inline void PrtoIoop::set_svthriftaddress(const ::std::string& value) {
  set_has_svthriftaddress();
  if (svthriftaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftaddress_ = new ::std::string;
  }
  svthriftaddress_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVthriftaddress)
}
inline void PrtoIoop::set_svthriftaddress(const char* value) {
  set_has_svthriftaddress();
  if (svthriftaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftaddress_ = new ::std::string;
  }
  svthriftaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVthriftaddress)
}
inline void PrtoIoop::set_svthriftaddress(const void* value, size_t size) {
  set_has_svthriftaddress();
  if (svthriftaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftaddress_ = new ::std::string;
  }
  svthriftaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVthriftaddress)
}
inline ::std::string* PrtoIoop::mutable_svthriftaddress() {
  set_has_svthriftaddress();
  if (svthriftaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVthriftaddress)
  return svthriftaddress_;
}
inline ::std::string* PrtoIoop::release_svthriftaddress() {
  clear_has_svthriftaddress();
  if (svthriftaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svthriftaddress_;
    svthriftaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svthriftaddress(::std::string* svthriftaddress) {
  if (svthriftaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svthriftaddress_;
  }
  if (svthriftaddress) {
    set_has_svthriftaddress();
    svthriftaddress_ = svthriftaddress;
  } else {
    clear_has_svthriftaddress();
    svthriftaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVthriftaddress)
}

// optional bytes sVthriftgossiperaddress = 8;
inline bool PrtoIoop::has_svthriftgossiperaddress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoIoop::set_has_svthriftgossiperaddress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoIoop::clear_has_svthriftgossiperaddress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoIoop::clear_svthriftgossiperaddress() {
  if (svthriftgossiperaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftgossiperaddress_->clear();
  }
  clear_has_svthriftgossiperaddress();
}
inline const ::std::string& PrtoIoop::svthriftgossiperaddress() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.sVthriftgossiperaddress)
  return *svthriftgossiperaddress_;
}
inline void PrtoIoop::set_svthriftgossiperaddress(const ::std::string& value) {
  set_has_svthriftgossiperaddress();
  if (svthriftgossiperaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftgossiperaddress_ = new ::std::string;
  }
  svthriftgossiperaddress_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.sVthriftgossiperaddress)
}
inline void PrtoIoop::set_svthriftgossiperaddress(const char* value) {
  set_has_svthriftgossiperaddress();
  if (svthriftgossiperaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftgossiperaddress_ = new ::std::string;
  }
  svthriftgossiperaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoIoop.sVthriftgossiperaddress)
}
inline void PrtoIoop::set_svthriftgossiperaddress(const void* value, size_t size) {
  set_has_svthriftgossiperaddress();
  if (svthriftgossiperaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftgossiperaddress_ = new ::std::string;
  }
  svthriftgossiperaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoIoop.sVthriftgossiperaddress)
}
inline ::std::string* PrtoIoop::mutable_svthriftgossiperaddress() {
  set_has_svthriftgossiperaddress();
  if (svthriftgossiperaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svthriftgossiperaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIoop.sVthriftgossiperaddress)
  return svthriftgossiperaddress_;
}
inline ::std::string* PrtoIoop::release_svthriftgossiperaddress() {
  clear_has_svthriftgossiperaddress();
  if (svthriftgossiperaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svthriftgossiperaddress_;
    svthriftgossiperaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoIoop::set_allocated_svthriftgossiperaddress(::std::string* svthriftgossiperaddress) {
  if (svthriftgossiperaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svthriftgossiperaddress_;
  }
  if (svthriftgossiperaddress) {
    set_has_svthriftgossiperaddress();
    svthriftgossiperaddress_ = svthriftgossiperaddress;
  } else {
    clear_has_svthriftgossiperaddress();
    svthriftgossiperaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIoop.sVthriftgossiperaddress)
}

// optional int32 iVthriftport = 9;
inline bool PrtoIoop::has_ivthriftport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PrtoIoop::set_has_ivthriftport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PrtoIoop::clear_has_ivthriftport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PrtoIoop::clear_ivthriftport() {
  ivthriftport_ = 0;
  clear_has_ivthriftport();
}
inline ::google::protobuf::int32 PrtoIoop::ivthriftport() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.iVthriftport)
  return ivthriftport_;
}
inline void PrtoIoop::set_ivthriftport(::google::protobuf::int32 value) {
  set_has_ivthriftport();
  ivthriftport_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.iVthriftport)
}

// optional int32 iVthriftgossiperport = 10;
inline bool PrtoIoop::has_ivthriftgossiperport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PrtoIoop::set_has_ivthriftgossiperport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PrtoIoop::clear_has_ivthriftgossiperport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PrtoIoop::clear_ivthriftgossiperport() {
  ivthriftgossiperport_ = 0;
  clear_has_ivthriftgossiperport();
}
inline ::google::protobuf::int32 PrtoIoop::ivthriftgossiperport() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.iVthriftgossiperport)
  return ivthriftgossiperport_;
}
inline void PrtoIoop::set_ivthriftgossiperport(::google::protobuf::int32 value) {
  set_has_ivthriftgossiperport();
  ivthriftgossiperport_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.iVthriftgossiperport)
}

// optional int32 iVredologdim = 11;
inline bool PrtoIoop::has_ivredologdim() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PrtoIoop::set_has_ivredologdim() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PrtoIoop::clear_has_ivredologdim() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PrtoIoop::clear_ivredologdim() {
  ivredologdim_ = 0;
  clear_has_ivredologdim();
}
inline ::google::protobuf::int32 PrtoIoop::ivredologdim() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.iVredologdim)
  return ivredologdim_;
}
inline void PrtoIoop::set_ivredologdim(::google::protobuf::int32 value) {
  set_has_ivredologdim();
  ivredologdim_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.iVredologdim)
}

// optional int32 iVthriftlisteners = 12;
inline bool PrtoIoop::has_ivthriftlisteners() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PrtoIoop::set_has_ivthriftlisteners() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PrtoIoop::clear_has_ivthriftlisteners() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PrtoIoop::clear_ivthriftlisteners() {
  ivthriftlisteners_ = 0;
  clear_has_ivthriftlisteners();
}
inline ::google::protobuf::int32 PrtoIoop::ivthriftlisteners() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.iVthriftlisteners)
  return ivthriftlisteners_;
}
inline void PrtoIoop::set_ivthriftlisteners(::google::protobuf::int32 value) {
  set_has_ivthriftlisteners();
  ivthriftlisteners_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.iVthriftlisteners)
}

// optional int32 iVmaxcompactionlevel = 13;
inline bool PrtoIoop::has_ivmaxcompactionlevel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PrtoIoop::set_has_ivmaxcompactionlevel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PrtoIoop::clear_has_ivmaxcompactionlevel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PrtoIoop::clear_ivmaxcompactionlevel() {
  ivmaxcompactionlevel_ = 0;
  clear_has_ivmaxcompactionlevel();
}
inline ::google::protobuf::int32 PrtoIoop::ivmaxcompactionlevel() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.iVmaxcompactionlevel)
  return ivmaxcompactionlevel_;
}
inline void PrtoIoop::set_ivmaxcompactionlevel(::google::protobuf::int32 value) {
  set_has_ivmaxcompactionlevel();
  ivmaxcompactionlevel_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.iVmaxcompactionlevel)
}

// optional int32 iVreplicationfactor = 14;
inline bool PrtoIoop::has_ivreplicationfactor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PrtoIoop::set_has_ivreplicationfactor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PrtoIoop::clear_has_ivreplicationfactor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PrtoIoop::clear_ivreplicationfactor() {
  ivreplicationfactor_ = 0;
  clear_has_ivreplicationfactor();
}
inline ::google::protobuf::int32 PrtoIoop::ivreplicationfactor() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.iVreplicationfactor)
  return ivreplicationfactor_;
}
inline void PrtoIoop::set_ivreplicationfactor(::google::protobuf::int32 value) {
  set_has_ivreplicationfactor();
  ivreplicationfactor_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.iVreplicationfactor)
}

// optional bool bVerrorifexists = 15;
inline bool PrtoIoop::has_bverrorifexists() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PrtoIoop::set_has_bverrorifexists() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PrtoIoop::clear_has_bverrorifexists() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PrtoIoop::clear_bverrorifexists() {
  bverrorifexists_ = false;
  clear_has_bverrorifexists();
}
inline bool PrtoIoop::bverrorifexists() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIoop.bVerrorifexists)
  return bverrorifexists_;
}
inline void PrtoIoop::set_bverrorifexists(bool value) {
  set_has_bverrorifexists();
  bverrorifexists_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIoop.bVerrorifexists)
}

// -------------------------------------------------------------------

// PrtoIwop

// required .com.tomting.orion.iCdbleveltype iVlevel = 1;
inline bool PrtoIwop::has_ivlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoIwop::set_has_ivlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoIwop::clear_has_ivlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoIwop::clear_ivlevel() {
  ivlevel_ = 1;
  clear_has_ivlevel();
}
inline ::com::tomting::orion::iCdbleveltype PrtoIwop::ivlevel() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.iVlevel)
  return static_cast< ::com::tomting::orion::iCdbleveltype >(ivlevel_);
}
inline void PrtoIwop::set_ivlevel(::com::tomting::orion::iCdbleveltype value) {
  assert(::com::tomting::orion::iCdbleveltype_IsValid(value));
  set_has_ivlevel();
  ivlevel_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIwop.iVlevel)
}

// optional .com.tomting.orion.PrtoLstm cVstatementL1 = 2;
inline bool PrtoIwop::has_cvstatementl1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoIwop::set_has_cvstatementl1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoIwop::clear_has_cvstatementl1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoIwop::clear_cvstatementl1() {
  if (cvstatementl1_ != NULL) cvstatementl1_->::com::tomting::orion::PrtoLstm::Clear();
  clear_has_cvstatementl1();
}
inline const ::com::tomting::orion::PrtoLstm& PrtoIwop::cvstatementl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.cVstatementL1)
  return cvstatementl1_ != NULL ? *cvstatementl1_ : *default_instance_->cvstatementl1_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoIwop::mutable_cvstatementl1() {
  set_has_cvstatementl1();
  if (cvstatementl1_ == NULL) cvstatementl1_ = new ::com::tomting::orion::PrtoLstm;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIwop.cVstatementL1)
  return cvstatementl1_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoIwop::release_cvstatementl1() {
  clear_has_cvstatementl1();
  ::com::tomting::orion::PrtoLstm* temp = cvstatementl1_;
  cvstatementl1_ = NULL;
  return temp;
}
inline void PrtoIwop::set_allocated_cvstatementl1(::com::tomting::orion::PrtoLstm* cvstatementl1) {
  delete cvstatementl1_;
  cvstatementl1_ = cvstatementl1;
  if (cvstatementl1) {
    set_has_cvstatementl1();
  } else {
    clear_has_cvstatementl1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIwop.cVstatementL1)
}

// optional .com.tomting.orion.PrtoL2st cVstatementL2 = 3;
inline bool PrtoIwop::has_cvstatementl2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoIwop::set_has_cvstatementl2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoIwop::clear_has_cvstatementl2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoIwop::clear_cvstatementl2() {
  if (cvstatementl2_ != NULL) cvstatementl2_->::com::tomting::orion::PrtoL2st::Clear();
  clear_has_cvstatementl2();
}
inline const ::com::tomting::orion::PrtoL2st& PrtoIwop::cvstatementl2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.cVstatementL2)
  return cvstatementl2_ != NULL ? *cvstatementl2_ : *default_instance_->cvstatementl2_;
}
inline ::com::tomting::orion::PrtoL2st* PrtoIwop::mutable_cvstatementl2() {
  set_has_cvstatementl2();
  if (cvstatementl2_ == NULL) cvstatementl2_ = new ::com::tomting::orion::PrtoL2st;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIwop.cVstatementL2)
  return cvstatementl2_;
}
inline ::com::tomting::orion::PrtoL2st* PrtoIwop::release_cvstatementl2() {
  clear_has_cvstatementl2();
  ::com::tomting::orion::PrtoL2st* temp = cvstatementl2_;
  cvstatementl2_ = NULL;
  return temp;
}
inline void PrtoIwop::set_allocated_cvstatementl2(::com::tomting::orion::PrtoL2st* cvstatementl2) {
  delete cvstatementl2_;
  cvstatementl2_ = cvstatementl2;
  if (cvstatementl2) {
    set_has_cvstatementl2();
  } else {
    clear_has_cvstatementl2();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIwop.cVstatementL2)
}

// optional bool bVoptimizewriteindex = 4;
inline bool PrtoIwop::has_bvoptimizewriteindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoIwop::set_has_bvoptimizewriteindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoIwop::clear_has_bvoptimizewriteindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoIwop::clear_bvoptimizewriteindex() {
  bvoptimizewriteindex_ = false;
  clear_has_bvoptimizewriteindex();
}
inline bool PrtoIwop::bvoptimizewriteindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.bVoptimizewriteindex)
  return bvoptimizewriteindex_;
}
inline void PrtoIwop::set_bvoptimizewriteindex(bool value) {
  set_has_bvoptimizewriteindex();
  bvoptimizewriteindex_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIwop.bVoptimizewriteindex)
}

// optional bool bVupdateonlyindex = 5;
inline bool PrtoIwop::has_bvupdateonlyindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoIwop::set_has_bvupdateonlyindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoIwop::clear_has_bvupdateonlyindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoIwop::clear_bvupdateonlyindex() {
  bvupdateonlyindex_ = false;
  clear_has_bvupdateonlyindex();
}
inline bool PrtoIwop::bvupdateonlyindex() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.bVupdateonlyindex)
  return bvupdateonlyindex_;
}
inline void PrtoIwop::set_bvupdateonlyindex(bool value) {
  set_has_bvupdateonlyindex();
  bvupdateonlyindex_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIwop.bVupdateonlyindex)
}

// optional bool bVlocalfilter = 6;
inline bool PrtoIwop::has_bvlocalfilter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoIwop::set_has_bvlocalfilter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoIwop::clear_has_bvlocalfilter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoIwop::clear_bvlocalfilter() {
  bvlocalfilter_ = false;
  clear_has_bvlocalfilter();
}
inline bool PrtoIwop::bvlocalfilter() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.bVlocalfilter)
  return bvlocalfilter_;
}
inline void PrtoIwop::set_bvlocalfilter(bool value) {
  set_has_bvlocalfilter();
  bvlocalfilter_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIwop.bVlocalfilter)
}

// optional bool bVenabletimestamp = 7;
inline bool PrtoIwop::has_bvenabletimestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoIwop::set_has_bvenabletimestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoIwop::clear_has_bvenabletimestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoIwop::clear_bvenabletimestamp() {
  bvenabletimestamp_ = false;
  clear_has_bvenabletimestamp();
}
inline bool PrtoIwop::bvenabletimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIwop.bVenabletimestamp)
  return bvenabletimestamp_;
}
inline void PrtoIwop::set_bvenabletimestamp(bool value) {
  set_has_bvenabletimestamp();
  bvenabletimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIwop.bVenabletimestamp)
}

// -------------------------------------------------------------------

// PrtoIrop

// required .com.tomting.orion.iCdbleveltype iVlevel = 1;
inline bool PrtoIrop::has_ivlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoIrop::set_has_ivlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoIrop::clear_has_ivlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoIrop::clear_ivlevel() {
  ivlevel_ = 1;
  clear_has_ivlevel();
}
inline ::com::tomting::orion::iCdbleveltype PrtoIrop::ivlevel() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIrop.iVlevel)
  return static_cast< ::com::tomting::orion::iCdbleveltype >(ivlevel_);
}
inline void PrtoIrop::set_ivlevel(::com::tomting::orion::iCdbleveltype value) {
  assert(::com::tomting::orion::iCdbleveltype_IsValid(value));
  set_has_ivlevel();
  ivlevel_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIrop.iVlevel)
}

// optional .com.tomting.orion.PrtoLqry cVqueryL1 = 2;
inline bool PrtoIrop::has_cvqueryl1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoIrop::set_has_cvqueryl1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoIrop::clear_has_cvqueryl1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoIrop::clear_cvqueryl1() {
  if (cvqueryl1_ != NULL) cvqueryl1_->::com::tomting::orion::PrtoLqry::Clear();
  clear_has_cvqueryl1();
}
inline const ::com::tomting::orion::PrtoLqry& PrtoIrop::cvqueryl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIrop.cVqueryL1)
  return cvqueryl1_ != NULL ? *cvqueryl1_ : *default_instance_->cvqueryl1_;
}
inline ::com::tomting::orion::PrtoLqry* PrtoIrop::mutable_cvqueryl1() {
  set_has_cvqueryl1();
  if (cvqueryl1_ == NULL) cvqueryl1_ = new ::com::tomting::orion::PrtoLqry;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIrop.cVqueryL1)
  return cvqueryl1_;
}
inline ::com::tomting::orion::PrtoLqry* PrtoIrop::release_cvqueryl1() {
  clear_has_cvqueryl1();
  ::com::tomting::orion::PrtoLqry* temp = cvqueryl1_;
  cvqueryl1_ = NULL;
  return temp;
}
inline void PrtoIrop::set_allocated_cvqueryl1(::com::tomting::orion::PrtoLqry* cvqueryl1) {
  delete cvqueryl1_;
  cvqueryl1_ = cvqueryl1;
  if (cvqueryl1) {
    set_has_cvqueryl1();
  } else {
    clear_has_cvqueryl1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIrop.cVqueryL1)
}

// optional .com.tomting.orion.PrtoL2qr cVqueryL2 = 3;
inline bool PrtoIrop::has_cvqueryl2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoIrop::set_has_cvqueryl2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoIrop::clear_has_cvqueryl2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoIrop::clear_cvqueryl2() {
  if (cvqueryl2_ != NULL) cvqueryl2_->::com::tomting::orion::PrtoL2qr::Clear();
  clear_has_cvqueryl2();
}
inline const ::com::tomting::orion::PrtoL2qr& PrtoIrop::cvqueryl2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIrop.cVqueryL2)
  return cvqueryl2_ != NULL ? *cvqueryl2_ : *default_instance_->cvqueryl2_;
}
inline ::com::tomting::orion::PrtoL2qr* PrtoIrop::mutable_cvqueryl2() {
  set_has_cvqueryl2();
  if (cvqueryl2_ == NULL) cvqueryl2_ = new ::com::tomting::orion::PrtoL2qr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIrop.cVqueryL2)
  return cvqueryl2_;
}
inline ::com::tomting::orion::PrtoL2qr* PrtoIrop::release_cvqueryl2() {
  clear_has_cvqueryl2();
  ::com::tomting::orion::PrtoL2qr* temp = cvqueryl2_;
  cvqueryl2_ = NULL;
  return temp;
}
inline void PrtoIrop::set_allocated_cvqueryl2(::com::tomting::orion::PrtoL2qr* cvqueryl2) {
  delete cvqueryl2_;
  cvqueryl2_ = cvqueryl2;
  if (cvqueryl2) {
    set_has_cvqueryl2();
  } else {
    clear_has_cvqueryl2();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIrop.cVqueryL2)
}

// -------------------------------------------------------------------

// PrtoIgop

// required .com.tomting.orion.iCdbleveltype iVlevel = 1;
inline bool PrtoIgop::has_ivlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoIgop::set_has_ivlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoIgop::clear_has_ivlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoIgop::clear_ivlevel() {
  ivlevel_ = 1;
  clear_has_ivlevel();
}
inline ::com::tomting::orion::iCdbleveltype PrtoIgop::ivlevel() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIgop.iVlevel)
  return static_cast< ::com::tomting::orion::iCdbleveltype >(ivlevel_);
}
inline void PrtoIgop::set_ivlevel(::com::tomting::orion::iCdbleveltype value) {
  assert(::com::tomting::orion::iCdbleveltype_IsValid(value));
  set_has_ivlevel();
  ivlevel_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIgop.iVlevel)
}

// optional .com.tomting.orion.PrtoLmtb cVdmlL1 = 2;
inline bool PrtoIgop::has_cvdmll1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoIgop::set_has_cvdmll1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoIgop::clear_has_cvdmll1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoIgop::clear_cvdmll1() {
  if (cvdmll1_ != NULL) cvdmll1_->::com::tomting::orion::PrtoLmtb::Clear();
  clear_has_cvdmll1();
}
inline const ::com::tomting::orion::PrtoLmtb& PrtoIgop::cvdmll1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIgop.cVdmlL1)
  return cvdmll1_ != NULL ? *cvdmll1_ : *default_instance_->cvdmll1_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoIgop::mutable_cvdmll1() {
  set_has_cvdmll1();
  if (cvdmll1_ == NULL) cvdmll1_ = new ::com::tomting::orion::PrtoLmtb;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIgop.cVdmlL1)
  return cvdmll1_;
}
inline ::com::tomting::orion::PrtoLmtb* PrtoIgop::release_cvdmll1() {
  clear_has_cvdmll1();
  ::com::tomting::orion::PrtoLmtb* temp = cvdmll1_;
  cvdmll1_ = NULL;
  return temp;
}
inline void PrtoIgop::set_allocated_cvdmll1(::com::tomting::orion::PrtoLmtb* cvdmll1) {
  delete cvdmll1_;
  cvdmll1_ = cvdmll1;
  if (cvdmll1) {
    set_has_cvdmll1();
  } else {
    clear_has_cvdmll1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIgop.cVdmlL1)
}

// optional .com.tomting.orion.PrtoL2ct cVdmlL2 = 3;
inline bool PrtoIgop::has_cvdmll2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoIgop::set_has_cvdmll2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoIgop::clear_has_cvdmll2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoIgop::clear_cvdmll2() {
  if (cvdmll2_ != NULL) cvdmll2_->::com::tomting::orion::PrtoL2ct::Clear();
  clear_has_cvdmll2();
}
inline const ::com::tomting::orion::PrtoL2ct& PrtoIgop::cvdmll2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIgop.cVdmlL2)
  return cvdmll2_ != NULL ? *cvdmll2_ : *default_instance_->cvdmll2_;
}
inline ::com::tomting::orion::PrtoL2ct* PrtoIgop::mutable_cvdmll2() {
  set_has_cvdmll2();
  if (cvdmll2_ == NULL) cvdmll2_ = new ::com::tomting::orion::PrtoL2ct;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIgop.cVdmlL2)
  return cvdmll2_;
}
inline ::com::tomting::orion::PrtoL2ct* PrtoIgop::release_cvdmll2() {
  clear_has_cvdmll2();
  ::com::tomting::orion::PrtoL2ct* temp = cvdmll2_;
  cvdmll2_ = NULL;
  return temp;
}
inline void PrtoIgop::set_allocated_cvdmll2(::com::tomting::orion::PrtoL2ct* cvdmll2) {
  delete cvdmll2_;
  cvdmll2_ = cvdmll2;
  if (cvdmll2) {
    set_has_cvdmll2();
  } else {
    clear_has_cvdmll2();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIgop.cVdmlL2)
}

// -------------------------------------------------------------------

// PrtoIsop

// required bool bVresult = 1;
inline bool PrtoIsop::has_bvresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoIsop::set_has_bvresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoIsop::clear_has_bvresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoIsop::clear_bvresult() {
  bvresult_ = false;
  clear_has_bvresult();
}
inline bool PrtoIsop::bvresult() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIsop.bVresult)
  return bvresult_;
}
inline void PrtoIsop::set_bvresult(bool value) {
  set_has_bvresult();
  bvresult_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIsop.bVresult)
}

// optional .com.tomting.orion.PrtoL1mr cVsnapshotL1 = 2;
inline bool PrtoIsop::has_cvsnapshotl1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoIsop::set_has_cvsnapshotl1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoIsop::clear_has_cvsnapshotl1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoIsop::clear_cvsnapshotl1() {
  if (cvsnapshotl1_ != NULL) cvsnapshotl1_->::com::tomting::orion::PrtoL1mr::Clear();
  clear_has_cvsnapshotl1();
}
inline const ::com::tomting::orion::PrtoL1mr& PrtoIsop::cvsnapshotl1() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIsop.cVsnapshotL1)
  return cvsnapshotl1_ != NULL ? *cvsnapshotl1_ : *default_instance_->cvsnapshotl1_;
}
inline ::com::tomting::orion::PrtoL1mr* PrtoIsop::mutable_cvsnapshotl1() {
  set_has_cvsnapshotl1();
  if (cvsnapshotl1_ == NULL) cvsnapshotl1_ = new ::com::tomting::orion::PrtoL1mr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIsop.cVsnapshotL1)
  return cvsnapshotl1_;
}
inline ::com::tomting::orion::PrtoL1mr* PrtoIsop::release_cvsnapshotl1() {
  clear_has_cvsnapshotl1();
  ::com::tomting::orion::PrtoL1mr* temp = cvsnapshotl1_;
  cvsnapshotl1_ = NULL;
  return temp;
}
inline void PrtoIsop::set_allocated_cvsnapshotl1(::com::tomting::orion::PrtoL1mr* cvsnapshotl1) {
  delete cvsnapshotl1_;
  cvsnapshotl1_ = cvsnapshotl1;
  if (cvsnapshotl1) {
    set_has_cvsnapshotl1();
  } else {
    clear_has_cvsnapshotl1();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIsop.cVsnapshotL1)
}

// optional .com.tomting.orion.PrtoL2mr cVsnapshotL2 = 3;
inline bool PrtoIsop::has_cvsnapshotl2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoIsop::set_has_cvsnapshotl2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoIsop::clear_has_cvsnapshotl2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoIsop::clear_cvsnapshotl2() {
  if (cvsnapshotl2_ != NULL) cvsnapshotl2_->::com::tomting::orion::PrtoL2mr::Clear();
  clear_has_cvsnapshotl2();
}
inline const ::com::tomting::orion::PrtoL2mr& PrtoIsop::cvsnapshotl2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIsop.cVsnapshotL2)
  return cvsnapshotl2_ != NULL ? *cvsnapshotl2_ : *default_instance_->cvsnapshotl2_;
}
inline ::com::tomting::orion::PrtoL2mr* PrtoIsop::mutable_cvsnapshotl2() {
  set_has_cvsnapshotl2();
  if (cvsnapshotl2_ == NULL) cvsnapshotl2_ = new ::com::tomting::orion::PrtoL2mr;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIsop.cVsnapshotL2)
  return cvsnapshotl2_;
}
inline ::com::tomting::orion::PrtoL2mr* PrtoIsop::release_cvsnapshotl2() {
  clear_has_cvsnapshotl2();
  ::com::tomting::orion::PrtoL2mr* temp = cvsnapshotl2_;
  cvsnapshotl2_ = NULL;
  return temp;
}
inline void PrtoIsop::set_allocated_cvsnapshotl2(::com::tomting::orion::PrtoL2mr* cvsnapshotl2) {
  delete cvsnapshotl2_;
  cvsnapshotl2_ = cvsnapshotl2;
  if (cvsnapshotl2) {
    set_has_cvsnapshotl2();
  } else {
    clear_has_cvsnapshotl2();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIsop.cVsnapshotL2)
}

// -------------------------------------------------------------------

// PrtoIqop

// required .com.tomting.orion.PrtoL2os cVosqlL2 = 1;
inline bool PrtoIqop::has_cvosqll2() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoIqop::set_has_cvosqll2() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoIqop::clear_has_cvosqll2() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoIqop::clear_cvosqll2() {
  if (cvosqll2_ != NULL) cvosqll2_->::com::tomting::orion::PrtoL2os::Clear();
  clear_has_cvosqll2();
}
inline const ::com::tomting::orion::PrtoL2os& PrtoIqop::cvosqll2() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIqop.cVosqlL2)
  return cvosqll2_ != NULL ? *cvosqll2_ : *default_instance_->cvosqll2_;
}
inline ::com::tomting::orion::PrtoL2os* PrtoIqop::mutable_cvosqll2() {
  set_has_cvosqll2();
  if (cvosqll2_ == NULL) cvosqll2_ = new ::com::tomting::orion::PrtoL2os;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoIqop.cVosqlL2)
  return cvosqll2_;
}
inline ::com::tomting::orion::PrtoL2os* PrtoIqop::release_cvosqll2() {
  clear_has_cvosqll2();
  ::com::tomting::orion::PrtoL2os* temp = cvosqll2_;
  cvosqll2_ = NULL;
  return temp;
}
inline void PrtoIqop::set_allocated_cvosqll2(::com::tomting::orion::PrtoL2os* cvosqll2) {
  delete cvosqll2_;
  cvosqll2_ = cvosqll2;
  if (cvosqll2) {
    set_has_cvosqll2();
  } else {
    clear_has_cvosqll2();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoIqop.cVosqlL2)
}

// optional bool bVenabletimestamp = 2;
inline bool PrtoIqop::has_bvenabletimestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoIqop::set_has_bvenabletimestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoIqop::clear_has_bvenabletimestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoIqop::clear_bvenabletimestamp() {
  bvenabletimestamp_ = false;
  clear_has_bvenabletimestamp();
}
inline bool PrtoIqop::bvenabletimestamp() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoIqop.bVenabletimestamp)
  return bvenabletimestamp_;
}
inline void PrtoIqop::set_bvenabletimestamp(bool value) {
  set_has_bvenabletimestamp();
  bvenabletimestamp_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoIqop.bVenabletimestamp)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace orion
}  // namespace tomting
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::tomting::orion::iCpartitiontype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCpartitiontype>() {
  return ::com::tomting::orion::iCpartitiontype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCstatetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCstatetype>() {
  return ::com::tomting::orion::iCstatetype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCopcodetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCopcodetype>() {
  return ::com::tomting::orion::iCopcodetype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCquerytype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCquerytype>() {
  return ::com::tomting::orion::iCquerytype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCtablettype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCtablettype>() {
  return ::com::tomting::orion::iCtablettype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCcolumntype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCcolumntype>() {
  return ::com::tomting::orion::iCcolumntype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCconditiontype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCconditiontype>() {
  return ::com::tomting::orion::iCconditiontype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCtabletype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCtabletype>() {
  return ::com::tomting::orion::iCtabletype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCindextype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCindextype>() {
  return ::com::tomting::orion::iCindextype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCordertype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCordertype>() {
  return ::com::tomting::orion::iCordertype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCstategossipnode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCstategossipnode>() {
  return ::com::tomting::orion::iCstategossipnode_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCstatstype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCstatstype>() {
  return ::com::tomting::orion::iCstatstype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCservicetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCservicetype>() {
  return ::com::tomting::orion::iCservicetype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCbulkservicetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCbulkservicetype>() {
  return ::com::tomting::orion::iCbulkservicetype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCdbleveltype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCdbleveltype>() {
  return ::com::tomting::orion::iCdbleveltype_descriptor();
}
template <> struct is_proto_enum< ::com::tomting::orion::iCembeddedservicetype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCembeddedservicetype>() {
  return ::com::tomting::orion::iCembeddedservicetype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PrtoAlog_2eproto__INCLUDED
