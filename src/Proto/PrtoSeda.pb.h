// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PrtoSeda.proto

#ifndef PROTOBUF_PrtoSeda_2eproto__INCLUDED
#define PROTOBUF_PrtoSeda_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "PrtoAlog.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace tomting {
namespace orion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PrtoSeda_2eproto();
void protobuf_AssignDesc_PrtoSeda_2eproto();
void protobuf_ShutdownFile_PrtoSeda_2eproto();

class PrtoMktr;
class PrtoQres;
class PrtoSeda;

enum iCcompactiontype {
  MINOR = 0,
  MAJOR = 1,
  MERGE = 2,
  FLUSH = 3
};
bool iCcompactiontype_IsValid(int value);
const iCcompactiontype iCcompactiontype_MIN = MINOR;
const iCcompactiontype iCcompactiontype_MAX = FLUSH;
const int iCcompactiontype_ARRAYSIZE = iCcompactiontype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCcompactiontype_descriptor();
inline const ::std::string& iCcompactiontype_Name(iCcompactiontype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCcompactiontype_descriptor(), value);
}
inline bool iCcompactiontype_Parse(
    const ::std::string& name, iCcompactiontype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCcompactiontype>(
    iCcompactiontype_descriptor(), name, value);
}
// ===================================================================

class PrtoMktr : public ::google::protobuf::Message {
 public:
  PrtoMktr();
  virtual ~PrtoMktr();

  PrtoMktr(const PrtoMktr& from);

  inline PrtoMktr& operator=(const PrtoMktr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoMktr& default_instance();

  void Swap(PrtoMktr* other);

  // implements Message ----------------------------------------------

  PrtoMktr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoMktr& from);
  void MergeFrom(const PrtoMktr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool bVleaf = 1;
  inline bool has_bvleaf() const;
  inline void clear_bvleaf();
  static const int kBVleafFieldNumber = 1;
  inline bool bvleaf() const;
  inline void set_bvleaf(bool value);

  // required bytes sVhash = 2;
  inline bool has_svhash() const;
  inline void clear_svhash();
  static const int kSVhashFieldNumber = 2;
  inline const ::std::string& svhash() const;
  inline void set_svhash(const ::std::string& value);
  inline void set_svhash(const char* value);
  inline void set_svhash(const void* value, size_t size);
  inline ::std::string* mutable_svhash();
  inline ::std::string* release_svhash();
  inline void set_allocated_svhash(::std::string* svhash);

  // optional int32 iVmerkeltreedataposition = 3;
  inline bool has_ivmerkeltreedataposition() const;
  inline void clear_ivmerkeltreedataposition();
  static const int kIVmerkeltreedatapositionFieldNumber = 3;
  inline ::google::protobuf::int32 ivmerkeltreedataposition() const;
  inline void set_ivmerkeltreedataposition(::google::protobuf::int32 value);

  // repeated .com.tomting.orion.PrtoMktr cVchildren = 4;
  inline int cvchildren_size() const;
  inline void clear_cvchildren();
  static const int kCVchildrenFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoMktr& cvchildren(int index) const;
  inline ::com::tomting::orion::PrtoMktr* mutable_cvchildren(int index);
  inline ::com::tomting::orion::PrtoMktr* add_cvchildren();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoMktr >&
      cvchildren() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoMktr >*
      mutable_cvchildren();

  // optional .com.tomting.orion.PrtoLkey cVkey = 5;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 5;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // optional .com.tomting.orion.PrtoLval cVvalue = 6;
  inline bool has_cvvalue() const;
  inline void clear_cvvalue();
  static const int kCVvalueFieldNumber = 6;
  inline const ::com::tomting::orion::PrtoLval& cvvalue() const;
  inline ::com::tomting::orion::PrtoLval* mutable_cvvalue();
  inline ::com::tomting::orion::PrtoLval* release_cvvalue();
  inline void set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoMktr)
 private:
  inline void set_has_bvleaf();
  inline void clear_has_bvleaf();
  inline void set_has_svhash();
  inline void clear_has_svhash();
  inline void set_has_ivmerkeltreedataposition();
  inline void clear_has_ivmerkeltreedataposition();
  inline void set_has_cvkey();
  inline void clear_has_cvkey();
  inline void set_has_cvvalue();
  inline void clear_has_cvvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svhash_;
  bool bvleaf_;
  ::google::protobuf::int32 ivmerkeltreedataposition_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoMktr > cvchildren_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  ::com::tomting::orion::PrtoLval* cvvalue_;
  friend void  protobuf_AddDesc_PrtoSeda_2eproto();
  friend void protobuf_AssignDesc_PrtoSeda_2eproto();
  friend void protobuf_ShutdownFile_PrtoSeda_2eproto();

  void InitAsDefaultInstance();
  static PrtoMktr* default_instance_;
};
// -------------------------------------------------------------------

class PrtoQres : public ::google::protobuf::Message {
 public:
  PrtoQres();
  virtual ~PrtoQres();

  PrtoQres(const PrtoQres& from);

  inline PrtoQres& operator=(const PrtoQres& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoQres& default_instance();

  void Swap(PrtoQres* other);

  // implements Message ----------------------------------------------

  PrtoQres* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoQres& from);
  void MergeFrom(const PrtoQres& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVnodeid = 1;
  inline bool has_svnodeid() const;
  inline void clear_svnodeid();
  static const int kSVnodeidFieldNumber = 1;
  inline const ::std::string& svnodeid() const;
  inline void set_svnodeid(const ::std::string& value);
  inline void set_svnodeid(const char* value);
  inline void set_svnodeid(const void* value, size_t size);
  inline ::std::string* mutable_svnodeid();
  inline ::std::string* release_svnodeid();
  inline void set_allocated_svnodeid(::std::string* svnodeid);

  // required .com.tomting.orion.PrtoLkey cVkey = 2;
  inline bool has_cvkey() const;
  inline void clear_cvkey();
  static const int kCVkeyFieldNumber = 2;
  inline const ::com::tomting::orion::PrtoLkey& cvkey() const;
  inline ::com::tomting::orion::PrtoLkey* mutable_cvkey();
  inline ::com::tomting::orion::PrtoLkey* release_cvkey();
  inline void set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey);

  // required bool bVresult = 3;
  inline bool has_bvresult() const;
  inline void clear_bvresult();
  static const int kBVresultFieldNumber = 3;
  inline bool bvresult() const;
  inline void set_bvresult(bool value);

  // required .com.tomting.orion.PrtoLval cVvalue = 4;
  inline bool has_cvvalue() const;
  inline void clear_cvvalue();
  static const int kCVvalueFieldNumber = 4;
  inline const ::com::tomting::orion::PrtoLval& cvvalue() const;
  inline ::com::tomting::orion::PrtoLval* mutable_cvvalue();
  inline ::com::tomting::orion::PrtoLval* release_cvvalue();
  inline void set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue);

  // required bool bVdigest = 5 [default = false];
  inline bool has_bvdigest() const;
  inline void clear_bvdigest();
  static const int kBVdigestFieldNumber = 5;
  inline bool bvdigest() const;
  inline void set_bvdigest(bool value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoQres)
 private:
  inline void set_has_svnodeid();
  inline void clear_has_svnodeid();
  inline void set_has_cvkey();
  inline void clear_has_cvkey();
  inline void set_has_bvresult();
  inline void clear_has_bvresult();
  inline void set_has_cvvalue();
  inline void clear_has_cvvalue();
  inline void set_has_bvdigest();
  inline void clear_has_bvdigest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnodeid_;
  ::com::tomting::orion::PrtoLkey* cvkey_;
  ::com::tomting::orion::PrtoLval* cvvalue_;
  bool bvresult_;
  bool bvdigest_;
  friend void  protobuf_AddDesc_PrtoSeda_2eproto();
  friend void protobuf_AssignDesc_PrtoSeda_2eproto();
  friend void protobuf_ShutdownFile_PrtoSeda_2eproto();

  void InitAsDefaultInstance();
  static PrtoQres* default_instance_;
};
// -------------------------------------------------------------------

class PrtoSeda : public ::google::protobuf::Message {
 public:
  PrtoSeda();
  virtual ~PrtoSeda();

  PrtoSeda(const PrtoSeda& from);

  inline PrtoSeda& operator=(const PrtoSeda& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoSeda& default_instance();

  void Swap(PrtoSeda* other);

  // implements Message ----------------------------------------------

  PrtoSeda* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoSeda& from);
  void MergeFrom(const PrtoSeda& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sVnamespace = 1;
  inline bool has_svnamespace() const;
  inline void clear_svnamespace();
  static const int kSVnamespaceFieldNumber = 1;
  inline const ::std::string& svnamespace() const;
  inline void set_svnamespace(const ::std::string& value);
  inline void set_svnamespace(const char* value);
  inline void set_svnamespace(const void* value, size_t size);
  inline ::std::string* mutable_svnamespace();
  inline ::std::string* release_svnamespace();
  inline void set_allocated_svnamespace(::std::string* svnamespace);

  // optional bytes sVtable = 2;
  inline bool has_svtable() const;
  inline void clear_svtable();
  static const int kSVtableFieldNumber = 2;
  inline const ::std::string& svtable() const;
  inline void set_svtable(const ::std::string& value);
  inline void set_svtable(const char* value);
  inline void set_svtable(const void* value, size_t size);
  inline ::std::string* mutable_svtable();
  inline ::std::string* release_svtable();
  inline void set_allocated_svtable(::std::string* svtable);

  // optional .com.tomting.orion.iCcompactiontype iVcompactiontype = 3;
  inline bool has_ivcompactiontype() const;
  inline void clear_ivcompactiontype();
  static const int kIVcompactiontypeFieldNumber = 3;
  inline ::com::tomting::orion::iCcompactiontype ivcompactiontype() const;
  inline void set_ivcompactiontype(::com::tomting::orion::iCcompactiontype value);

  // optional bytes sVmessage = 4;
  inline bool has_svmessage() const;
  inline void clear_svmessage();
  static const int kSVmessageFieldNumber = 4;
  inline const ::std::string& svmessage() const;
  inline void set_svmessage(const ::std::string& value);
  inline void set_svmessage(const char* value);
  inline void set_svmessage(const void* value, size_t size);
  inline ::std::string* mutable_svmessage();
  inline ::std::string* release_svmessage();
  inline void set_allocated_svmessage(::std::string* svmessage);

  // optional .com.tomting.orion.PrtoGoel cVgossipelement = 5;
  inline bool has_cvgossipelement() const;
  inline void clear_cvgossipelement();
  static const int kCVgossipelementFieldNumber = 5;
  inline const ::com::tomting::orion::PrtoGoel& cvgossipelement() const;
  inline ::com::tomting::orion::PrtoGoel* mutable_cvgossipelement();
  inline ::com::tomting::orion::PrtoGoel* release_cvgossipelement();
  inline void set_allocated_cvgossipelement(::com::tomting::orion::PrtoGoel* cvgossipelement);

  // optional .com.tomting.orion.PrtoLstm cVstatement = 6;
  inline bool has_cvstatement() const;
  inline void clear_cvstatement();
  static const int kCVstatementFieldNumber = 6;
  inline const ::com::tomting::orion::PrtoLstm& cvstatement() const;
  inline ::com::tomting::orion::PrtoLstm* mutable_cvstatement();
  inline ::com::tomting::orion::PrtoLstm* release_cvstatement();
  inline void set_allocated_cvstatement(::com::tomting::orion::PrtoLstm* cvstatement);

  // optional bytes sVcallback = 7;
  inline bool has_svcallback() const;
  inline void clear_svcallback();
  static const int kSVcallbackFieldNumber = 7;
  inline const ::std::string& svcallback() const;
  inline void set_svcallback(const ::std::string& value);
  inline void set_svcallback(const char* value);
  inline void set_svcallback(const void* value, size_t size);
  inline ::std::string* mutable_svcallback();
  inline ::std::string* release_svcallback();
  inline void set_allocated_svcallback(::std::string* svcallback);

  // optional .com.tomting.orion.PrtoLqry cVquery = 8;
  inline bool has_cvquery() const;
  inline void clear_cvquery();
  static const int kCVqueryFieldNumber = 8;
  inline const ::com::tomting::orion::PrtoLqry& cvquery() const;
  inline ::com::tomting::orion::PrtoLqry* mutable_cvquery();
  inline ::com::tomting::orion::PrtoLqry* release_cvquery();
  inline void set_allocated_cvquery(::com::tomting::orion::PrtoLqry* cvquery);

  // repeated .com.tomting.orion.PrtoQres cVlistqueryresult = 9;
  inline int cvlistqueryresult_size() const;
  inline void clear_cvlistqueryresult();
  static const int kCVlistqueryresultFieldNumber = 9;
  inline const ::com::tomting::orion::PrtoQres& cvlistqueryresult(int index) const;
  inline ::com::tomting::orion::PrtoQres* mutable_cvlistqueryresult(int index);
  inline ::com::tomting::orion::PrtoQres* add_cvlistqueryresult();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoQres >&
      cvlistqueryresult() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoQres >*
      mutable_cvlistqueryresult();

  // repeated .com.tomting.orion.PrtoGoel cVlistgossipelement = 10;
  inline int cvlistgossipelement_size() const;
  inline void clear_cvlistgossipelement();
  static const int kCVlistgossipelementFieldNumber = 10;
  inline const ::com::tomting::orion::PrtoGoel& cvlistgossipelement(int index) const;
  inline ::com::tomting::orion::PrtoGoel* mutable_cvlistgossipelement(int index);
  inline ::com::tomting::orion::PrtoGoel* add_cvlistgossipelement();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >&
      cvlistgossipelement() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >*
      mutable_cvlistgossipelement();

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoSeda)
 private:
  inline void set_has_svnamespace();
  inline void clear_has_svnamespace();
  inline void set_has_svtable();
  inline void clear_has_svtable();
  inline void set_has_ivcompactiontype();
  inline void clear_has_ivcompactiontype();
  inline void set_has_svmessage();
  inline void clear_has_svmessage();
  inline void set_has_cvgossipelement();
  inline void clear_has_cvgossipelement();
  inline void set_has_cvstatement();
  inline void clear_has_cvstatement();
  inline void set_has_svcallback();
  inline void clear_has_svcallback();
  inline void set_has_cvquery();
  inline void clear_has_cvquery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnamespace_;
  ::std::string* svtable_;
  ::std::string* svmessage_;
  ::com::tomting::orion::PrtoGoel* cvgossipelement_;
  ::com::tomting::orion::PrtoLstm* cvstatement_;
  ::std::string* svcallback_;
  ::com::tomting::orion::PrtoLqry* cvquery_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoQres > cvlistqueryresult_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel > cvlistgossipelement_;
  int ivcompactiontype_;
  friend void  protobuf_AddDesc_PrtoSeda_2eproto();
  friend void protobuf_AssignDesc_PrtoSeda_2eproto();
  friend void protobuf_ShutdownFile_PrtoSeda_2eproto();

  void InitAsDefaultInstance();
  static PrtoSeda* default_instance_;
};
// ===================================================================


// ===================================================================

// PrtoMktr

// required bool bVleaf = 1;
inline bool PrtoMktr::has_bvleaf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoMktr::set_has_bvleaf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoMktr::clear_has_bvleaf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoMktr::clear_bvleaf() {
  bvleaf_ = false;
  clear_has_bvleaf();
}
inline bool PrtoMktr::bvleaf() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoMktr.bVleaf)
  return bvleaf_;
}
inline void PrtoMktr::set_bvleaf(bool value) {
  set_has_bvleaf();
  bvleaf_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoMktr.bVleaf)
}

// required bytes sVhash = 2;
inline bool PrtoMktr::has_svhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoMktr::set_has_svhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoMktr::clear_has_svhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoMktr::clear_svhash() {
  if (svhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svhash_->clear();
  }
  clear_has_svhash();
}
inline const ::std::string& PrtoMktr::svhash() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoMktr.sVhash)
  return *svhash_;
}
inline void PrtoMktr::set_svhash(const ::std::string& value) {
  set_has_svhash();
  if (svhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svhash_ = new ::std::string;
  }
  svhash_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoMktr.sVhash)
}
inline void PrtoMktr::set_svhash(const char* value) {
  set_has_svhash();
  if (svhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svhash_ = new ::std::string;
  }
  svhash_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoMktr.sVhash)
}
inline void PrtoMktr::set_svhash(const void* value, size_t size) {
  set_has_svhash();
  if (svhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svhash_ = new ::std::string;
  }
  svhash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoMktr.sVhash)
}
inline ::std::string* PrtoMktr::mutable_svhash() {
  set_has_svhash();
  if (svhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svhash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoMktr.sVhash)
  return svhash_;
}
inline ::std::string* PrtoMktr::release_svhash() {
  clear_has_svhash();
  if (svhash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svhash_;
    svhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoMktr::set_allocated_svhash(::std::string* svhash) {
  if (svhash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svhash_;
  }
  if (svhash) {
    set_has_svhash();
    svhash_ = svhash;
  } else {
    clear_has_svhash();
    svhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoMktr.sVhash)
}

// optional int32 iVmerkeltreedataposition = 3;
inline bool PrtoMktr::has_ivmerkeltreedataposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoMktr::set_has_ivmerkeltreedataposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoMktr::clear_has_ivmerkeltreedataposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoMktr::clear_ivmerkeltreedataposition() {
  ivmerkeltreedataposition_ = 0;
  clear_has_ivmerkeltreedataposition();
}
inline ::google::protobuf::int32 PrtoMktr::ivmerkeltreedataposition() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoMktr.iVmerkeltreedataposition)
  return ivmerkeltreedataposition_;
}
inline void PrtoMktr::set_ivmerkeltreedataposition(::google::protobuf::int32 value) {
  set_has_ivmerkeltreedataposition();
  ivmerkeltreedataposition_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoMktr.iVmerkeltreedataposition)
}

// repeated .com.tomting.orion.PrtoMktr cVchildren = 4;
inline int PrtoMktr::cvchildren_size() const {
  return cvchildren_.size();
}
inline void PrtoMktr::clear_cvchildren() {
  cvchildren_.Clear();
}
inline const ::com::tomting::orion::PrtoMktr& PrtoMktr::cvchildren(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoMktr.cVchildren)
  return cvchildren_.Get(index);
}
inline ::com::tomting::orion::PrtoMktr* PrtoMktr::mutable_cvchildren(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoMktr.cVchildren)
  return cvchildren_.Mutable(index);
}
inline ::com::tomting::orion::PrtoMktr* PrtoMktr::add_cvchildren() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoMktr.cVchildren)
  return cvchildren_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoMktr >&
PrtoMktr::cvchildren() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoMktr.cVchildren)
  return cvchildren_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoMktr >*
PrtoMktr::mutable_cvchildren() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoMktr.cVchildren)
  return &cvchildren_;
}

// optional .com.tomting.orion.PrtoLkey cVkey = 5;
inline bool PrtoMktr::has_cvkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoMktr::set_has_cvkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoMktr::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoMktr::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoMktr::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoMktr.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoMktr::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoMktr.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoMktr::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoMktr::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoMktr.cVkey)
}

// optional .com.tomting.orion.PrtoLval cVvalue = 6;
inline bool PrtoMktr::has_cvvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoMktr::set_has_cvvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoMktr::clear_has_cvvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoMktr::clear_cvvalue() {
  if (cvvalue_ != NULL) cvvalue_->::com::tomting::orion::PrtoLval::Clear();
  clear_has_cvvalue();
}
inline const ::com::tomting::orion::PrtoLval& PrtoMktr::cvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoMktr.cVvalue)
  return cvvalue_ != NULL ? *cvvalue_ : *default_instance_->cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoMktr::mutable_cvvalue() {
  set_has_cvvalue();
  if (cvvalue_ == NULL) cvvalue_ = new ::com::tomting::orion::PrtoLval;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoMktr.cVvalue)
  return cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoMktr::release_cvvalue() {
  clear_has_cvvalue();
  ::com::tomting::orion::PrtoLval* temp = cvvalue_;
  cvvalue_ = NULL;
  return temp;
}
inline void PrtoMktr::set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue) {
  delete cvvalue_;
  cvvalue_ = cvvalue;
  if (cvvalue) {
    set_has_cvvalue();
  } else {
    clear_has_cvvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoMktr.cVvalue)
}

// -------------------------------------------------------------------

// PrtoQres

// required bytes sVnodeid = 1;
inline bool PrtoQres::has_svnodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoQres::set_has_svnodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoQres::clear_has_svnodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoQres::clear_svnodeid() {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_->clear();
  }
  clear_has_svnodeid();
}
inline const ::std::string& PrtoQres::svnodeid() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoQres.sVnodeid)
  return *svnodeid_;
}
inline void PrtoQres::set_svnodeid(const ::std::string& value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoQres.sVnodeid)
}
inline void PrtoQres::set_svnodeid(const char* value) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoQres.sVnodeid)
}
inline void PrtoQres::set_svnodeid(const void* value, size_t size) {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  svnodeid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoQres.sVnodeid)
}
inline ::std::string* PrtoQres::mutable_svnodeid() {
  set_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnodeid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoQres.sVnodeid)
  return svnodeid_;
}
inline ::std::string* PrtoQres::release_svnodeid() {
  clear_has_svnodeid();
  if (svnodeid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnodeid_;
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoQres::set_allocated_svnodeid(::std::string* svnodeid) {
  if (svnodeid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnodeid_;
  }
  if (svnodeid) {
    set_has_svnodeid();
    svnodeid_ = svnodeid;
  } else {
    clear_has_svnodeid();
    svnodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoQres.sVnodeid)
}

// required .com.tomting.orion.PrtoLkey cVkey = 2;
inline bool PrtoQres::has_cvkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoQres::set_has_cvkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoQres::clear_has_cvkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoQres::clear_cvkey() {
  if (cvkey_ != NULL) cvkey_->::com::tomting::orion::PrtoLkey::Clear();
  clear_has_cvkey();
}
inline const ::com::tomting::orion::PrtoLkey& PrtoQres::cvkey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoQres.cVkey)
  return cvkey_ != NULL ? *cvkey_ : *default_instance_->cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoQres::mutable_cvkey() {
  set_has_cvkey();
  if (cvkey_ == NULL) cvkey_ = new ::com::tomting::orion::PrtoLkey;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoQres.cVkey)
  return cvkey_;
}
inline ::com::tomting::orion::PrtoLkey* PrtoQres::release_cvkey() {
  clear_has_cvkey();
  ::com::tomting::orion::PrtoLkey* temp = cvkey_;
  cvkey_ = NULL;
  return temp;
}
inline void PrtoQres::set_allocated_cvkey(::com::tomting::orion::PrtoLkey* cvkey) {
  delete cvkey_;
  cvkey_ = cvkey;
  if (cvkey) {
    set_has_cvkey();
  } else {
    clear_has_cvkey();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoQres.cVkey)
}

// required bool bVresult = 3;
inline bool PrtoQres::has_bvresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoQres::set_has_bvresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoQres::clear_has_bvresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoQres::clear_bvresult() {
  bvresult_ = false;
  clear_has_bvresult();
}
inline bool PrtoQres::bvresult() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoQres.bVresult)
  return bvresult_;
}
inline void PrtoQres::set_bvresult(bool value) {
  set_has_bvresult();
  bvresult_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoQres.bVresult)
}

// required .com.tomting.orion.PrtoLval cVvalue = 4;
inline bool PrtoQres::has_cvvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoQres::set_has_cvvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoQres::clear_has_cvvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoQres::clear_cvvalue() {
  if (cvvalue_ != NULL) cvvalue_->::com::tomting::orion::PrtoLval::Clear();
  clear_has_cvvalue();
}
inline const ::com::tomting::orion::PrtoLval& PrtoQres::cvvalue() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoQres.cVvalue)
  return cvvalue_ != NULL ? *cvvalue_ : *default_instance_->cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoQres::mutable_cvvalue() {
  set_has_cvvalue();
  if (cvvalue_ == NULL) cvvalue_ = new ::com::tomting::orion::PrtoLval;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoQres.cVvalue)
  return cvvalue_;
}
inline ::com::tomting::orion::PrtoLval* PrtoQres::release_cvvalue() {
  clear_has_cvvalue();
  ::com::tomting::orion::PrtoLval* temp = cvvalue_;
  cvvalue_ = NULL;
  return temp;
}
inline void PrtoQres::set_allocated_cvvalue(::com::tomting::orion::PrtoLval* cvvalue) {
  delete cvvalue_;
  cvvalue_ = cvvalue;
  if (cvvalue) {
    set_has_cvvalue();
  } else {
    clear_has_cvvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoQres.cVvalue)
}

// required bool bVdigest = 5 [default = false];
inline bool PrtoQres::has_bvdigest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoQres::set_has_bvdigest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoQres::clear_has_bvdigest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoQres::clear_bvdigest() {
  bvdigest_ = false;
  clear_has_bvdigest();
}
inline bool PrtoQres::bvdigest() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoQres.bVdigest)
  return bvdigest_;
}
inline void PrtoQres::set_bvdigest(bool value) {
  set_has_bvdigest();
  bvdigest_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoQres.bVdigest)
}

// -------------------------------------------------------------------

// PrtoSeda

// optional bytes sVnamespace = 1;
inline bool PrtoSeda::has_svnamespace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoSeda::set_has_svnamespace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoSeda::clear_has_svnamespace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoSeda::clear_svnamespace() {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_->clear();
  }
  clear_has_svnamespace();
}
inline const ::std::string& PrtoSeda::svnamespace() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.sVnamespace)
  return *svnamespace_;
}
inline void PrtoSeda::set_svnamespace(const ::std::string& value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSeda.sVnamespace)
}
inline void PrtoSeda::set_svnamespace(const char* value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSeda.sVnamespace)
}
inline void PrtoSeda::set_svnamespace(const void* value, size_t size) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSeda.sVnamespace)
}
inline ::std::string* PrtoSeda::mutable_svnamespace() {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.sVnamespace)
  return svnamespace_;
}
inline ::std::string* PrtoSeda::release_svnamespace() {
  clear_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnamespace_;
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoSeda::set_allocated_svnamespace(::std::string* svnamespace) {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnamespace_;
  }
  if (svnamespace) {
    set_has_svnamespace();
    svnamespace_ = svnamespace;
  } else {
    clear_has_svnamespace();
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.sVnamespace)
}

// optional bytes sVtable = 2;
inline bool PrtoSeda::has_svtable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoSeda::set_has_svtable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoSeda::clear_has_svtable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoSeda::clear_svtable() {
  if (svtable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_->clear();
  }
  clear_has_svtable();
}
inline const ::std::string& PrtoSeda::svtable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.sVtable)
  return *svtable_;
}
inline void PrtoSeda::set_svtable(const ::std::string& value) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSeda.sVtable)
}
inline void PrtoSeda::set_svtable(const char* value) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSeda.sVtable)
}
inline void PrtoSeda::set_svtable(const void* value, size_t size) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSeda.sVtable)
}
inline ::std::string* PrtoSeda::mutable_svtable() {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.sVtable)
  return svtable_;
}
inline ::std::string* PrtoSeda::release_svtable() {
  clear_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtable_;
    svtable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoSeda::set_allocated_svtable(::std::string* svtable) {
  if (svtable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtable_;
  }
  if (svtable) {
    set_has_svtable();
    svtable_ = svtable;
  } else {
    clear_has_svtable();
    svtable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.sVtable)
}

// optional .com.tomting.orion.iCcompactiontype iVcompactiontype = 3;
inline bool PrtoSeda::has_ivcompactiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoSeda::set_has_ivcompactiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoSeda::clear_has_ivcompactiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoSeda::clear_ivcompactiontype() {
  ivcompactiontype_ = 0;
  clear_has_ivcompactiontype();
}
inline ::com::tomting::orion::iCcompactiontype PrtoSeda::ivcompactiontype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.iVcompactiontype)
  return static_cast< ::com::tomting::orion::iCcompactiontype >(ivcompactiontype_);
}
inline void PrtoSeda::set_ivcompactiontype(::com::tomting::orion::iCcompactiontype value) {
  assert(::com::tomting::orion::iCcompactiontype_IsValid(value));
  set_has_ivcompactiontype();
  ivcompactiontype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSeda.iVcompactiontype)
}

// optional bytes sVmessage = 4;
inline bool PrtoSeda::has_svmessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoSeda::set_has_svmessage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoSeda::clear_has_svmessage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoSeda::clear_svmessage() {
  if (svmessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmessage_->clear();
  }
  clear_has_svmessage();
}
inline const ::std::string& PrtoSeda::svmessage() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.sVmessage)
  return *svmessage_;
}
inline void PrtoSeda::set_svmessage(const ::std::string& value) {
  set_has_svmessage();
  if (svmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmessage_ = new ::std::string;
  }
  svmessage_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSeda.sVmessage)
}
inline void PrtoSeda::set_svmessage(const char* value) {
  set_has_svmessage();
  if (svmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmessage_ = new ::std::string;
  }
  svmessage_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSeda.sVmessage)
}
inline void PrtoSeda::set_svmessage(const void* value, size_t size) {
  set_has_svmessage();
  if (svmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmessage_ = new ::std::string;
  }
  svmessage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSeda.sVmessage)
}
inline ::std::string* PrtoSeda::mutable_svmessage() {
  set_has_svmessage();
  if (svmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svmessage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.sVmessage)
  return svmessage_;
}
inline ::std::string* PrtoSeda::release_svmessage() {
  clear_has_svmessage();
  if (svmessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svmessage_;
    svmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoSeda::set_allocated_svmessage(::std::string* svmessage) {
  if (svmessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svmessage_;
  }
  if (svmessage) {
    set_has_svmessage();
    svmessage_ = svmessage;
  } else {
    clear_has_svmessage();
    svmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.sVmessage)
}

// optional .com.tomting.orion.PrtoGoel cVgossipelement = 5;
inline bool PrtoSeda::has_cvgossipelement() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoSeda::set_has_cvgossipelement() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoSeda::clear_has_cvgossipelement() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoSeda::clear_cvgossipelement() {
  if (cvgossipelement_ != NULL) cvgossipelement_->::com::tomting::orion::PrtoGoel::Clear();
  clear_has_cvgossipelement();
}
inline const ::com::tomting::orion::PrtoGoel& PrtoSeda::cvgossipelement() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.cVgossipelement)
  return cvgossipelement_ != NULL ? *cvgossipelement_ : *default_instance_->cvgossipelement_;
}
inline ::com::tomting::orion::PrtoGoel* PrtoSeda::mutable_cvgossipelement() {
  set_has_cvgossipelement();
  if (cvgossipelement_ == NULL) cvgossipelement_ = new ::com::tomting::orion::PrtoGoel;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.cVgossipelement)
  return cvgossipelement_;
}
inline ::com::tomting::orion::PrtoGoel* PrtoSeda::release_cvgossipelement() {
  clear_has_cvgossipelement();
  ::com::tomting::orion::PrtoGoel* temp = cvgossipelement_;
  cvgossipelement_ = NULL;
  return temp;
}
inline void PrtoSeda::set_allocated_cvgossipelement(::com::tomting::orion::PrtoGoel* cvgossipelement) {
  delete cvgossipelement_;
  cvgossipelement_ = cvgossipelement;
  if (cvgossipelement) {
    set_has_cvgossipelement();
  } else {
    clear_has_cvgossipelement();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.cVgossipelement)
}

// optional .com.tomting.orion.PrtoLstm cVstatement = 6;
inline bool PrtoSeda::has_cvstatement() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoSeda::set_has_cvstatement() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoSeda::clear_has_cvstatement() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoSeda::clear_cvstatement() {
  if (cvstatement_ != NULL) cvstatement_->::com::tomting::orion::PrtoLstm::Clear();
  clear_has_cvstatement();
}
inline const ::com::tomting::orion::PrtoLstm& PrtoSeda::cvstatement() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.cVstatement)
  return cvstatement_ != NULL ? *cvstatement_ : *default_instance_->cvstatement_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoSeda::mutable_cvstatement() {
  set_has_cvstatement();
  if (cvstatement_ == NULL) cvstatement_ = new ::com::tomting::orion::PrtoLstm;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.cVstatement)
  return cvstatement_;
}
inline ::com::tomting::orion::PrtoLstm* PrtoSeda::release_cvstatement() {
  clear_has_cvstatement();
  ::com::tomting::orion::PrtoLstm* temp = cvstatement_;
  cvstatement_ = NULL;
  return temp;
}
inline void PrtoSeda::set_allocated_cvstatement(::com::tomting::orion::PrtoLstm* cvstatement) {
  delete cvstatement_;
  cvstatement_ = cvstatement;
  if (cvstatement) {
    set_has_cvstatement();
  } else {
    clear_has_cvstatement();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.cVstatement)
}

// optional bytes sVcallback = 7;
inline bool PrtoSeda::has_svcallback() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PrtoSeda::set_has_svcallback() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PrtoSeda::clear_has_svcallback() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PrtoSeda::clear_svcallback() {
  if (svcallback_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcallback_->clear();
  }
  clear_has_svcallback();
}
inline const ::std::string& PrtoSeda::svcallback() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.sVcallback)
  return *svcallback_;
}
inline void PrtoSeda::set_svcallback(const ::std::string& value) {
  set_has_svcallback();
  if (svcallback_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcallback_ = new ::std::string;
  }
  svcallback_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSeda.sVcallback)
}
inline void PrtoSeda::set_svcallback(const char* value) {
  set_has_svcallback();
  if (svcallback_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcallback_ = new ::std::string;
  }
  svcallback_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSeda.sVcallback)
}
inline void PrtoSeda::set_svcallback(const void* value, size_t size) {
  set_has_svcallback();
  if (svcallback_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcallback_ = new ::std::string;
  }
  svcallback_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSeda.sVcallback)
}
inline ::std::string* PrtoSeda::mutable_svcallback() {
  set_has_svcallback();
  if (svcallback_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcallback_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.sVcallback)
  return svcallback_;
}
inline ::std::string* PrtoSeda::release_svcallback() {
  clear_has_svcallback();
  if (svcallback_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svcallback_;
    svcallback_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoSeda::set_allocated_svcallback(::std::string* svcallback) {
  if (svcallback_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svcallback_;
  }
  if (svcallback) {
    set_has_svcallback();
    svcallback_ = svcallback;
  } else {
    clear_has_svcallback();
    svcallback_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.sVcallback)
}

// optional .com.tomting.orion.PrtoLqry cVquery = 8;
inline bool PrtoSeda::has_cvquery() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PrtoSeda::set_has_cvquery() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PrtoSeda::clear_has_cvquery() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PrtoSeda::clear_cvquery() {
  if (cvquery_ != NULL) cvquery_->::com::tomting::orion::PrtoLqry::Clear();
  clear_has_cvquery();
}
inline const ::com::tomting::orion::PrtoLqry& PrtoSeda::cvquery() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.cVquery)
  return cvquery_ != NULL ? *cvquery_ : *default_instance_->cvquery_;
}
inline ::com::tomting::orion::PrtoLqry* PrtoSeda::mutable_cvquery() {
  set_has_cvquery();
  if (cvquery_ == NULL) cvquery_ = new ::com::tomting::orion::PrtoLqry;
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.cVquery)
  return cvquery_;
}
inline ::com::tomting::orion::PrtoLqry* PrtoSeda::release_cvquery() {
  clear_has_cvquery();
  ::com::tomting::orion::PrtoLqry* temp = cvquery_;
  cvquery_ = NULL;
  return temp;
}
inline void PrtoSeda::set_allocated_cvquery(::com::tomting::orion::PrtoLqry* cvquery) {
  delete cvquery_;
  cvquery_ = cvquery;
  if (cvquery) {
    set_has_cvquery();
  } else {
    clear_has_cvquery();
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSeda.cVquery)
}

// repeated .com.tomting.orion.PrtoQres cVlistqueryresult = 9;
inline int PrtoSeda::cvlistqueryresult_size() const {
  return cvlistqueryresult_.size();
}
inline void PrtoSeda::clear_cvlistqueryresult() {
  cvlistqueryresult_.Clear();
}
inline const ::com::tomting::orion::PrtoQres& PrtoSeda::cvlistqueryresult(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.cVlistqueryresult)
  return cvlistqueryresult_.Get(index);
}
inline ::com::tomting::orion::PrtoQres* PrtoSeda::mutable_cvlistqueryresult(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.cVlistqueryresult)
  return cvlistqueryresult_.Mutable(index);
}
inline ::com::tomting::orion::PrtoQres* PrtoSeda::add_cvlistqueryresult() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoSeda.cVlistqueryresult)
  return cvlistqueryresult_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoQres >&
PrtoSeda::cvlistqueryresult() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoSeda.cVlistqueryresult)
  return cvlistqueryresult_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoQres >*
PrtoSeda::mutable_cvlistqueryresult() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoSeda.cVlistqueryresult)
  return &cvlistqueryresult_;
}

// repeated .com.tomting.orion.PrtoGoel cVlistgossipelement = 10;
inline int PrtoSeda::cvlistgossipelement_size() const {
  return cvlistgossipelement_.size();
}
inline void PrtoSeda::clear_cvlistgossipelement() {
  cvlistgossipelement_.Clear();
}
inline const ::com::tomting::orion::PrtoGoel& PrtoSeda::cvlistgossipelement(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSeda.cVlistgossipelement)
  return cvlistgossipelement_.Get(index);
}
inline ::com::tomting::orion::PrtoGoel* PrtoSeda::mutable_cvlistgossipelement(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSeda.cVlistgossipelement)
  return cvlistgossipelement_.Mutable(index);
}
inline ::com::tomting::orion::PrtoGoel* PrtoSeda::add_cvlistgossipelement() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoSeda.cVlistgossipelement)
  return cvlistgossipelement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >&
PrtoSeda::cvlistgossipelement() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoSeda.cVlistgossipelement)
  return cvlistgossipelement_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoGoel >*
PrtoSeda::mutable_cvlistgossipelement() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoSeda.cVlistgossipelement)
  return &cvlistgossipelement_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace orion
}  // namespace tomting
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::tomting::orion::iCcompactiontype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCcompactiontype>() {
  return ::com::tomting::orion::iCcompactiontype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PrtoSeda_2eproto__INCLUDED
