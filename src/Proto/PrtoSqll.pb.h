// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PrtoSqll.proto

#ifndef PROTOBUF_PrtoSqll_2eproto__INCLUDED
#define PROTOBUF_PrtoSqll_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace tomting {
namespace orion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PrtoSqll_2eproto();
void protobuf_AssignDesc_PrtoSqll_2eproto();
void protobuf_ShutdownFile_PrtoSqll_2eproto();

class PrtoScol;
class PrtoSctl;

enum iCsqllcolumntype {
  STRING = 0,
  INTEGER = 1,
  STRINGLIST = 2
};
bool iCsqllcolumntype_IsValid(int value);
const iCsqllcolumntype iCsqllcolumntype_MIN = STRING;
const iCsqllcolumntype iCsqllcolumntype_MAX = STRINGLIST;
const int iCsqllcolumntype_ARRAYSIZE = iCsqllcolumntype_MAX + 1;

const ::google::protobuf::EnumDescriptor* iCsqllcolumntype_descriptor();
inline const ::std::string& iCsqllcolumntype_Name(iCsqllcolumntype value) {
  return ::google::protobuf::internal::NameOfEnum(
    iCsqllcolumntype_descriptor(), value);
}
inline bool iCsqllcolumntype_Parse(
    const ::std::string& name, iCsqllcolumntype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iCsqllcolumntype>(
    iCsqllcolumntype_descriptor(), name, value);
}
// ===================================================================

class PrtoScol : public ::google::protobuf::Message {
 public:
  PrtoScol();
  virtual ~PrtoScol();

  PrtoScol(const PrtoScol& from);

  inline PrtoScol& operator=(const PrtoScol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoScol& default_instance();

  void Swap(PrtoScol* other);

  // implements Message ----------------------------------------------

  PrtoScol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoScol& from);
  void MergeFrom(const PrtoScol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVcolumn = 1;
  inline bool has_svcolumn() const;
  inline void clear_svcolumn();
  static const int kSVcolumnFieldNumber = 1;
  inline const ::std::string& svcolumn() const;
  inline void set_svcolumn(const ::std::string& value);
  inline void set_svcolumn(const char* value);
  inline void set_svcolumn(const void* value, size_t size);
  inline ::std::string* mutable_svcolumn();
  inline ::std::string* release_svcolumn();
  inline void set_allocated_svcolumn(::std::string* svcolumn);

  // required bool bViskey = 2 [default = false];
  inline bool has_bviskey() const;
  inline void clear_bviskey();
  static const int kBViskeyFieldNumber = 2;
  inline bool bviskey() const;
  inline void set_bviskey(bool value);

  // required .com.tomting.orion.iCsqllcolumntype iVtype = 3 [default = STRING];
  inline bool has_ivtype() const;
  inline void clear_ivtype();
  static const int kIVtypeFieldNumber = 3;
  inline ::com::tomting::orion::iCsqllcolumntype ivtype() const;
  inline void set_ivtype(::com::tomting::orion::iCsqllcolumntype value);

  // optional uint32 iVlength = 4;
  inline bool has_ivlength() const;
  inline void clear_ivlength();
  static const int kIVlengthFieldNumber = 4;
  inline ::google::protobuf::uint32 ivlength() const;
  inline void set_ivlength(::google::protobuf::uint32 value);

  // optional uint32 iVleftposition = 5;
  inline bool has_ivleftposition() const;
  inline void clear_ivleftposition();
  static const int kIVleftpositionFieldNumber = 5;
  inline ::google::protobuf::uint32 ivleftposition() const;
  inline void set_ivleftposition(::google::protobuf::uint32 value);

  // optional uint32 iVrightposition = 6;
  inline bool has_ivrightposition() const;
  inline void clear_ivrightposition();
  static const int kIVrightpositionFieldNumber = 6;
  inline ::google::protobuf::uint32 ivrightposition() const;
  inline void set_ivrightposition(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoScol)
 private:
  inline void set_has_svcolumn();
  inline void clear_has_svcolumn();
  inline void set_has_bviskey();
  inline void clear_has_bviskey();
  inline void set_has_ivtype();
  inline void clear_has_ivtype();
  inline void set_has_ivlength();
  inline void clear_has_ivlength();
  inline void set_has_ivleftposition();
  inline void clear_has_ivleftposition();
  inline void set_has_ivrightposition();
  inline void clear_has_ivrightposition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svcolumn_;
  bool bviskey_;
  int ivtype_;
  ::google::protobuf::uint32 ivlength_;
  ::google::protobuf::uint32 ivleftposition_;
  ::google::protobuf::uint32 ivrightposition_;
  friend void  protobuf_AddDesc_PrtoSqll_2eproto();
  friend void protobuf_AssignDesc_PrtoSqll_2eproto();
  friend void protobuf_ShutdownFile_PrtoSqll_2eproto();

  void InitAsDefaultInstance();
  static PrtoScol* default_instance_;
};
// -------------------------------------------------------------------

class PrtoSctl : public ::google::protobuf::Message {
 public:
  PrtoSctl();
  virtual ~PrtoSctl();

  PrtoSctl(const PrtoSctl& from);

  inline PrtoSctl& operator=(const PrtoSctl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrtoSctl& default_instance();

  void Swap(PrtoSctl* other);

  // implements Message ----------------------------------------------

  PrtoSctl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrtoSctl& from);
  void MergeFrom(const PrtoSctl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sVnamespace = 1;
  inline bool has_svnamespace() const;
  inline void clear_svnamespace();
  static const int kSVnamespaceFieldNumber = 1;
  inline const ::std::string& svnamespace() const;
  inline void set_svnamespace(const ::std::string& value);
  inline void set_svnamespace(const char* value);
  inline void set_svnamespace(const void* value, size_t size);
  inline ::std::string* mutable_svnamespace();
  inline ::std::string* release_svnamespace();
  inline void set_allocated_svnamespace(::std::string* svnamespace);

  // required bytes sVtable = 2;
  inline bool has_svtable() const;
  inline void clear_svtable();
  static const int kSVtableFieldNumber = 2;
  inline const ::std::string& svtable() const;
  inline void set_svtable(const ::std::string& value);
  inline void set_svtable(const char* value);
  inline void set_svtable(const void* value, size_t size);
  inline ::std::string* mutable_svtable();
  inline ::std::string* release_svtable();
  inline void set_allocated_svtable(::std::string* svtable);

  // repeated .com.tomting.orion.PrtoScol cVcolumns = 3;
  inline int cvcolumns_size() const;
  inline void clear_cvcolumns();
  static const int kCVcolumnsFieldNumber = 3;
  inline const ::com::tomting::orion::PrtoScol& cvcolumns(int index) const;
  inline ::com::tomting::orion::PrtoScol* mutable_cvcolumns(int index);
  inline ::com::tomting::orion::PrtoScol* add_cvcolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoScol >&
      cvcolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoScol >*
      mutable_cvcolumns();

  // optional bytes sVterminatedby = 4 [default = ";"];
  inline bool has_svterminatedby() const;
  inline void clear_svterminatedby();
  static const int kSVterminatedbyFieldNumber = 4;
  inline const ::std::string& svterminatedby() const;
  inline void set_svterminatedby(const ::std::string& value);
  inline void set_svterminatedby(const char* value);
  inline void set_svterminatedby(const void* value, size_t size);
  inline ::std::string* mutable_svterminatedby();
  inline ::std::string* release_svterminatedby();
  inline void set_allocated_svterminatedby(::std::string* svterminatedby);

  // optional uint32 iVlimitrows = 5;
  inline bool has_ivlimitrows() const;
  inline void clear_ivlimitrows();
  static const int kIVlimitrowsFieldNumber = 5;
  inline ::google::protobuf::uint32 ivlimitrows() const;
  inline void set_ivlimitrows(::google::protobuf::uint32 value);

  // optional bytes sVlistseparator = 6 [default = "|"];
  inline bool has_svlistseparator() const;
  inline void clear_svlistseparator();
  static const int kSVlistseparatorFieldNumber = 6;
  inline const ::std::string& svlistseparator() const;
  inline void set_svlistseparator(const ::std::string& value);
  inline void set_svlistseparator(const char* value);
  inline void set_svlistseparator(const void* value, size_t size);
  inline ::std::string* mutable_svlistseparator();
  inline ::std::string* release_svlistseparator();
  inline void set_allocated_svlistseparator(::std::string* svlistseparator);

  // @@protoc_insertion_point(class_scope:com.tomting.orion.PrtoSctl)
 private:
  inline void set_has_svnamespace();
  inline void clear_has_svnamespace();
  inline void set_has_svtable();
  inline void clear_has_svtable();
  inline void set_has_svterminatedby();
  inline void clear_has_svterminatedby();
  inline void set_has_ivlimitrows();
  inline void clear_has_ivlimitrows();
  inline void set_has_svlistseparator();
  inline void clear_has_svlistseparator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* svnamespace_;
  ::std::string* svtable_;
  ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoScol > cvcolumns_;
  static ::std::string* _default_svterminatedby_;
  ::std::string* svterminatedby_;
  static ::std::string* _default_svlistseparator_;
  ::std::string* svlistseparator_;
  ::google::protobuf::uint32 ivlimitrows_;
  friend void  protobuf_AddDesc_PrtoSqll_2eproto();
  friend void protobuf_AssignDesc_PrtoSqll_2eproto();
  friend void protobuf_ShutdownFile_PrtoSqll_2eproto();

  void InitAsDefaultInstance();
  static PrtoSctl* default_instance_;
};
// ===================================================================


// ===================================================================

// PrtoScol

// required bytes sVcolumn = 1;
inline bool PrtoScol::has_svcolumn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoScol::set_has_svcolumn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoScol::clear_has_svcolumn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoScol::clear_svcolumn() {
  if (svcolumn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_->clear();
  }
  clear_has_svcolumn();
}
inline const ::std::string& PrtoScol::svcolumn() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoScol.sVcolumn)
  return *svcolumn_;
}
inline void PrtoScol::set_svcolumn(const ::std::string& value) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoScol.sVcolumn)
}
inline void PrtoScol::set_svcolumn(const char* value) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoScol.sVcolumn)
}
inline void PrtoScol::set_svcolumn(const void* value, size_t size) {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  svcolumn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoScol.sVcolumn)
}
inline ::std::string* PrtoScol::mutable_svcolumn() {
  set_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svcolumn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoScol.sVcolumn)
  return svcolumn_;
}
inline ::std::string* PrtoScol::release_svcolumn() {
  clear_has_svcolumn();
  if (svcolumn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svcolumn_;
    svcolumn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoScol::set_allocated_svcolumn(::std::string* svcolumn) {
  if (svcolumn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svcolumn_;
  }
  if (svcolumn) {
    set_has_svcolumn();
    svcolumn_ = svcolumn;
  } else {
    clear_has_svcolumn();
    svcolumn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoScol.sVcolumn)
}

// required bool bViskey = 2 [default = false];
inline bool PrtoScol::has_bviskey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoScol::set_has_bviskey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoScol::clear_has_bviskey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoScol::clear_bviskey() {
  bviskey_ = false;
  clear_has_bviskey();
}
inline bool PrtoScol::bviskey() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoScol.bViskey)
  return bviskey_;
}
inline void PrtoScol::set_bviskey(bool value) {
  set_has_bviskey();
  bviskey_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoScol.bViskey)
}

// required .com.tomting.orion.iCsqllcolumntype iVtype = 3 [default = STRING];
inline bool PrtoScol::has_ivtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrtoScol::set_has_ivtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrtoScol::clear_has_ivtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrtoScol::clear_ivtype() {
  ivtype_ = 0;
  clear_has_ivtype();
}
inline ::com::tomting::orion::iCsqllcolumntype PrtoScol::ivtype() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoScol.iVtype)
  return static_cast< ::com::tomting::orion::iCsqllcolumntype >(ivtype_);
}
inline void PrtoScol::set_ivtype(::com::tomting::orion::iCsqllcolumntype value) {
  assert(::com::tomting::orion::iCsqllcolumntype_IsValid(value));
  set_has_ivtype();
  ivtype_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoScol.iVtype)
}

// optional uint32 iVlength = 4;
inline bool PrtoScol::has_ivlength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoScol::set_has_ivlength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoScol::clear_has_ivlength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoScol::clear_ivlength() {
  ivlength_ = 0u;
  clear_has_ivlength();
}
inline ::google::protobuf::uint32 PrtoScol::ivlength() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoScol.iVlength)
  return ivlength_;
}
inline void PrtoScol::set_ivlength(::google::protobuf::uint32 value) {
  set_has_ivlength();
  ivlength_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoScol.iVlength)
}

// optional uint32 iVleftposition = 5;
inline bool PrtoScol::has_ivleftposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoScol::set_has_ivleftposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoScol::clear_has_ivleftposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoScol::clear_ivleftposition() {
  ivleftposition_ = 0u;
  clear_has_ivleftposition();
}
inline ::google::protobuf::uint32 PrtoScol::ivleftposition() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoScol.iVleftposition)
  return ivleftposition_;
}
inline void PrtoScol::set_ivleftposition(::google::protobuf::uint32 value) {
  set_has_ivleftposition();
  ivleftposition_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoScol.iVleftposition)
}

// optional uint32 iVrightposition = 6;
inline bool PrtoScol::has_ivrightposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoScol::set_has_ivrightposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoScol::clear_has_ivrightposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoScol::clear_ivrightposition() {
  ivrightposition_ = 0u;
  clear_has_ivrightposition();
}
inline ::google::protobuf::uint32 PrtoScol::ivrightposition() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoScol.iVrightposition)
  return ivrightposition_;
}
inline void PrtoScol::set_ivrightposition(::google::protobuf::uint32 value) {
  set_has_ivrightposition();
  ivrightposition_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoScol.iVrightposition)
}

// -------------------------------------------------------------------

// PrtoSctl

// required bytes sVnamespace = 1;
inline bool PrtoSctl::has_svnamespace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrtoSctl::set_has_svnamespace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrtoSctl::clear_has_svnamespace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrtoSctl::clear_svnamespace() {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_->clear();
  }
  clear_has_svnamespace();
}
inline const ::std::string& PrtoSctl::svnamespace() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSctl.sVnamespace)
  return *svnamespace_;
}
inline void PrtoSctl::set_svnamespace(const ::std::string& value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSctl.sVnamespace)
}
inline void PrtoSctl::set_svnamespace(const char* value) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSctl.sVnamespace)
}
inline void PrtoSctl::set_svnamespace(const void* value, size_t size) {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  svnamespace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSctl.sVnamespace)
}
inline ::std::string* PrtoSctl::mutable_svnamespace() {
  set_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svnamespace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSctl.sVnamespace)
  return svnamespace_;
}
inline ::std::string* PrtoSctl::release_svnamespace() {
  clear_has_svnamespace();
  if (svnamespace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svnamespace_;
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoSctl::set_allocated_svnamespace(::std::string* svnamespace) {
  if (svnamespace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svnamespace_;
  }
  if (svnamespace) {
    set_has_svnamespace();
    svnamespace_ = svnamespace;
  } else {
    clear_has_svnamespace();
    svnamespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSctl.sVnamespace)
}

// required bytes sVtable = 2;
inline bool PrtoSctl::has_svtable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrtoSctl::set_has_svtable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrtoSctl::clear_has_svtable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrtoSctl::clear_svtable() {
  if (svtable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_->clear();
  }
  clear_has_svtable();
}
inline const ::std::string& PrtoSctl::svtable() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSctl.sVtable)
  return *svtable_;
}
inline void PrtoSctl::set_svtable(const ::std::string& value) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSctl.sVtable)
}
inline void PrtoSctl::set_svtable(const char* value) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSctl.sVtable)
}
inline void PrtoSctl::set_svtable(const void* value, size_t size) {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  svtable_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSctl.sVtable)
}
inline ::std::string* PrtoSctl::mutable_svtable() {
  set_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    svtable_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSctl.sVtable)
  return svtable_;
}
inline ::std::string* PrtoSctl::release_svtable() {
  clear_has_svtable();
  if (svtable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = svtable_;
    svtable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrtoSctl::set_allocated_svtable(::std::string* svtable) {
  if (svtable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete svtable_;
  }
  if (svtable) {
    set_has_svtable();
    svtable_ = svtable;
  } else {
    clear_has_svtable();
    svtable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSctl.sVtable)
}

// repeated .com.tomting.orion.PrtoScol cVcolumns = 3;
inline int PrtoSctl::cvcolumns_size() const {
  return cvcolumns_.size();
}
inline void PrtoSctl::clear_cvcolumns() {
  cvcolumns_.Clear();
}
inline const ::com::tomting::orion::PrtoScol& PrtoSctl::cvcolumns(int index) const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSctl.cVcolumns)
  return cvcolumns_.Get(index);
}
inline ::com::tomting::orion::PrtoScol* PrtoSctl::mutable_cvcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSctl.cVcolumns)
  return cvcolumns_.Mutable(index);
}
inline ::com::tomting::orion::PrtoScol* PrtoSctl::add_cvcolumns() {
  // @@protoc_insertion_point(field_add:com.tomting.orion.PrtoSctl.cVcolumns)
  return cvcolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoScol >&
PrtoSctl::cvcolumns() const {
  // @@protoc_insertion_point(field_list:com.tomting.orion.PrtoSctl.cVcolumns)
  return cvcolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::tomting::orion::PrtoScol >*
PrtoSctl::mutable_cvcolumns() {
  // @@protoc_insertion_point(field_mutable_list:com.tomting.orion.PrtoSctl.cVcolumns)
  return &cvcolumns_;
}

// optional bytes sVterminatedby = 4 [default = ";"];
inline bool PrtoSctl::has_svterminatedby() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrtoSctl::set_has_svterminatedby() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrtoSctl::clear_has_svterminatedby() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrtoSctl::clear_svterminatedby() {
  if (svterminatedby_ != _default_svterminatedby_) {
    svterminatedby_->assign(*_default_svterminatedby_);
  }
  clear_has_svterminatedby();
}
inline const ::std::string& PrtoSctl::svterminatedby() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSctl.sVterminatedby)
  return *svterminatedby_;
}
inline void PrtoSctl::set_svterminatedby(const ::std::string& value) {
  set_has_svterminatedby();
  if (svterminatedby_ == _default_svterminatedby_) {
    svterminatedby_ = new ::std::string;
  }
  svterminatedby_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSctl.sVterminatedby)
}
inline void PrtoSctl::set_svterminatedby(const char* value) {
  set_has_svterminatedby();
  if (svterminatedby_ == _default_svterminatedby_) {
    svterminatedby_ = new ::std::string;
  }
  svterminatedby_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSctl.sVterminatedby)
}
inline void PrtoSctl::set_svterminatedby(const void* value, size_t size) {
  set_has_svterminatedby();
  if (svterminatedby_ == _default_svterminatedby_) {
    svterminatedby_ = new ::std::string;
  }
  svterminatedby_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSctl.sVterminatedby)
}
inline ::std::string* PrtoSctl::mutable_svterminatedby() {
  set_has_svterminatedby();
  if (svterminatedby_ == _default_svterminatedby_) {
    svterminatedby_ = new ::std::string(*_default_svterminatedby_);
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSctl.sVterminatedby)
  return svterminatedby_;
}
inline ::std::string* PrtoSctl::release_svterminatedby() {
  clear_has_svterminatedby();
  if (svterminatedby_ == _default_svterminatedby_) {
    return NULL;
  } else {
    ::std::string* temp = svterminatedby_;
    svterminatedby_ = const_cast< ::std::string*>(_default_svterminatedby_);
    return temp;
  }
}
inline void PrtoSctl::set_allocated_svterminatedby(::std::string* svterminatedby) {
  if (svterminatedby_ != _default_svterminatedby_) {
    delete svterminatedby_;
  }
  if (svterminatedby) {
    set_has_svterminatedby();
    svterminatedby_ = svterminatedby;
  } else {
    clear_has_svterminatedby();
    svterminatedby_ = const_cast< ::std::string*>(_default_svterminatedby_);
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSctl.sVterminatedby)
}

// optional uint32 iVlimitrows = 5;
inline bool PrtoSctl::has_ivlimitrows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrtoSctl::set_has_ivlimitrows() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrtoSctl::clear_has_ivlimitrows() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrtoSctl::clear_ivlimitrows() {
  ivlimitrows_ = 0u;
  clear_has_ivlimitrows();
}
inline ::google::protobuf::uint32 PrtoSctl::ivlimitrows() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSctl.iVlimitrows)
  return ivlimitrows_;
}
inline void PrtoSctl::set_ivlimitrows(::google::protobuf::uint32 value) {
  set_has_ivlimitrows();
  ivlimitrows_ = value;
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSctl.iVlimitrows)
}

// optional bytes sVlistseparator = 6 [default = "|"];
inline bool PrtoSctl::has_svlistseparator() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrtoSctl::set_has_svlistseparator() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrtoSctl::clear_has_svlistseparator() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrtoSctl::clear_svlistseparator() {
  if (svlistseparator_ != _default_svlistseparator_) {
    svlistseparator_->assign(*_default_svlistseparator_);
  }
  clear_has_svlistseparator();
}
inline const ::std::string& PrtoSctl::svlistseparator() const {
  // @@protoc_insertion_point(field_get:com.tomting.orion.PrtoSctl.sVlistseparator)
  return *svlistseparator_;
}
inline void PrtoSctl::set_svlistseparator(const ::std::string& value) {
  set_has_svlistseparator();
  if (svlistseparator_ == _default_svlistseparator_) {
    svlistseparator_ = new ::std::string;
  }
  svlistseparator_->assign(value);
  // @@protoc_insertion_point(field_set:com.tomting.orion.PrtoSctl.sVlistseparator)
}
inline void PrtoSctl::set_svlistseparator(const char* value) {
  set_has_svlistseparator();
  if (svlistseparator_ == _default_svlistseparator_) {
    svlistseparator_ = new ::std::string;
  }
  svlistseparator_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.tomting.orion.PrtoSctl.sVlistseparator)
}
inline void PrtoSctl::set_svlistseparator(const void* value, size_t size) {
  set_has_svlistseparator();
  if (svlistseparator_ == _default_svlistseparator_) {
    svlistseparator_ = new ::std::string;
  }
  svlistseparator_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.tomting.orion.PrtoSctl.sVlistseparator)
}
inline ::std::string* PrtoSctl::mutable_svlistseparator() {
  set_has_svlistseparator();
  if (svlistseparator_ == _default_svlistseparator_) {
    svlistseparator_ = new ::std::string(*_default_svlistseparator_);
  }
  // @@protoc_insertion_point(field_mutable:com.tomting.orion.PrtoSctl.sVlistseparator)
  return svlistseparator_;
}
inline ::std::string* PrtoSctl::release_svlistseparator() {
  clear_has_svlistseparator();
  if (svlistseparator_ == _default_svlistseparator_) {
    return NULL;
  } else {
    ::std::string* temp = svlistseparator_;
    svlistseparator_ = const_cast< ::std::string*>(_default_svlistseparator_);
    return temp;
  }
}
inline void PrtoSctl::set_allocated_svlistseparator(::std::string* svlistseparator) {
  if (svlistseparator_ != _default_svlistseparator_) {
    delete svlistseparator_;
  }
  if (svlistseparator) {
    set_has_svlistseparator();
    svlistseparator_ = svlistseparator;
  } else {
    clear_has_svlistseparator();
    svlistseparator_ = const_cast< ::std::string*>(_default_svlistseparator_);
  }
  // @@protoc_insertion_point(field_set_allocated:com.tomting.orion.PrtoSctl.sVlistseparator)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace orion
}  // namespace tomting
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::tomting::orion::iCsqllcolumntype> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::tomting::orion::iCsqllcolumntype>() {
  return ::com::tomting::orion::iCsqllcolumntype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PrtoSqll_2eproto__INCLUDED
